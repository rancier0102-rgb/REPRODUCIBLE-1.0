name: ðŸš€ Generate Movie Chunks

on:
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - '**.json'
      - 'generate-chunks.js'
      - '.github/workflows/*.yml'

permissions:
  contents: write

jobs:
  generate:
    runs-on: ubuntu-latest
    
    steps:
    - name: ðŸ“¥ Checkout
      uses: actions/checkout@v4
    
    - name: ðŸ”§ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: ðŸ“ Prepare directories and files
      run: |
        echo "=== Preparando ambiente ==="
        
        # Crear directorios necesarios
        mkdir -p chunks
        mkdir -p data
        
        # Mostrar estructura actual
        echo ""
        echo "ðŸ“ Estructura del repositorio:"
        ls -la
        
        echo ""
        echo "ðŸ“„ Archivos JSON encontrados:"
        find . -name "*.json" -type f | head -20
        
        # Si no hay JSONs, crear uno de ejemplo
        if [ -z "$(find . -name "peliculas*.json" -type f)" ]; then
          echo ""
          echo "âš ï¸ No se encontraron archivos de pelÃ­culas, creando ejemplo..."
          cat > data/peliculas_ejemplo.json << 'EJEMPLO'
          [
            {
              "titulo": "PelÃ­cula Ejemplo 1",
              "enlace": "https://example.com/ver/1",
              "poster": "https://via.placeholder.com/300x450/FF0000/FFFFFF?text=Ejemplo+1",
              "ano": 2024,
              "genero": "AcciÃ³n",
              "calidad": "HD"
            },
            {
              "titulo": "PelÃ­cula Ejemplo 2",
              "enlace": "https://example.com/ver/2",
              "poster": "https://via.placeholder.com/300x450/00FF00/FFFFFF?text=Ejemplo+2",
              "ano": 2023,
              "genero": "Comedia",
              "calidad": "4K"
            }
          ]
          EJEMPLO
          echo "âœ… Archivo de ejemplo creado"
        fi
    
    - name: ðŸš€ Generate chunks with inline script
      run: |
        echo "=== Generando chunks ==="
        
        cat > generator.js << 'GENERATOR_SCRIPT'
        const fs = require('fs');
        const path = require('path');
        
        console.log('ðŸš€ Iniciando generaciÃ³n de chunks\n');
        console.log('Directorio actual:', process.cwd());
        console.log('Archivos en el directorio:');
        console.log(fs.readdirSync('.').filter(f => !f.startsWith('.')).join(', '));
        console.log('');
        
        // ConfiguraciÃ³n de perÃ­odos
        const PERIODS = [
          { id: 'latest', name: 'Ãšltimos Estrenos', years: [2025, 2024, 2023], priority: 1 },
          { id: 'recent', name: 'Recientes', years: [2022, 2021, 2020], priority: 2 },
          { id: '2010s', name: 'DÃ©cada 2010', years: Array.from({length: 10}, (_, i) => 2019 - i), priority: 3 },
          { id: '2000s', name: 'DÃ©cada 2000', years: Array.from({length: 10}, (_, i) => 2009 - i), priority: 4 },
          { id: '90s', name: 'AÃ±os 90', years: Array.from({length: 10}, (_, i) => 1999 - i), priority: 5 },
          { id: 'classics', name: 'ClÃ¡sicas', years: 'rest', priority: 6 }
        ];
        
        // Buscar archivos JSON de pelÃ­culas
        function findMovieFiles() {
          const patterns = [
            './data/*.json',
            './peliculas*.json',
            './*peliculas*.json',
            './movies*.json'
          ];
          
          const files = new Set();
          
          // Buscar en data/
          if (fs.existsSync('./data')) {
            fs.readdirSync('./data')
              .filter(f => f.endsWith('.json'))
              .forEach(f => files.add(path.join('./data', f)));
          }
          
          // Buscar en raÃ­z
          fs.readdirSync('.')
            .filter(f => f.endsWith('.json') && !f.includes('package') && !f.includes('manifest'))
            .forEach(f => files.add(`./${f}`));
          
          return Array.from(files);
        }
        
        // Cargar todas las pelÃ­culas
        function loadMovies(files) {
          const allMovies = [];
          
          files.forEach(file => {
            try {
              console.log(`ðŸ“„ Procesando: ${file}`);
              const content = fs.readFileSync(file, 'utf8');
              
              // Intentar parsear el JSON
              let data;
              try {
                data = JSON.parse(content);
              } catch (e) {
                console.log(`  âš ï¸ Error parseando JSON: ${e.message}`);
                return;
              }
              
              // Extraer aÃ±o del nombre del archivo si es posible
              const yearMatch = path.basename(file).match(/(\d{4})/);
              const defaultYear = yearMatch ? parseInt(yearMatch[1]) : new Date().getFullYear();
              
              // Normalizar estructura de datos
              let movies = [];
              if (Array.isArray(data)) {
                movies = data;
              } else if (data && typeof data === 'object') {
                if (data.peliculas && Array.isArray(data.peliculas)) {
                  movies = data.peliculas;
                } else if (data.movies && Array.isArray(data.movies)) {
                  movies = data.movies;
                } else if (data.titulo || data.title) {
                  movies = [data];
                }
              }
              
              // Procesar cada pelÃ­cula
              movies.forEach((movie, idx) => {
                if (movie && (movie.titulo || movie.title)) {
                  // Asegurar que tenga aÃ±o
                  if (!movie.year && !movie.ano && !movie.aÃ±o) {
                    movie.year = defaultYear;
                  }
                  allMovies.push(movie);
                }
              });
              
              console.log(`  âœ… ${movies.length} pelÃ­culas cargadas`);
              
            } catch (error) {
              console.log(`  âŒ Error procesando ${file}: ${error.message}`);
            }
          });
          
          return allMovies;
        }
        
        // Comprimir campos de pelÃ­cula
        function compressMovie(movie) {
          return {
            t: movie.titulo || movie.title || 'Sin tÃ­tulo',
            l: movie.enlace || movie.link || movie.url || '#',
            y: parseInt(movie.year || movie.ano || movie.aÃ±o || 2024),
            p: movie.poster || movie.image || movie.imagen || '',
            g: movie.genero || movie.genre || movie.categoria || '',
            q: movie.quality || movie.calidad || movie.qualidade || ''
          };
        }
        
        // MAIN
        try {
          // Encontrar archivos
          const files = findMovieFiles();
          console.log(`\nðŸ“ Archivos encontrados: ${files.length}`);
          
          if (files.length === 0) {
            console.log('âš ï¸ No se encontraron archivos JSON de pelÃ­culas');
            
            // Crear manifest vacÃ­o
            const emptyManifest = {
              version: '2.0.0',
              generated: new Date().toISOString(),
              statistics: { totalMovies: 0 },
              chunks: []
            };
            fs.writeFileSync('./manifest.json', JSON.stringify(emptyManifest, null, 2));
            console.log('ðŸ“„ Manifest vacÃ­o creado');
            process.exit(0);
          }
          
          // Cargar pelÃ­culas
          const allMovies = loadMovies(files);
          console.log(`\nðŸŽ¬ Total de pelÃ­culas cargadas: ${allMovies.length}`);
          
          if (allMovies.length === 0) {
            console.log('âš ï¸ No se encontraron pelÃ­culas en los archivos');
            const emptyManifest = {
              version: '2.0.0',
              generated: new Date().toISOString(),
              statistics: { totalMovies: 0 },
              chunks: []
            };
            fs.writeFileSync('./manifest.json', JSON.stringify(emptyManifest, null, 2));
            process.exit(0);
          }
          
          // Comprimir y eliminar duplicados
          const uniqueMovies = new Map();
          allMovies.forEach(movie => {
            const compressed = compressMovie(movie);
            const key = `${compressed.t}_${compressed.y}`.toLowerCase();
            if (!uniqueMovies.has(key)) {
              uniqueMovies.set(key, compressed);
            }
          });
          
          const processedMovies = Array.from(uniqueMovies.values());
          console.log(`ðŸ“Š PelÃ­culas Ãºnicas despuÃ©s de procesar: ${processedMovies.length}`);
          
          // Crear chunks por perÃ­odo
          console.log('\nðŸ“¦ Creando chunks por perÃ­odo:');
          
          if (!fs.existsSync('./chunks')) {
            fs.mkdirSync('./chunks', { recursive: true });
          }
          
          const manifest = {
            version: '2.0.0',
            generated: new Date().toISOString(),
            repository: {
              user: process.env.GITHUB_REPOSITORY ? process.env.GITHUB_REPOSITORY.split('/')[0] : 'unknown',
              repo: process.env.GITHUB_REPOSITORY ? process.env.GITHUB_REPOSITORY.split('/')[1] : 'unknown'
            },
            statistics: {
              totalMovies: processedMovies.length,
              years: {
                min: Math.min(...processedMovies.map(m => m.y)),
                max: Math.max(...processedMovies.map(m => m.y))
              }
            },
            chunks: []
          };
          
          const usedYears = new Set();
          
          // Generar chunks por perÃ­odo
          PERIODS.forEach(period => {
            let periodMovies;
            
            if (period.years === 'rest') {
              // Todas las pelÃ­culas de aÃ±os no usados
              periodMovies = processedMovies.filter(m => !usedYears.has(m.y));
            } else {
              // PelÃ­culas de aÃ±os especÃ­ficos
              periodMovies = processedMovies.filter(m => period.years.includes(m.y));
              period.years.forEach(y => usedYears.add(y));
            }
            
            if (periodMovies.length > 0) {
              const chunk = {
                id: period.id,
                name: period.name,
                generated: new Date().toISOString(),
                count: periodMovies.length,
                priority: period.priority,
                movies: periodMovies.sort((a, b) => b.y - a.y || a.t.localeCompare(b.t))
              };
              
              const chunkPath = `./chunks/${period.id}.json`;
              fs.writeFileSync(chunkPath, JSON.stringify(chunk));
              
              manifest.chunks.push({
                id: period.id,
                name: period.name,
                file: `chunks/${period.id}.json`,
                movies: periodMovies.length,
                priority: period.priority,
                size: Buffer.byteLength(JSON.stringify(chunk)),
                sizeKB: (Buffer.byteLength(JSON.stringify(chunk)) / 1024).toFixed(1)
              });
              
              console.log(`  âœ… ${period.name}: ${periodMovies.length} pelÃ­culas`);
            }
          });
          
          // Si no hay chunks por perÃ­odo, crear uno con todas las pelÃ­culas
          if (manifest.chunks.length === 0 && processedMovies.length > 0) {
            console.log('\nâš ï¸ No se pudieron crear chunks por perÃ­odo, creando chunk Ãºnico...');
            
            const allChunk = {
              id: 'all',
              name: 'Todas las pelÃ­culas',
              generated: new Date().toISOString(),
              count: processedMovies.length,
              priority: 1,
              movies: processedMovies
            };
            
            fs.writeFileSync('./chunks/all.json', JSON.stringify(allChunk));
            
            manifest.chunks.push({
              id: 'all',
              name: 'Todas las pelÃ­culas',
              file: 'chunks/all.json',
              movies: processedMovies.length,
              priority: 1,
              size: Buffer.byteLength(JSON.stringify(allChunk)),
              sizeKB: (Buffer.byteLength(JSON.stringify(allChunk)) / 1024).toFixed(1)
            });
            
            console.log(`  âœ… Chunk Ãºnico: ${processedMovies.length} pelÃ­culas`);
          }
          
          // Guardar manifest
          fs.writeFileSync('./manifest.json', JSON.stringify(manifest, null, 2));
          
          console.log('\nâœ… GENERACIÃ“N COMPLETADA');
          console.log('ðŸ“‹ Resumen:');
          console.log(`  â€¢ Total de pelÃ­culas: ${processedMovies.length}`);
          console.log(`  â€¢ Chunks generados: ${manifest.chunks.length}`);
          console.log(`  â€¢ AÃ±os: ${manifest.statistics.years.min} - ${manifest.statistics.years.max}`);
          
        } catch (error) {
          console.error('\nâŒ ERROR FATAL:', error);
          console.error(error.stack);
          process.exit(1);
        }
        GENERATOR_SCRIPT
        
        # Ejecutar el generador
        node generator.js
        
        # Verificar resultados
        echo ""
        echo "=== Verificando resultados ==="
        
        if [ -f manifest.json ]; then
          echo "âœ… manifest.json creado"
          echo "ðŸ“Š Contenido:"
          cat manifest.json | head -20
        else
          echo "âŒ No se creÃ³ manifest.json"
        fi
        
        echo ""
        echo "ðŸ“¦ Archivos en chunks/:"
        ls -la chunks/ 2>/dev/null || echo "No hay archivos en chunks/"
    
    - name: ðŸ’¾ Commit changes
      run: |
        # Configurar Git
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        
        # Ver cambios
        echo "=== Cambios detectados ==="
        git status
        
        # Agregar archivos
        git add -A
        
        # Hacer commit solo si hay cambios
        if git diff --staged --quiet; then
          echo "ðŸ“ No hay cambios para commitear"
        else
          git commit -m "ðŸŽ¬ Auto-generated chunks" \
                     -m "Generated at: $(date '+%Y-%m-%d %H:%M:%S UTC')" \
                     -m "Action run: ${{ github.run_number }}"
          
          # Push
          git push origin main || {
            echo "âš ï¸ Push fallÃ³, intentando pull primero..."
            git pull --rebase origin main
            git push origin main
          }
          
          echo "âœ… Cambios subidos exitosamente"
        fi
    
    - name: ðŸ“Š Final Summary
      if: always()
      run: |
        echo "### ðŸŽ¬ GeneraciÃ³n de Chunks Completada" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ -f manifest.json ]; then
          TOTAL=$(grep -o '"totalMovies":[0-9]*' manifest.json | grep -o '[0-9]*' || echo "0")
          CHUNKS=$(grep -c '"id":' manifest.json || echo "0")
          
          echo "âœ… **Estado:** Exitoso" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“Š **PelÃ­culas totales:** $TOTAL" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“¦ **Chunks generados:** $CHUNKS" >> $GITHUB_STEP_SUMMARY
        else
          echo "âš ï¸ **Estado:** Sin datos generados" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ•’ **Fecha:** $(date '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ”¢ **Run:** #${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
