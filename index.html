<!DOCTYPE html> 
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Latino VOD+ - Plataforma Multi-Fuente Optimizada</title>
<style>
/* ESTILOS BASE - Mantengo los mismos pero optimizados */
:root {
    --primary-color: #e50914;
    --secondary-color: #46d369;
    --background-dark: #141414;
    --background-card: #181818;
    --background-secondary: #222;
    --text-light: #fff;
    --muted: #b3b3b3;
    --radius: 8px;
    --transition: 0.25s ease;
    --focus-shadow: 0 0 25px rgba(229, 9, 20, 0.9);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
    font-family: 'Segoe UI', Arial, sans-serif;
    background: var(--background-dark);
    color: var(--text-light);
    overflow-x: hidden;
    -webkit-font-smoothing: antialiased;
}

/* Optimizaci√≥n: Usar will-change para animaciones predecibles */
.movie-card,
.carousel-track {
    will-change: transform;
}

/* Loader mejorado con mejor performance */
.loader {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    z-index: 1000;
    background: rgba(20, 20, 20, 0.95);
    padding: 30px;
    border-radius: 15px;
    min-width: 300px;
    backdrop-filter: blur(10px);
}

.loader-spinner {
    width: 50px;
    height: 50px;
    border: 3px solid rgba(229, 9, 20, 0.3);
    border-top: 3px solid var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 20px;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.loader-text {
    color: var(--text-light);
    font-size: 1.2rem;
    margin-bottom: 10px;
}

.loader-progress {
    margin-top: 10px;
    color: var(--muted);
    font-size: 0.9rem;
}

.loader-sources {
    margin-top: 20px;
    text-align: left;
    max-height: 200px;
    overflow-y: auto;
}

.loader-source-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 5px;
    margin: 5px 0;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.05);
}

.loader-source-status {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--muted);
    flex-shrink: 0;
}

.loader-source-status.loading {
    background: #ffa500;
    animation: pulse 1s infinite;
}

.loader-source-status.success {
    background: var(--secondary-color);
}

.loader-source-status.error {
    background: #ff4444;
}

.loader.hidden {
    display: none;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

/* HEADER */
header {
    padding: 15px 40px;
    background: rgba(0,0,0,0.9);
    position: sticky;
    top: 0;
    display: flex;
    gap: 15px;
    align-items: center;
    z-index: 10;
    backdrop-filter: blur(10px);
    flex-wrap: wrap;
}

.logo { 
    font-weight: bold; 
    font-size: 1.8rem; 
    color: var(--primary-color);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
}

.search-container {
    flex: 1;
    max-width: 400px;
    margin: 0 auto;
    position: relative;
}

.search-input {
    width: 100%;
    padding: 8px 40px 8px 15px;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 25px;
    color: var(--text-light);
    font-size: 0.95rem;
    transition: all 0.3s ease;
}

.search-input:focus {
    outline: none;
    background: rgba(255,255,255,0.15);
    border-color: var(--primary-color);
}

.search-clear {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: var(--muted);
    cursor: pointer;
    padding: 5px;
    display: none;
}

.search-clear.visible {
    display: block;
}

/* SOURCE SELECTOR */
.source-selector {
    display: flex;
    gap: 10px;
    align-items: center;
    padding: 10px 40px;
    background: rgba(0,0,0,0.5);
    border-bottom: 1px solid rgba(255,255,255,0.1);
    overflow-x: auto;
    scrollbar-width: thin;
    -webkit-overflow-scrolling: touch;
}

.source-btn {
    padding: 8px 16px;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 20px;
    color: var(--text-light);
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.3s ease;
    white-space: nowrap;
    position: relative;
}

.source-btn.active {
    background: var(--primary-color);
    border-color: var(--primary-color);
}

.source-btn .badge {
    position: absolute;
    top: -5px;
    right: -5px;
    background: var(--secondary-color);
    color: white;
    font-size: 0.7rem;
    padding: 2px 6px;
    border-radius: 10px;
    font-weight: bold;
}

/* CATEGORY FILTER */
.category-filter {
    display: flex;
    gap: 10px;
    padding: 10px 40px;
    background: rgba(0,0,0,0.3);
    overflow-x: auto;
    scrollbar-width: thin;
    -webkit-overflow-scrolling: touch;
}

.category-btn {
    padding: 6px 14px;
    background: transparent;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 15px;
    color: var(--muted);
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.3s ease;
    white-space: nowrap;
}

.category-btn.active {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

/* MAIN CONTENT */
.main-content {
    padding: 20px 0;
    min-height: 500px;
}

/* PROVIDER SECTIONS */
.provider-section {
    margin-bottom: 50px;
    opacity: 0;
    animation: fadeIn 0.5s ease-out forwards;
}

@keyframes fadeIn {
    from { 
        opacity: 0; 
        transform: translateY(20px); 
    }
    to { 
        opacity: 1; 
        transform: translateY(0); 
    }
}

.provider-header {
    padding: 0 40px;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    border-left: 4px solid var(--primary-color);
}

.provider-title {
    font-size: 1.8rem;
    font-weight: 600;
    color: var(--text-light);
}

/* YEAR SECTIONS */
.year-section {
    margin-bottom: 40px;
}

.year-header {
    padding: 0 40px;
    margin-bottom: 15px;
    display: flex;
    align-items: center;
    gap: 15px;
}

.year-title {
    font-size: 1.3rem;
    font-weight: 500;
    color: var(--text-light);
}

/* CAROUSEL */
.carousel-container {
    position: relative;
    padding: 0 40px;
}

.carousel-track {
    display: flex;
    gap: 12px;
    overflow-x: auto;
    scroll-behavior: smooth;
    scrollbar-width: none;
    padding: 10px 0;
    -webkit-overflow-scrolling: touch;
}

.carousel-track::-webkit-scrollbar {
    display: none;
}

.carousel-nav {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 40px;
    height: 80%;
    background: linear-gradient(90deg, rgba(20,20,20,0.95), transparent);
    border: none;
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    z-index: 5;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.carousel-container:hover .carousel-nav {
    opacity: 1;
}

/* MOVIE CARDS - Optimizado */
.movie-card {
    flex: 0 0 150px;
    background: transparent;
    border-radius: 5px;
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    border: 2px solid transparent;
    contain: layout style paint;
}

.movie-card.skeleton {
    background: linear-gradient(90deg, #2a2a2a 25%, #333 50%, #2a2a2a 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
    height: 225px;
}

@keyframes loading {
    to { background-position-x: -200%; }
}

.movie-card img { 
    width: 100%; 
    height: auto;
    aspect-ratio: 2/3;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.movie-card img.loaded {
    opacity: 1;
}

.movie-source-badge {
    position: absolute;
    top: 5px;
    right: 5px;
    padding: 3px 8px;
    background: rgba(0,0,0,0.8);
    color: white;
    font-size: 0.65rem;
    border-radius: 10px;
    font-weight: bold;
    z-index: 2;
}

.movie-card:hover {
    transform: scale(1.05);
    z-index: 3;
}

/* MOVIE DETAIL OVERLAY */
.movie-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--background-dark);
    z-index: 100;
    overflow-y: auto;
    animation: slideIn 0.3s ease-out;
}

/* Responsive */
@media (max-width: 768px) {
    header {
        padding: 15px;
    }
    
    .movie-card {
        flex: 0 0 110px;
    }
    
    .carousel-nav {
        display: none;
    }
}

/* ... resto de estilos ... */
</style>
</head>
<body>

<div class="loader" id="loader">
    <div class="loader-spinner"></div>
    <div class="loader-text">Cargando pel√≠culas...</div>
    <div class="loader-progress" id="loaderProgress"></div>
    <div class="loader-sources" id="loaderSources"></div>
</div>

<header>
    <div class="logo">MOVIES+</div>
    
    <div class="search-container">
        <input type="text" 
               class="search-input" 
               id="searchInput" 
               placeholder="Buscar pel√≠culas..."
               autocomplete="off">
        <button class="search-clear" id="searchClear">‚úï</button>
    </div>
    
    <div class="status-bar">
        <div class="movie-count" id="movieCount">0 pel√≠culas</div>
        <div class="status-indicator connected" id="statusIndicator">
            <span id="statusText">Conectado</span>
        </div>
    </div>
</header>

<div class="source-selector" id="sourceSelector">
    <span class="source-label">Fuentes:</span>
    <button class="source-btn active" data-source="all">
        Todas
        <span class="badge" id="allCount">0</span>
    </button>
</div>

<div class="category-filter" id="categoryFilter">
    <button class="category-btn active" data-category="all">Todas</button>
</div>

<button class="back-button" id="backButton">
    <span>‚Üê</span>
    <span>Volver</span>
</button>

<main class="main-content" id="mainContent"></main>

<div id="movieOverlay" class="movie-overlay">
    <span class="close" id="closeButton">√ó</span>
    <!-- Contenido del overlay -->
</div>

<script>
/**
 * ========================================
 * PLATAFORMA OPTIMIZADA MULTI-FUENTE
 * Version 2.0 - Performance Enhanced
 * ========================================
 */

class OptimizedMoviesPlatform {
    constructor() {
        // Configuraci√≥n de fuentes con ejemplos reales
        this.sources = [
            {
                id: 'peliculas_2024',
                name: 'üìÖ Pel√≠culas 2024',
                url: 'https://raw.githubusercontent.com/TU_USUARIO/TU_REPO/main/peliculas_2024.json',
                enabled: true,
                priority: 1,
                color: '#e50914',
                movies: [],
                status: 'pending',
                retryCount: 0,
                maxRetries: 3
            },
            {
                id: 'peliculas_2023',
                name: 'üìÖ Pel√≠culas 2023',
                url: 'https://raw.githubusercontent.com/TU_USUARIO/TU_REPO/main/peliculas_2023.json',
                enabled: true,
                priority: 2,
                color: '#46d369',
                movies: [],
                status: 'pending',
                retryCount: 0,
                maxRetries: 3
            },
            {
                id: 'peliculas_2022',
                name: 'üìÖ Pel√≠culas 2022',
                url: 'https://raw.githubusercontent.com/TU_USUARIO/TU_REPO/main/peliculas_2022.json',
                enabled: true,
                priority: 3,
                color: '#ffa500',
                movies: [],
                status: 'pending',
                retryCount: 0,
                maxRetries: 3
            },
            {
                id: 'peliculas_2021',
                name: 'üìÖ Pel√≠culas 2021',
                url: 'https://raw.githubusercontent.com/TU_USUARIO/TU_REPO/main/peliculas_2021.json',
                enabled: true,
                priority: 4,
                color: '#00a8e1',
                movies: [],
                status: 'pending',
                retryCount: 0,
                maxRetries: 3
            },
            {
                id: 'clasicos',
                name: 'üé¨ Cl√°sicos',
                url: 'https://raw.githubusercontent.com/TU_USUARIO/TU_REPO/main/clasicos.json',
                enabled: true,
                priority: 5,
                color: '#9b59b6',
                movies: [],
                status: 'pending',
                retryCount: 0,
                maxRetries: 3
            },
            {
                id: 'animacion',
                name: 'üé® Animaci√≥n',
                url: 'https://raw.githubusercontent.com/TU_USUARIO/TU_REPO/main/animacion.json',
                enabled: true,
                priority: 6,
                color: '#ff69b4',
                movies: [],
                status: 'pending',
                retryCount: 0,
                maxRetries: 3
            },
            {
                id: 'accion',
                name: 'üí• Acci√≥n',
                url: 'https://raw.githubusercontent.com/TU_USUARIO/TU_REPO/main/accion.json',
                enabled: true,
                priority: 7,
                color: '#ff4444',
                movies: [],
                status: 'pending',
                retryCount: 0,
                maxRetries: 3
            },
            {
                id: 'terror',
                name: 'üëª Terror',
                url: 'https://raw.githubusercontent.com/TU_USUARIO/TU_REPO/main/terror.json',
                enabled: true,
                priority: 8,
                color: '#8b0000',
                movies: [],
                status: 'pending',
                retryCount: 0,
                maxRetries: 3
            },
            {
                id: 'comedia',
                name: 'üòÇ Comedia',
                url: 'https://raw.githubusercontent.com/TU_USUARIO/TU_REPO/main/comedia.json',
                enabled: true,
                priority: 9,
                color: '#ffeb3b',
                movies: [],
                status: 'pending',
                retryCount: 0,
                maxRetries: 3
            },
            {
                id: 'romance',
                name: 'üíï Romance',
                url: 'https://raw.githubusercontent.com/TU_USUARIO/TU_REPO/main/romance.json',
                enabled: true,
                priority: 10,
                color: '#ff1493',
                movies: [],
                status: 'pending',
                retryCount: 0,
                maxRetries: 3
            }
        ];
        
        // Optimizaciones de rendimiento
        this.config = {
            cacheEnabled: true,
            cacheExpiry: 7200000, // 2 horas
            concurrentLoads: 5, // Cargar 5 fuentes en paralelo
            batchSize: 20, // Renderizar pel√≠culas en lotes
            debounceDelay: 300, // Delay para b√∫squeda
            lazyLoadOffset: 100, // Pixels antes de cargar im√°genes
            useWebWorkers: typeof Worker !== 'undefined',
            compressionEnabled: true,
            retryDelay: 2000 // 2 segundos entre reintentos
        };
        
        // Estado de la aplicaci√≥n
        this.state = {
            allMovies: [],
            filteredMovies: [],
            displayedMovies: new Set(),
            currentSource: 'all',
            currentCategory: 'all',
            searchQuery: '',
            isLoading: false,
            loadedSources: 0,
            failedSources: [],
            totalMoviesCount: 0,
            renderQueue: [],
            imageCache: new Map(),
            abortController: null
        };
        
        // √çndices para b√∫squeda r√°pida
        this.indexes = {
            byTitle: new Map(),
            byYear: new Map(),
            byCategory: new Map(),
            bySource: new Map()
        };
        
        // Inicializaci√≥n
        this.init();
    }
    
    async init() {
        this.cacheDOMElements();
        this.setupEventListeners();
        this.setupObservers();
        this.loadCachedSources();
        await this.loadAllSources();
        this.setupAutoRefresh();
    }
    
    cacheDOMElements() {
        // Cachear todos los elementos del DOM una sola vez
        this.elements = {
            loader: document.getElementById('loader'),
            loaderProgress: document.getElementById('loaderProgress'),
            loaderSources: document.getElementById('loaderSources'),
            mainContent: document.getElementById('mainContent'),
            movieCount: document.getElementById('movieCount'),
            searchInput: document.getElementById('searchInput'),
            searchClear: document.getElementById('searchClear'),
            sourceSelector: document.getElementById('sourceSelector'),
            categoryFilter: document.getElementById('categoryFilter'),
            statusText: document.getElementById('statusText'),
            allCount: document.getElementById('allCount'),
            backButton: document.getElementById('backButton'),
            movieOverlay: document.getElementById('movieOverlay'),
            closeButton: document.getElementById('closeButton')
        };
    }
    
    setupEventListeners() {
        // B√∫squeda con debounce
        let searchTimeout;
        this.elements.searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => this.handleSearch(e.target.value), this.config.debounceDelay);
            this.elements.searchClear.classList.toggle('visible', e.target.value.length > 0);
        });
        
        this.elements.searchClear.addEventListener('click', () => this.clearSearch());
        
        // Delegaci√≥n de eventos para mejor rendimiento
        this.elements.sourceSelector.addEventListener('click', (e) => {
            const btn = e.target.closest('.source-btn');
            if (btn) this.selectSource(btn.dataset.source);
        });
        
        this.elements.categoryFilter.addEventListener('click', (e) => {
            const btn = e.target.closest('.category-btn');
            if (btn) this.selectCategory(btn.dataset.category);
        });
        
        // Navegaci√≥n del overlay
        this.elements.backButton.addEventListener('click', () => this.closeMovieDetail());
        this.elements.closeButton.addEventListener('click', () => this.closeMovieDetail());
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') this.closeMovieDetail();
            if (e.key === '/' && e.ctrlKey) {
                e.preventDefault();
                this.elements.searchInput.focus();
            }
        });
    }
    
    setupObservers() {
        // Intersection Observer para lazy loading optimizado
        this.imageObserver = new IntersectionObserver(
            (entries) => {
                const toLoad = entries.filter(e => e.isIntersecting);
                this.batchLoadImages(toLoad.map(e => e.target));
            },
            {
                rootMargin: `${this.config.lazyLoadOffset}px`,
                threshold: 0.01
            }
        );
        
        // Mutation Observer para detectar cambios en el DOM
        this.mutationObserver = new MutationObserver(() => {
            this.observeNewImages();
        });
        
        this.mutationObserver.observe(this.elements.mainContent, {
            childList: true,
            subtree: true
        });
    }
    
    async loadAllSources() {
        this.showLoader(true);
        this.renderLoadingProgress();
        
        // Cancelar cargas anteriores si existen
        if (this.state.abortController) {
            this.state.abortController.abort();
        }
        this.state.abortController = new AbortController();
        
        // Ordenar fuentes por prioridad
        const sortedSources = [...this.sources]
            .filter(s => s.enabled)
            .sort((a, b) => a.priority - b.priority);
        
        // Cargar en lotes paralelos
        const chunks = this.chunkArray(sortedSources, this.config.concurrentLoads);
        
        for (const chunk of chunks) {
            await Promise.allSettled(
                chunk.map(source => this.loadSourceWithRetry(source))
            );
        }
        
        // Procesar resultados
        this.processLoadedMovies();
        this.buildIndexes();
        this.renderContent();
        this.updateUI();
        this.showLoader(false);
        
        // Guardar en cach√©
        this.saveToCache();
    }
    
    async loadSourceWithRetry(source) {
        while (source.retryCount < source.maxRetries) {
            try {
                await this.loadSource(source);
                return;
            } catch (error) {
                source.retryCount++;
                if (source.retryCount < source.maxRetries) {
                    await this.delay(this.config.retryDelay * source.retryCount);
                } else {
                    this.handleSourceError(source, error);
                }
            }
        }
    }
    
    async loadSource(source) {
        this.updateSourceStatus(source.id, 'loading');
        
        // Verificar cach√© primero
        const cached = this.getCachedData(source.id);
        if (cached && !this.isCacheExpired(cached.timestamp)) {
            source.movies = cached.data;
            source.status = 'success';
            this.state.loadedSources++;
            this.updateSourceStatus(source.id, 'success');
            return;
        }
        
        // Fetch con timeout y abort signal
        const response = await fetch(source.url, {
            signal: this.state.abortController.signal,
            headers: {
                'Cache-Control': 'max-age=3600',
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        // Parsear JSON de manera eficiente
        const text = await response.text();
        const data = JSON.parse(text);
        
        // Procesar pel√≠culas
        source.movies = this.parseMovies(data, source);
        source.status = 'success';
        source.lastUpdate = Date.now();
        
        // Actualizar estado
        this.state.loadedSources++;
        this.updateSourceStatus(source.id, 'success');
        
        // Guardar en cach√©
        this.setCachedData(source.id, source.movies);
    }
    
    parseMovies(data, source) {
        const movies = [];
        let items = data.peliculas || data.movies || data.items || data;
        
        if (!Array.isArray(items)) {
            items = Object.values(items);
        }
        
        items.forEach((item, index) => {
            if (this.isValidMovie(item)) {
                movies.push(this.normalizeMovie(item, source, index));
            }
        });
        
        return movies;
    }
    
    isValidMovie(item) {
        return item && 
               (item.titulo || item.title || item.nombre) && 
               (item.enlace || item.url || item.link);
    }
    
    normalizeMovie(item, source, index) {
        return {
            id: `${source.id}_${index}_${Date.now()}`,
            titulo: item.titulo || item.title || item.nombre,
            poster: this.normalizePosterUrl(item.poster || item.imagen || item.image),
            ano: item.ano || item.year || item.a√±o || new Date().getFullYear(),
            enlace: item.enlace || item.url || item.link,
            source: source.name,
            sourceId: source.id,
            sourceColor: source.color,
            categoria: this.normalizeCategory(item.categoria || item.genero || item.genre),
            descripcion: item.descripcion || item.description || item.sinopsis || '',
            duracion: item.duracion || item.duration || null,
            calidad: item.calidad || item.quality || 'HD',
            idioma: item.idioma || item.language || 'Espa√±ol',
            _searchText: null // Se calcular√° despu√©s
        };
    }
    
    normalizePosterUrl(url) {
        if (!url) return this.getPlaceholderImage();
        
        // Si es una URL relativa, convertir a absoluta
        if (url.startsWith('//')) {
            return 'https:' + url;
        }
        
        // Verificar si es una URL v√°lida
        try {
            new URL(url);
            return url;
        } catch {
            return this.getPlaceholderImage();
        }
    }
    
    normalizeCategory(category) {
        if (!category) return 'general';
        
        const normalized = category.toLowerCase().trim();
        const categoryMap = {
            'action': 'accion',
            'comedy': 'comedia',
            'drama': 'drama',
            'horror': 'terror',
            'sci-fi': 'scifi',
            'science fiction': 'scifi',
            'romance': 'romance',
            'animation': 'animacion',
            'thriller': 'thriller',
            'adventure': 'aventura',
            'fantasy': 'fantasia',
            'documentary': 'documental'
        };
        
        return categoryMap[normalized] || normalized;
    }
    
    processLoadedMovies() {
        // Combinar todas las pel√≠culas
        this.state.allMovies = [];
        
        this.sources.forEach(source => {
            if (source.enabled && source.movies.length > 0) {
                this.state.allMovies.push(...source.movies);
            }
        });
        
        // Crear texto de b√∫squeda para cada pel√≠cula (optimizaci√≥n)
        this.state.allMovies.forEach(movie => {
            movie._searchText = `${movie.titulo} ${movie.ano} ${movie.categoria} ${movie.source}`.toLowerCase();
        });
        
        // Eliminar duplicados
        this.removeDuplicates();
        
        // Actualizar contador
        this.state.totalMoviesCount = this.state.allMovies.length;
    }
    
    removeDuplicates() {
        const seen = new Map();
        const unique = [];
        
        this.state.allMovies.forEach(movie => {
            const key = `${movie.titulo.toLowerCase()}_${movie.ano}`;
            
            if (!seen.has(key)) {
                seen.set(key, true);
                unique.push(movie);
            } else {
                // Si hay duplicado, preferir el de mayor prioridad
                const existing = unique.find(m => 
                    m.titulo.toLowerCase() === movie.titulo.toLowerCase() && 
                    m.ano === movie.ano
                );
                
                const existingSource = this.sources.find(s => s.id === existing.sourceId);
                const currentSource = this.sources.find(s => s.id === movie.sourceId);
                
                if (currentSource.priority < existingSource.priority) {
                    const index = unique.indexOf(existing);
                    unique[index] = movie;
                }
            }
        });
        
        this.state.allMovies = unique;
    }
    
    buildIndexes() {
        // Limpiar √≠ndices
        this.indexes.byTitle.clear();
        this.indexes.byYear.clear();
        this.indexes.byCategory.clear();
        this.indexes.bySource.clear();
        
        // Construir √≠ndices para b√∫squeda r√°pida
        this.state.allMovies.forEach(movie => {
            // √çndice por t√≠tulo
            const titleKey = movie.titulo.charAt(0).toLowerCase();
            if (!this.indexes.byTitle.has(titleKey)) {
                this.indexes.byTitle.set(titleKey, []);
            }
            this.indexes.byTitle.get(titleKey).push(movie);
            
            // √çndice por a√±o
            if (!this.indexes.byYear.has(movie.ano)) {
                this.indexes.byYear.set(movie.ano, []);
            }
            this.indexes.byYear.get(movie.ano).push(movie);
            
            // √çndice por categor√≠a
            if (!this.indexes.byCategory.has(movie.categoria)) {
                this.indexes.byCategory.set(movie.categoria, []);
            }
            this.indexes.byCategory.get(movie.categoria).push(movie);
            
            // √çndice por fuente
            if (!this.indexes.bySource.has(movie.sourceId)) {
                this.indexes.bySource.set(movie.sourceId, []);
            }
            this.indexes.bySource.get(movie.sourceId).push(movie);
        });
    }
    
    renderContent() {
        const movies = this.getFilteredMovies();
        
        if (movies.length === 0) {
            this.renderEmptyState();
            return;
        }
        
        // Usar DocumentFragment para mejor rendimiento
        const fragment = document.createDocumentFragment();
        
        if (this.state.currentSource === 'all') {
            // Renderizar por fuente
            this.sources
                .filter(s => s.enabled && s.movies.length > 0)
                .forEach(source => {
                    const sourceMovies = movies.filter(m => m.sourceId === source.id);
                    if (sourceMovies.length > 0) {
                        fragment.appendChild(this.createSourceSection(source, sourceMovies));
                    }
                });
        } else {
            // Renderizar por a√±o
            const moviesByYear = this.groupMoviesByYear(movies);
            Object.entries(moviesByYear)
                .sort(([a], [b]) => b - a)
                .forEach(([year, yearMovies]) => {
                    fragment.appendChild(this.createYearSection(year, yearMovies));
                });
        }
        
        // Actualizar DOM una sola vez
        this.elements.mainContent.innerHTML = '';
        this.elements.mainContent.appendChild(fragment);
        
        // Observar nuevas im√°genes
        this.observeNewImages();
    }
    
    createSourceSection(source, movies) {
        const section = document.createElement('div');
        section.className = 'provider-section';
        section.innerHTML = `
            <div class="provider-header" style="border-left-color: ${source.color}">
                <h2 class="provider-title">${source.name}</h2>
                <div class="provider-info">
                    <span class="provider-count">${movies.length} pel√≠culas</span>
                </div>
            </div>
        `;
        
        // Agrupar por a√±o
        const moviesByYear = this.groupMoviesByYear(movies);
        Object.entries(moviesByYear)
            .sort(([a], [b]) => b - a)
            .forEach(([year, yearMovies]) => {
                section.appendChild(this.createYearSection(year, yearMovies));
            });
        
        return section;
    }
    
    createYearSection(year, movies) {
        const section = document.createElement('div');
        section.className = 'year-section';
        section.innerHTML = `
            <div class="year-header">
                <h2 class="year-title">${year}</h2>
                <span class="year-count">(${movies.length})</span>
            </div>
        `;
        
        const container = document.createElement('div');
        container.className = 'carousel-container';
        
        // Navegaci√≥n
        const prevBtn = document.createElement('button');
        prevBtn.className = 'carousel-nav prev';
        prevBtn.innerHTML = '‚Äπ';
        prevBtn.onclick = () => this.scrollCarousel(track, -1);
        
        const nextBtn = document.createElement('button');
        nextBtn.className = 'carousel-nav next';
        nextBtn.innerHTML = '‚Ä∫';
        nextBtn.onclick = () => this.scrollCarousel(track, 1);
        
        // Track con pel√≠culas
        const track = document.createElement('div');
        track.className = 'carousel-track';
        
        // Renderizar pel√≠culas en lotes
        const fragment = document.createDocumentFragment();
        movies.forEach(movie => {
            fragment.appendChild(this.createMovieCard(movie));
        });
        track.appendChild(fragment);
        
        container.appendChild(prevBtn);
        container.appendChild(nextBtn);
        container.appendChild(track);
        section.appendChild(container);
        
        return section;
    }
    
    createMovieCard(movie) {
        const card = document.createElement('div');
        card.className = 'movie-card skeleton';
        card.dataset.movieId = movie.id;
        
        card.innerHTML = `
            <div class="movie-source-badge" style="background-color: ${movie.sourceColor}">
                ${movie.source.substring(0, 3).toUpperCase()}
            </div>
            <img data-src="${movie.poster}" alt="${movie.titulo}" loading="lazy">
            <div class="play-overlay">
                <div class="play-icon"></div>
            </div>
            <div class="movie-card-title">${movie.titulo}</div>
        `;
        
        card.onclick = () => this.openMovieDetail(movie);
        
        return card;
    }
    
    observeNewImages() {
        const images = this.elements.mainContent.querySelectorAll('img[data-src]');
        images.forEach(img => this.imageObserver.observe(img));
    }
    
    batchLoadImages(images) {
        // Cargar im√°genes en lotes para mejor rendimiento
        const batch = images.slice(0, this.config.batchSize);
        
        batch.forEach(img => {
            this.loadImage(img);
            this.imageObserver.unobserve(img);
        });
        
        // Programar siguiente lote
        if (images.length > this.config.batchSize) {
            requestAnimationFrame(() => {
                this.batchLoadImages(images.slice(this.config.batchSize));
            });
        }
    }
    
    loadImage(img) {
        const src = img.dataset.src;
        if (!src || img.src === src) return;
        
        // Verificar cach√©
        if (this.state.imageCache.has(src)) {
            img.src = this.state.imageCache.get(src);
            img.classList.add('loaded');
            img.closest('.movie-card')?.classList.remove('skeleton');
            return;
        }
        
        // Cargar imagen
        const tempImg = new Image();
        tempImg.onload = () => {
            img.src = src;
            img.classList.add('loaded');
            img.closest('.movie-card')?.classList.remove('skeleton');
            this.state.imageCache.set(src, src);
        };
        
        tempImg.onerror = () => {
            const placeholder = this.getPlaceholderImage(img.alt);
            img.src = placeholder;
            img.classList.add('loaded');
            img.closest('.movie-card')?.classList.remove('skeleton');
        };
        
        tempImg.src = src;
    }
    
    scrollCarousel(track, direction) {
        const cardWidth = 162; // 150px + 12px gap
        track.scrollBy({
            left: cardWidth * 3 * direction,
            behavior: 'smooth'
        });
    }
    
    getFilteredMovies() {
        let movies = [...this.state.allMovies];
        
        // Filtrar por fuente
        if (this.state.currentSource !== 'all') {
            movies = this.indexes.bySource.get(this.state.currentSource) || [];
        }
        
        // Filtrar por categor√≠a
        if (this.state.currentCategory !== 'all') {
            movies = movies.filter(m => m.categoria === this.state.currentCategory);
        }
        
        // Filtrar por b√∫squeda
        if (this.state.searchQuery) {
            const query = this.state.searchQuery.toLowerCase();
            movies = movies.filter(m => m._searchText.includes(query));
        }
        
        return movies;
    }
    
    groupMoviesByYear(movies) {
        const grouped = {};
        movies.forEach(movie => {
            const year = movie.ano || 'Sin fecha';
            if (!grouped[year]) grouped[year] = [];
            grouped[year].push(movie);
        });
        return grouped;
    }
    
    handleSearch(query) {
        this.state.searchQuery = query.trim();
        this.renderContent();
        this.updateMovieCount();
    }
    
    clearSearch() {
        this.elements.searchInput.value = '';
        this.elements.searchClear.classList.remove('visible');
        this.state.searchQuery = '';
        this.renderContent();
        this.updateMovieCount();
    }
    
    selectSource(sourceId) {
        this.state.currentSource = sourceId;
        
        document.querySelectorAll('.source-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.source === sourceId);
        });
        
        this.renderContent();
        this.updateMovieCount();
    }
    
    selectCategory(category) {
        this.state.currentCategory = category;
        
        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.category === category);
        });
        
        this.renderContent();
        this.updateMovieCount();
    }
    
    openMovieDetail(movie) {
        // Implementar apertura de detalle
        console.log('Abrir pel√≠cula:', movie);
        // Aqu√≠ ir√≠a la l√≥gica del overlay
    }
    
    closeMovieDetail() {
        this.elements.movieOverlay.style.display = 'none';
        this.elements.backButton.classList.remove('visible');
        history.replaceState(null, '', window.location.pathname);
    }
    
    updateUI() {
        this.updateSourceButtons();
        this.updateCategoryButtons();
        this.updateMovieCount();
        this.updateStatus();
    }
    
    updateSourceButtons() {
        // Limpiar botones existentes
        const existingBtns = this.elements.sourceSelector.querySelectorAll('.source-btn:not([data-source="all"])');
        existingBtns.forEach(btn => btn.remove());
        
        // Crear nuevos botones
        const fragment = document.createDocumentFragment();
        this.sources
            .filter(s => s.enabled && s.movies.length > 0)
            .forEach(source => {
                const btn = document.createElement('button');
                btn.className = 'source-btn';
                btn.dataset.source = source.id;
                btn.innerHTML = `
                    ${source.name}
                    <span class="badge">${source.movies.length}</span>
                `;
                fragment.appendChild(btn);
            });
        
        this.elements.sourceSelector.appendChild(fragment);
        this.elements.allCount.textContent = this.state.totalMoviesCount;
    }
    
    updateCategoryButtons() {
        // Obtener categor√≠as √∫nicas
        const categories = new Set();
        this.state.allMovies.forEach(m => categories.add(m.categoria));
        
        // Actualizar botones de categor√≠a si es necesario
        // ...
    }
    
    updateMovieCount() {
        const count = this.getFilteredMovies().length;
        this.elements.movieCount.textContent = `${count.toLocaleString('es')} pel√≠culas`;
    }
    
    updateStatus() {
        const total = this.sources.filter(s => s.enabled).length;
        const loaded = this.state.loadedSources;
        const failed = this.state.failedSources.length;
        
        let statusText = `${loaded}/${total} fuentes`;
        if (failed > 0) {
            statusText += ` (${failed} errores)`;
        }
        
        this.elements.statusText.textContent = statusText;
    }
    
    renderLoadingProgress() {
        const sources = this.sources.filter(s => s.enabled);
        
        this.elements.loaderSources.innerHTML = sources
            .map(source => `
                <div class="loader-source-item">
                    <div class="loader-source-status" id="source-status-${source.id}"></div>
                    <div>${source.name}</div>
                </div>
            `).join('');
    }
    
    updateSourceStatus(sourceId, status) {
        const element = document.getElementById(`source-status-${sourceId}`);
        if (element) {
            element.className = `loader-source-status ${status}`;
        }
        
        // Actualizar texto de progreso
        const loaded = this.state.loadedSources;
        const total = this.sources.filter(s => s.enabled).length;
        const percent = Math.round((loaded / total) * 100);
        
        this.elements.loaderProgress.textContent = `${percent}% completado (${loaded}/${total})`;
    }
    
    showLoader(show) {
        this.elements.loader.classList.toggle('hidden', !show);
        this.state.isLoading = show;
    }
    
    renderEmptyState() {
        this.elements.mainContent.innerHTML = `
            <div class="empty-state">
                <h2>No se encontraron pel√≠culas</h2>
                <p>Intenta ajustar los filtros o verificar tu conexi√≥n</p>
            </div>
        `;
    }
    
    handleSourceError(source, error) {
        console.error(`Error en ${source.name}:`, error);
        source.status = 'error';
        this.state.failedSources.push(source);
        this.updateSourceStatus(source.id, 'error');
    }
    
    // M√©todos de cach√©
    getCachedData(key) {
        if (!this.config.cacheEnabled) return null;
        
        try {
            const cached = localStorage.getItem(`cache_${key}`);
            return cached ? JSON.parse(cached) : null;
        } catch {
            return null;
        }
    }
    
    setCachedData(key, data) {
        if (!this.config.cacheEnabled) return;
        
        try {
            const cacheData = {
                data: data,
                timestamp: Date.now()
            };
            localStorage.setItem(`cache_${key}`, JSON.stringify(cacheData));
        } catch (e) {
            console.warn('Cache storage failed:', e);
        }
    }
    
    isCacheExpired(timestamp) {
        return Date.now() - timestamp > this.config.cacheExpiry;
    }
    
    loadCachedSources() {
        // Cargar datos en cach√© mientras se obtienen los nuevos
        this.sources.forEach(source => {
            const cached = this.getCachedData(source.id);
            if (cached && cached.data) {
                source.movies = cached.data;
                // Marcar como cach√© temporal
                source.status = 'cached';
            }
        });
        
        // Renderizar contenido en cach√© inmediatamente
        if (this.sources.some(s => s.status === 'cached')) {
            this.processLoadedMovies();
            this.buildIndexes();
            this.renderContent();
            this.updateUI();
        }
    }
    
    saveToCache() {
        // Guardar estado actual en cach√©
        this.sources.forEach(source => {
            if (source.status === 'success' && source.movies.length > 0) {
                this.setCachedData(source.id, source.movies);
            }
        });
    }
    
    setupAutoRefresh() {
        // Actualizar fuentes cada hora
        setInterval(() => {
            this.loadAllSources();
        }, 3600000);
    }
    
    // Utilidades
    getPlaceholderImage(title = 'Movie') {
        return `https://via.placeholder.com/300x450/2a2a2a/e50914?text=${encodeURIComponent(title.substring(0, 15))}`;
    }
    
    chunkArray(array, size) {
        const chunks = [];
        for (let i = 0; i < array.length; i += size) {
            chunks.push(array.slice(i, i + size));
        }
        return chunks;
    }
    
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Inicializaci√≥n
document.addEventListener('DOMContentLoaded', () => {
    window.moviePlatform = new OptimizedMoviesPlatform();
});

// Service Worker para cach√© offline (opcional)
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js').catch(() => {});
}
</script>

</body>
</html>
