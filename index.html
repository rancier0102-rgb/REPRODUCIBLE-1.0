<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Movies HD - Chunk System</title>

<!-- Preconexiones cr√≠ticas -->
<link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

<!-- Precarga del manifest -->
<link rel="preload" 
      href="https://cdn.jsdelivr.net/gh/TU_USUARIO/TU_REPO@main/manifest.json" 
      as="fetch" 
      crossorigin>

<style>
/* CSS Cr√≠tico */
:root{--primary:#e50914;--bg:#000;--card:#111;--text:#fff}
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--text)}

/* Layout */
.app{min-height:100vh;display:flex;flex-direction:column}
header{background:var(--card);padding:1rem;border-bottom:2px solid var(--primary);position:sticky;top:0;z-index:100}
.header-content{max-width:1400px;margin:0 auto;display:flex;align-items:center;gap:1rem;flex-wrap:wrap}
h1{color:var(--primary);font-size:1.5rem}
.search-box{flex:1;min-width:200px;position:relative}
.search-box input{width:100%;padding:0.75rem 1rem;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:25px;color:var(--text);font-size:1rem}
.search-box input:focus{outline:none;border-color:var(--primary);background:rgba(255,255,255,0.15)}
.stats{display:flex;gap:1rem;align-items:center}
.stat{background:rgba(255,255,255,0.1);padding:0.5rem 1rem;border-radius:20px;font-size:0.9rem}
.stat.primary{background:var(--primary)}

/* Loading */
.loader-container{position:fixed;top:0;left:0;right:0;bottom:0;background:var(--bg);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:1000;transition:opacity 0.3s}
.loader-container.hidden{opacity:0;pointer-events:none}
.loader{width:60px;height:60px;border:3px solid rgba(255,255,255,0.1);border-top-color:var(--primary);border-radius:50%;animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
.loader-text{margin-top:1rem;color:rgba(255,255,255,0.6)}
.progress-bar{width:300px;height:3px;background:rgba(255,255,255,0.1);border-radius:3px;margin-top:1rem;overflow:hidden}
.progress-fill{height:100%;background:var(--primary);width:0%;transition:width 0.3s}

/* Movies Grid */
.main{flex:1;max-width:1400px;margin:0 auto;padding:1rem;width:100%}
.filter-tabs{display:flex;gap:0.5rem;padding:1rem 0;overflow-x:auto;margin-bottom:1rem}
.filter-tabs::-webkit-scrollbar{height:3px}
.filter-tabs::-webkit-scrollbar-track{background:rgba(255,255,255,0.05)}
.filter-tabs::-webkit-scrollbar-thumb{background:var(--primary);border-radius:3px}
.tab{padding:0.5rem 1.5rem;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:20px;color:var(--text);cursor:pointer;white-space:nowrap;transition:all 0.2s}
.tab:hover{background:rgba(255,255,255,0.1)}
.tab.active{background:var(--primary);border-color:var(--primary)}
.tab .count{opacity:0.7;margin-left:0.5rem;font-size:0.9em}

.movies-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:1rem}
.movie{background:var(--card);border-radius:8px;overflow:hidden;cursor:pointer;transition:transform 0.2s,box-shadow 0.2s;position:relative}
.movie:hover{transform:scale(1.05);box-shadow:0 5px 20px rgba(229,9,20,0.3)}
.movie-poster{position:relative;padding-bottom:150%;background:linear-gradient(135deg,#1a1a1a,#2a2a2a)}
.movie-poster img{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}
.movie-poster .skeleton{position:absolute;inset:0;background:linear-gradient(90deg,rgba(255,255,255,0.05) 25%,rgba(255,255,255,0.1) 50%,rgba(255,255,255,0.05) 75%);background-size:200% 100%;animation:shimmer 1.5s infinite}
@keyframes shimmer{0%{background-position:-200% 0}100%{background-position:200% 0}}
.movie-info{padding:0.75rem}
.movie-title{font-size:0.9rem;font-weight:500;line-height:1.3;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical}
.movie-year{font-size:0.8rem;color:rgba(255,255,255,0.5);margin-top:0.25rem}
.movie-quality{position:absolute;top:0.5rem;right:0.5rem;background:var(--primary);padding:0.25rem 0.5rem;border-radius:4px;font-size:0.7rem;font-weight:bold}

/* Empty State */
.empty-state{text-align:center;padding:3rem 1rem;color:rgba(255,255,255,0.5)}
.empty-state h2{margin-bottom:1rem;color:rgba(255,255,255,0.7)}

/* Responsive */
@media (max-width:768px){
  .header-content{flex-direction:column;align-items:stretch}
  .search-box{order:3}
  .movies-grid{grid-template-columns:repeat(auto-fill,minmax(100px,1fr))}
  .movie-title{font-size:0.8rem}
}

/* Toast */
.toast{position:fixed;bottom:2rem;right:2rem;background:var(--card);padding:1rem 1.5rem;border-radius:8px;border-left:3px solid var(--primary);box-shadow:0 4px 12px rgba(0,0,0,0.5);transform:translateX(400px);transition:transform 0.3s;z-index:1000}
.toast.show{transform:translateX(0)}
</style>
</head>
<body>

<div class="app">
  <!-- Loader -->
  <div class="loader-container" id="loader">
    <div class="loader"></div>
    <div class="loader-text" id="loaderText">Cargando cat√°logo...</div>
    <div class="progress-bar">
      <div class="progress-fill" id="progressBar"></div>
    </div>
  </div>
  
  <!-- Header -->
  <header>
    <div class="header-content">
      <h1>MOVIES+</h1>
      <div class="search-box">
        <input type="search" id="searchInput" placeholder="Buscar pel√≠culas..." autocomplete="off">
      </div>
      <div class="stats">
        <div class="stat primary" id="movieCount">0 pel√≠culas</div>
        <div class="stat" id="loadStatus">Cargando...</div>
      </div>
    </div>
  </header>
  
  <!-- Main Content -->
  <main class="main">
    <!-- Filter Tabs -->
    <div class="filter-tabs" id="filterTabs">
      <button class="tab active" data-filter="all">
        Todas<span class="count" id="countAll">0</span>
      </button>
    </div>
    
    <!-- Movies Grid -->
    <div class="movies-grid" id="moviesGrid">
      <!-- Las pel√≠culas se cargar√°n aqu√≠ -->
    </div>
    
    <!-- Empty State -->
    <div class="empty-state" id="emptyState" style="display:none">
      <h2>No se encontraron pel√≠culas</h2>
      <p>Intenta con otro t√©rmino de b√∫squeda</p>
    </div>
  </main>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
'use strict';

// ============================================
// CONFIGURACI√ìN DEL SISTEMA DE CHUNKS
// ============================================
const CONFIG = {
  // GitHub / CDN Configuration
  CDN_BASE: 'https://cdn.jsdelivr.net/gh',
  GITHUB_USER: 'TU_USUARIO',
  GITHUB_REPO: 'TU_REPO',
  GITHUB_BRANCH: 'main',
  
  // Obtener URLs
  getManifestUrl() {
    return `${this.CDN_BASE}/${this.GITHUB_USER}/${this.GITHUB_REPO}@${this.GITHUB_BRANCH}/manifest.json`;
  },
  
  getChunkUrl(chunkFile) {
    return `${this.CDN_BASE}/${this.GITHUB_USER}/${this.GITHUB_REPO}@${this.GITHUB_BRANCH}/${chunkFile}`;
  },
  
  // Performance Settings
  CACHE_ENABLED: true,
  CACHE_TTL: 3600000, // 1 hora
  LAZY_LOAD_IMAGES: true,
  PROGRESSIVE_RENDER: true,
  RENDER_BATCH_SIZE: 50,
  SEARCH_DEBOUNCE: 300
};

// ============================================
// SISTEMA DE CHUNKS OPTIMIZADO
// ============================================
class ChunkedMoviesApp {
  constructor() {
    this.manifest = null;
    this.chunks = new Map();
    this.movies = [];
    this.filteredMovies = [];
    this.loadedChunks = new Set();
    this.currentFilter = 'all';
    this.searchQuery = '';
    
    // Cache
    this.cache = new Map();
    this.initIndexedDB();
    
    // UI Elements
    this.elements = {
      loader: document.getElementById('loader'),
      loaderText: document.getElementById('loaderText'),
      progressBar: document.getElementById('progressBar'),
      movieCount: document.getElementById('movieCount'),
      loadStatus: document.getElementById('loadStatus'),
      searchInput: document.getElementById('searchInput'),
      filterTabs: document.getElementById('filterTabs'),
      moviesGrid: document.getElementById('moviesGrid'),
      emptyState: document.getElementById('emptyState'),
      toast: document.getElementById('toast')
    };
    
    // Performance tracking
    this.startTime = performance.now();
  }
  
  async init() {
    console.log('üöÄ Iniciando sistema de chunks...');
    
    try {
      // Paso 1: Cargar manifest
      await this.loadManifest();
      
      // Paso 2: Cargar chunks por prioridad
      await this.loadChunksByPriority();
      
      // Paso 3: Setup UI
      this.setupEventListeners();
      this.createFilterTabs();
      
      // Ocultar loader
      this.hideLoader();
      
      // Mostrar estad√≠sticas
      const loadTime = ((performance.now() - this.startTime) / 1000).toFixed(2);
      this.showToast(`‚úÖ ${this.movies.length} pel√≠culas cargadas en ${loadTime}s`);
      
    } catch (error) {
      console.error('‚ùå Error fatal:', error);
      this.showError('Error cargando el cat√°logo');
    }
  }
  
  async loadManifest() {
    this.updateLoader('Cargando cat√°logo...');
    
    // Intentar desde cach√©
    const cached = await this.getFromCache('manifest');
    if (cached) {
      console.log('‚ö° Manifest desde cach√©');
      this.manifest = cached;
      return;
    }
    
    // Cargar desde CDN
    const response = await fetch(CONFIG.getManifestUrl());
    if (!response.ok) throw new Error('No se pudo cargar el manifest');
    
    this.manifest = await response.json();
    console.log(`üìã Manifest cargado: ${this.manifest.totalMovies} pel√≠culas en ${this.manifest.chunks.length} chunks`);
    
    // Guardar en cach√©
    await this.saveToCache('manifest', this.manifest);
  }
  
  async loadChunksByPriority() {
    if (!this.manifest || !this.manifest.chunks) return;
    
    // Ordenar chunks por prioridad
    const sortedChunks = [...this.manifest.chunks].sort((a, b) => a.priority - b.priority);
    
    let loadedMovies = 0;
    const totalMovies = this.manifest.totalMovies;
    
    for (const chunkInfo of sortedChunks) {
      // Actualizar progreso
      const progress = Math.round((loadedMovies / totalMovies) * 100);
      this.updateLoader(`Cargando ${chunkInfo.name}...`, progress);
      
      // Cargar chunk
      const chunkData = await this.loadChunk(chunkInfo);
      
      if (chunkData && chunkData.movies) {
        // Descomprimir campos si es necesario
        const movies = chunkData.movies.map(m => this.decompressMovie(m));
        
        // Agregar pel√≠culas
        this.movies.push(...movies);
        loadedMovies += movies.length;
        
        console.log(`‚úÖ ${chunkInfo.name}: ${movies.length} pel√≠culas`);
        
        // Renderizado progresivo para el primer chunk
        if (CONFIG.PROGRESSIVE_RENDER && chunkInfo.priority === 1) {
          this.renderMovies(this.movies);
          this.updateStats();
        }
      }
    }
    
    // Renderizado final
    this.renderMovies(this.movies);
    this.updateStats();
  }
  
  async loadChunk(chunkInfo) {
    const cacheKey = `chunk_${chunkInfo.id}`;
    
    // Verificar si ya est√° cargado
    if (this.loadedChunks.has(chunkInfo.id)) {
      return this.chunks.get(chunkInfo.id);
    }
    
    // Intentar desde cach√©
    const cached = await this.getFromCache(cacheKey);
    if (cached) {
      console.log(`‚ö° Chunk ${chunkInfo.id} desde cach√©`);
      this.chunks.set(chunkInfo.id, cached);
      this.loadedChunks.add(chunkInfo.id);
      return cached;
    }
    
    try {
      // Cargar desde CDN
      const response = await fetch(CONFIG.getChunkUrl(chunkInfo.file));
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      
      const data = await response.json();
      
      // Verificar checksum si existe
      if (chunkInfo.checksum && CONFIG.VERIFY_CHECKSUM) {
        // Implementar verificaci√≥n de checksum aqu√≠ si es necesario
      }
      
      // Guardar en cach√©
      await this.saveToCache(cacheKey, data);
      
      // Guardar en memoria
      this.chunks.set(chunkInfo.id, data);
      this.loadedChunks.add(chunkInfo.id);
      
      return data;
      
    } catch (error) {
      console.error(`‚ùå Error cargando chunk ${chunkInfo.id}:`, error);
      return null;
    }
  }
  
  decompressMovie(movie) {
    // Descomprimir campos abreviados
    return {
      titulo: movie.t || movie.titulo,
      enlace: movie.l || movie.enlace,
      year: movie.y || movie.year || 2000,
      poster: movie.p || movie.poster || this.getPlaceholder(movie.t),
      genero: movie.g || movie.genero,
      quality: movie.q || movie.quality,
      rating: movie.r || movie.rating,
      duration: movie.d || movie.duration
    };
  }
  
  // ============================================
  // SISTEMA DE CACH√â
  // ============================================
  
  async initIndexedDB() {
    if (!CONFIG.CACHE_ENABLED || !window.indexedDB) return;
    
    return new Promise((resolve) => {
      const request = indexedDB.open('MoviesChunkDB', 1);
      
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('cache')) {
          db.createObjectStore('cache', { keyPath: 'key' });
        }
      };
      
      request.onerror = () => resolve();
    });
  }
  
  async getFromCache(key) {
    if (!CONFIG.CACHE_ENABLED) return null;
    
    // Nivel 1: Memoria
    if (this.cache.has(key)) {
      const item = this.cache.get(key);
      if (Date.now() < item.expiry) {
        return item.data;
      }
      this.cache.delete(key);
    }
    
    // Nivel 2: IndexedDB
    if (this.db) {
      return new Promise((resolve) => {
        try {
          const transaction = this.db.transaction(['cache'], 'readonly');
          const request = transaction.objectStore('cache').get(key);
          
          request.onsuccess = () => {
            const result = request.result;
            if (result && Date.now() < result.expiry) {
              this.cache.set(key, result); // Promover a memoria
              resolve(result.data);
            } else {
              resolve(null);
            }
          };
          
          request.onerror = () => resolve(null);
        } catch (e) {
          resolve(null);
        }
      });
    }
    
    // Nivel 3: LocalStorage
    try {
      const item = localStorage.getItem(key);
      if (item) {
        const parsed = JSON.parse(item);
        if (Date.now() < parsed.expiry) {
          return parsed.data;
        }
        localStorage.removeItem(key);
      }
    } catch (e) {}
    
    return null;
  }
  
  async saveToCache(key, data) {
    if (!CONFIG.CACHE_ENABLED) return;
    
    const item = {
      key,
      data,
      expiry: Date.now() + CONFIG.CACHE_TTL
    };
    
    // Memoria
    this.cache.set(key, item);
    
    // IndexedDB
    if (this.db) {
      try {
        const transaction = this.db.transaction(['cache'], 'readwrite');
        transaction.objectStore('cache').put(item);
      } catch (e) {}
    }
    
    // LocalStorage para datos peque√±os
    if (JSON.stringify(item).length < 50000) {
      try {
        localStorage.setItem(key, JSON.stringify(item));
      } catch (e) {}
    }
  }
  
  // ============================================
  // RENDERIZADO
  // ============================================
  
  renderMovies(movies = this.filteredMovies.length ? this.filteredMovies : this.movies) {
    const grid = this.elements.moviesGrid;
    
    if (movies.length === 0) {
      grid.innerHTML = '';
      this.elements.emptyState.style.display = 'block';
      return;
    }
    
    this.elements.emptyState.style.display = 'none';
    
    // Renderizado por lotes para mejor performance
    const fragment = document.createDocumentFragment();
    const batchSize = CONFIG.RENDER_BATCH_SIZE;
    const moviesToRender = movies.slice(0, batchSize);
    
    moviesToRender.forEach(movie => {
      const element = this.createMovieElement(movie);
      fragment.appendChild(element);
    });
    
    grid.innerHTML = '';
    grid.appendChild(fragment);
    
    // Renderizar resto en background
    if (movies.length > batchSize) {
      requestIdleCallback(() => {
        const restFragment = document.createDocumentFragment();
        movies.slice(batchSize).forEach(movie => {
          const element = this.createMovieElement(movie);
          restFragment.appendChild(element);
        });
        grid.appendChild(restFragment);
        
        // Activar lazy loading de im√°genes
        if (CONFIG.LAZY_LOAD_IMAGES) {
          this.setupLazyLoading();
        }
      });
    } else {
      // Activar lazy loading de im√°genes
      if (CONFIG.LAZY_LOAD_IMAGES) {
        this.setupLazyLoading();
      }
    }
  }
  
  createMovieElement(movie) {
    const div = document.createElement('div');
    div.className = 'movie';
    div.onclick = () => this.playMovie(movie);
    
    // Quality badge si existe
    const qualityBadge = movie.quality ? 
      `<div class="movie-quality">${movie.quality}</div>` : '';
    
    div.innerHTML = `
      <div class="movie-poster">
        ${CONFIG.LAZY_LOAD_IMAGES ? 
          `<div class="skeleton"></div>
           <img data-src="${movie.poster}" alt="${movie.titulo}" loading="lazy">` :
          `<img src="${movie.poster}" alt="${movie.titulo}">`
        }
        ${qualityBadge}
      </div>
      <div class="movie-info">
        <div class="movie-title">${movie.titulo}</div>
        <div class="movie-year">${movie.year}</div>
      </div>
    `;
    
    return div;
  }
  
  setupLazyLoading() {
    const images = this.elements.moviesGrid.querySelectorAll('img[data-src]');
    
    const imageObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          const src = img.dataset.src;
          
          // Cargar imagen
          const tempImg = new Image();
          tempImg.onload = () => {
            img.src = src;
            img.removeAttribute('data-src');
            
            // Ocultar skeleton
            const skeleton = img.parentElement.querySelector('.skeleton');
            if (skeleton) skeleton.style.display = 'none';
          };
          tempImg.onerror = () => {
            img.src = this.getPlaceholder(img.alt);
          };
          tempImg.src = src;
          
          imageObserver.unobserve(img);
        }
      });
    }, {
      rootMargin: '50px'
    });
    
    images.forEach(img => imageObserver.observe(img));
  }
  
  // ============================================
  // FILTROS Y B√öSQUEDA
  // ============================================
  
  createFilterTabs() {
    // Obtener g√©neros √∫nicos
    const genres = new Set();
    this.movies.forEach(movie => {
      if (movie.genero) {
        genres.add(movie.genero);
      }
    });
    
    // Crear tabs de filtro
    const tabs = this.elements.filterTabs;
    
    // Agregar filtros de a√±o por d√©cada
    const decades = [
      { id: '2020s', label: '2020s', filter: m => m.year >= 2020 },
      { id: '2010s', label: '2010s', filter: m => m.year >= 2010 && m.year < 2020 },
      { id: '2000s', label: '2000s', filter: m => m.year >= 2000 && m.year < 2010 },
      { id: '90s', label: '90s', filter: m => m.year >= 1990 && m.year < 2000 },
      { id: 'classic', label: 'Cl√°sicas', filter: m => m.year < 1990 }
    ];
    
    decades.forEach(decade => {
      const count = this.movies.filter(decade.filter).length;
      if (count > 0) {
        const tab = document.createElement('button');
        tab.className = 'tab';
        tab.dataset.filter = decade.id;
        tab.innerHTML = `${decade.label}<span class="count">${count}</span>`;
        tab.onclick = () => this.applyFilter(decade.id, decade.filter);
        tabs.appendChild(tab);
      }
    });
    
    // Actualizar contador de "Todas"
    document.getElementById('countAll').textContent = this.movies.length;
  }
  
  applyFilter(filterId, filterFn) {
    // Actualizar tabs activos
    document.querySelectorAll('.tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.filter === filterId);
    });
    
    this.currentFilter = filterId;
    
    if (filterId === 'all') {
      this.filteredMovies = [];
      this.renderMovies(this.movies);
    } else {
      this.filteredMovies = this.movies.filter(filterFn);
      this.renderMovies(this.filteredMovies);
    }
    
    this.updateStats();
  }
  
  setupEventListeners() {
    // B√∫squeda con debounce
    let searchTimeout;
    this.elements.searchInput.addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      const query = e.target.value.toLowerCase().trim();
      
      searchTimeout = setTimeout(() => {
        this.searchQuery = query;
        this.performSearch();
      }, CONFIG.SEARCH_DEBOUNCE);
    });
    
    // Tab "Todas"
    document.querySelector('[data-filter="all"]').onclick = () => {
      this.applyFilter('all', null);
    };
  }
  
  performSearch() {
    if (!this.searchQuery) {
      this.filteredMovies = [];
      this.renderMovies(this.movies);
    } else {
      this.filteredMovies = this.movies.filter(movie => 
        movie.titulo.toLowerCase().includes(this.searchQuery) ||
        (movie.year && movie.year.toString().includes(this.searchQuery)) ||
        (movie.genero && movie.genero.toLowerCase().includes(this.searchQuery))
      );
      this.renderMovies(this.filteredMovies);
    }
    
    this.updateStats();
  }
  
  // ============================================
  // UI HELPERS
  // ============================================
  
  updateLoader(text, progress = 0) {
    this.elements.loaderText.textContent = text;
    this.elements.progressBar.style.width = `${progress}%`;
  }
  
  hideLoader() {
    this.elements.loader.classList.add('hidden');
    setTimeout(() => {
      this.elements.loader.style.display = 'none';
    }, 300);
  }
  
  updateStats() {
    const count = this.filteredMovies.length || this.movies.length;
    this.elements.movieCount.textContent = `${count} pel√≠culas`;
    this.elements.loadStatus.textContent = 'Listo';
  }
  
  showToast(message, duration = 3000) {
    this.elements.toast.textContent = message;
    this.elements.toast.classList.add('show');
    
    setTimeout(() => {
      this.elements.toast.classList.remove('show');
    }, duration);
  }
  
  showError(message) {
    this.elements.moviesGrid.innerHTML = `
      <div class="empty-state">
        <h2>‚ö†Ô∏è Error</h2>
        <p>${message}</p>
        <button onclick="location.reload()" style="margin-top:1rem;padding:0.5rem 2rem;background:var(--primary);border:none;border-radius:5px;color:white;cursor:pointer">
          Reintentar
        </button>
      </div>
    `;
    this.hideLoader();
  }
  
  getPlaceholder(title = '') {
    // SVG placeholder
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="300" height="450" viewBox="0 0 300 450">
      <rect width="300" height="450" fill="#1a1a1a"/>
      <text x="150" y="225" font-family="Arial" font-size="16" fill="#666" text-anchor="middle">
        ${title.substring(0, 20) || 'Sin imagen'}
      </text>
    </svg>`;
    return 'data:image/svg+xml,' + encodeURIComponent(svg);
  }
  
  playMovie(movie) {
    console.log('‚ñ∂Ô∏è Reproduciendo:', movie.titulo);
    window.open(movie.enlace, '_blank');
  }
}

// ============================================
// INICIALIZACI√ìN
// ============================================
const app = new ChunkedMoviesApp();

// Iniciar cuando el DOM est√© listo
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => app.init());
} else {
  app.init();
}

// Exponer para debug
window.app = app;
</script>

</body>
</html>
