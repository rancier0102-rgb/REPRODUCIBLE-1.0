<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Ayman's PlayTorrio</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<!-- Video.js CSS -->
<link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet" />
<style>
        /* Performance mode overrides: remove expensive visual effects when enabled */
        body.perf-mode * { backdrop-filter: none !important; }
        body.perf-mode .shadow-heavy { box-shadow: none !important; }
        /* Prefer letting Chrome skip offscreen rendering */
        body.perf-mode img { content-visibility: auto; }
        /* Optional: reduce motion for continuous animations */
        @media (prefers-reduced-motion: reduce) {
            * { animation-duration: 0.001ms !important; animation-iteration-count: 1 !important; transition-duration: 0.001ms !important; }
        }
        :root {
            --primary: #2a1847;    /* header/cards */
            --secondary: #8b5cf6;  /* subtle accents */
            --tertiary: #c084fc;   /* highlights/pills */
            --dark: #120a1f;       /* page background */
            --light: #f8f9fa;      /* text */
            --gray: #6c757d;       /* muted text */
            --danger: #dc3545;
            --success: #28a745;
            /* Accent (kept var name for minimal changes) */
            --vlc-orange: #a855f7; /* accent purple */
            --vlc-dark: #2d2d2d;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--dark);
            color: var(--light);
            overflow-x: hidden;
        }

        /* Global performance profile (safe visual downgrades only) */
        body.perf-mode * { transition: none !important; animation: none !important; }
        body.perf-mode #updateOverlay { backdrop-filter: none !important; }

        header {
            background-color: var(--header-bg);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 900;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--light);
            text-decoration: none;
        }
        
        .logo span {
            color: var(--vlc-orange);
        }
        
        .search-container {
            flex: 1;
            max-width: 600px;
            margin: 0 2rem;
            position: relative;
        }
        
        .search-container input {
            width: 100%;
            padding: 0.8rem 1.2rem;
            padding-left: 3rem;
            border-radius: 30px;
            border: none;
            background-color: var(--input-bg);
            color: var(--light);
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .search-container input:focus {
            outline: none;
            background-color: var(--hover-bg);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.3);
        }
        
        .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--gray);
        }
        
        .user-actions {
            display: flex;
            gap: 1rem;
        }
        
        .btn {
            padding: 0.6rem 1.2rem;
            border-radius: 30px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .btn-outline {
            background-color: transparent;
            border: 2px solid var(--vlc-orange);
            color: var(--vlc-orange);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .btn-primary:hover {
            background-color: #9333ea;
        }
        
        .btn-outline:hover {
            background-color: rgba(168, 85, 247, 0.1);
        }
        
        .btn-outline.active {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        main {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        
        .section-title {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            padding-left: 1rem;
            border-left: 4px solid var(--vlc-orange);
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .section-title i {
            color: var(--tertiary);
        }
        
        .categories {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            overflow-x: auto;
            padding: 0.5rem 0;
        }
        
        .category {
            padding: 0.8rem 1.5rem;
            background-color: var(--input-bg);
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            font-weight: 600;
        }
        
        .category:hover, .category.active {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .movies-grid, .genre-grid, .genre-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 3rem;
        }
        
        .movie-card, .genre-card {
            background-color: var(--card-bg);
            border-radius: 10px;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            position: relative;
            cursor: pointer;
        }

        /* Performance mode: reduce heavy shadows on cards */
        body.perf-mode .movie-card, body.perf-mode .genre-card {
            box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
        }
        
        .movie-card:hover, .genre-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 12px 16px rgba(0, 0, 0, 0.3);
        }

        body.perf-mode .movie-card:hover, body.perf-mode .genre-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 10px rgba(0,0,0,0.25) !important;
        }
        
        .movie-poster {
            width: 100%;
            height: 300px;
            object-fit: cover;
            display: block;
        }
        
        .movie-info, .genre-info {
            padding: 1rem;
        }
        
        .movie-title, .genre-title {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .movie-year {
            color: var(--tertiary);
            font-size: 0.9rem;
        }

        /* ===== DOWNLOADER STYLES ===== */
        .downloader-search { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; flex-wrap: wrap; }
        .downloader-search input { flex: 1; padding: 0.8rem 1rem; border-radius: 10px; border: none; background-color: rgba(255, 255, 255, 0.08); color: var(--light); }
        .downloader-search button { padding: 0.7rem 1rem; border-radius: 10px; border: none; background: linear-gradient(135deg, #8b5cf6, #6d28d9); color: #fff; cursor: pointer; }
    .downloader-results { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem; }
    .downloader-results.single {
        display: flex;
        justify-content: center;
        align-items: flex-start; /* don't stretch heights */
        gap: 1rem;
    }
    .downloader-results.single .downloader-item {
        flex: 0 0 260px; /* fixed column width for poster card */
        max-width: 260px;
        align-self: flex-start;
        position: sticky; /* keep the highlighted card visible */
        top: 12px;
    }
    .downloader-results.single .downloader-files-card {
        flex: 1 1 auto; /* fill remaining space */
        min-width: 360px;
    }
        .downloader-item { display: flex; flex-direction: column; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08); border-radius: 14px; overflow: hidden; transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease; cursor: pointer; outline: none; }
        .downloader-item:hover { transform: translateY(-2px); border-color: rgba(168,85,247,0.35); box-shadow: 0 6px 20px rgba(168,85,247,0.15); }
        .downloader-item.selected { border-color: #a855f7; box-shadow: 0 0 0 2px rgba(168,85,247,0.35) inset, 0 10px 24px rgba(168,85,247,0.25); }
        .downloader-thumb { width: 100%; height: 240px; object-fit: cover; background: #1f2937; }
        .downloader-meta { padding: 0.75rem; display: flex; flex-direction: column; gap: 0.3rem; }
        .downloader-title { color: #fff; font-weight: 600; }
        .downloader-year { color: #9ca3af; font-size: 0.9rem; }
        .downloader-empty { color: #9ca3af; text-align: center; padding: 2rem 1rem; }
        .downloader-type-toggle { display:flex; align-items:center; gap:0.5rem; margin-left:auto; }
        .downloader-type-toggle .filter-btn { padding: 0.55rem 0.9rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.06); color:#fff; font-weight:600; cursor:pointer; }

        /* Live TV Styles */
        .livetv-category-section {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 0;
        }
        .livetv-category-label {
            font-weight: 600;
            color: #10b981;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .livetv-category-dropdown {
            padding: 0.75rem 1.25rem;
            border-radius: 12px;
            border: 2px solid rgba(16, 185, 129, 0.3);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.12), rgba(5, 150, 105, 0.08));
            color: #fff;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            outline: none;
            min-width: 200px;
        }
        .livetv-category-dropdown:hover {
            border-color: rgba(16, 185, 129, 0.5);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.18), rgba(5, 150, 105, 0.12));
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
        }
        .livetv-category-dropdown:focus {
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.15);
        }
        .livetv-category-dropdown option {
            background: #1a1a2e;
            color: #fff;
            padding: 0.75rem;
            font-weight: 600;
        }
        .livetv-matches-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 1.5rem;
            padding: 0.5rem 0;
        }
        .livetv-match-card {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.05));
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }
        .livetv-match-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #10b981, #059669);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .livetv-match-card:hover {
            transform: translateY(-4px);
            border-color: #10b981;
            box-shadow: 0 8px 24px rgba(16, 185, 129, 0.25);
        }
        .livetv-match-card:hover::before {
            opacity: 1;
        }
        .livetv-poster {
            width: 100%;
            height: 140px;
            object-fit: cover;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
        }
        .livetv-poster-placeholder {
            width: 100%;
            height: 140px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: rgba(255, 255, 255, 0.3);
            font-size: 2.5em;
        }
        .livetv-match-info {
            padding: 1rem;
        }
        .livetv-match-title {
            font-weight: 700;
            font-size: 0.95rem;
            margin-bottom: 0.5rem;
            color: #fff;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            line-clamp: 2;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.3;
        }
        .livetv-match-category {
            display: inline-block;
            padding: 0.35rem 0.75rem;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.15));
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            color: #10b981;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .livetv-watch-btn {
            width: 100%;
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: linear-gradient(135deg, #10b981, #059669);
            border: none;
            border-radius: 10px;
            color: #fff;
            font-weight: 700;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .livetv-watch-btn:hover {
            background: linear-gradient(135deg, #059669, #047857);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            transform: scale(1.02);
        }
        .livetv-empty {
            text-align: center;
            padding: 4rem 2rem;
            color: rgba(255, 255, 255, 0.4);
        }
        .livetv-empty p {
            margin-top: 1rem;
            font-size: 1.1rem;
        }
        
        /* Streams List Modal */
        .livetv-streams-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }
        .livetv-streams-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid rgba(16, 185, 129, 0.3);
            border-radius: 20px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(16, 185, 129, 0.3);
        }
        .livetv-streams-header {
            padding: 1.5rem;
            background: rgba(16, 185, 129, 0.1);
            border-bottom: 2px solid rgba(16, 185, 129, 0.3);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .livetv-streams-header h3 {
            font-size: 1.3rem;
            color: #10b981;
            font-weight: 700;
        }
        .livetv-close-btn {
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid rgba(220, 53, 69, 0.4);
            border-radius: 8px;
            color: #ff4757;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }
        .livetv-close-btn:hover {
            background: rgba(220, 53, 69, 0.3);
            transform: scale(1.1);
        }
        .livetv-streams-list {
            padding: 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .livetv-stream-item {
            padding: 1rem 1.25rem;
            background: rgba(16, 185, 129, 0.08);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 12px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }
        .livetv-stream-item:hover {
            background: rgba(16, 185, 129, 0.15);
            border-color: #10b981;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
        }
        .livetv-stream-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .livetv-stream-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }
        .livetv-copy-link-btn, .livetv-open-browser-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 10px;
            color: #fff;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        .livetv-copy-link-btn {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
        }
        .livetv-copy-link-btn:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            transform: scale(1.05);
        }
        .livetv-open-browser-btn {
            background: linear-gradient(135deg, #10b981, #059669);
        }
        .livetv-open-browser-btn:hover {
            background: linear-gradient(135deg, #059669, #047857);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            transform: scale(1.05);
        }
        .livetv-copy-link-btn:active, .livetv-open-browser-btn:active {
            transform: scale(0.98);
        }
        .livetv-stream-source {
            font-weight: 700;
            color: #10b981;
            font-size: 1.1rem;
        }
        .livetv-stream-details {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
            font-size: 0.9rem;
        }
        .livetv-stream-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .livetv-stream-badge.hd {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: #fff;
        }
        .livetv-stream-badge.language {
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.4);
            color: #3b82f6;
        }
        .livetv-stream-badge.viewers {
            background: rgba(168, 85, 247, 0.2);
            border: 1px solid rgba(168, 85, 247, 0.4);
            color: #a855f7;
        }
        .livetv-loading {
            text-align: center;
            padding: 2rem;
            color: rgba(255, 255, 255, 0.6);
        }
        .livetv-loading i {
            font-size: 2em;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .downloader-type-toggle .filter-btn.active { background: linear-gradient(135deg, #8b5cf6, #6d28d9); border-color: transparent; }
        
        .movie-rating {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: var(--tertiary);
            color: #1f1140;
            padding: 0.3rem 0.6rem;
            border-radius: 30px;
            font-weight: 700;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .add-to-list-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--light);
            border: none;
            padding: 0.5rem;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            transform: scale(0.8);
        }
        
        .movie-card:hover .add-to-list-btn {
            opacity: 1;
            transform: scale(1);
        }
        
        .add-to-list-btn:hover {
            background-color: var(--success);
            transform: scale(1.1);
        }
        
        .add-to-list-btn.in-list {
            background-color: var(--success);
            opacity: 1;
            transform: scale(1);
        }
        
        .add-to-list-btn.in-list i:before {
            content: "\f00c"; /* checkmark */
        }
        
        .done-watching-btn {
            position: absolute;
            top: 10px;
            left: 55px; /* Position next to the add-to-list button */
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--light);
            border: none;
            padding: 0.5rem;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            transform: scale(0.8);
        }
        
        .movie-card:hover .done-watching-btn {
            opacity: 1;
            transform: scale(1);
        }
        
        .done-watching-btn:hover {
            background-color: #17a2b8; /* info blue color */
            transform: scale(1.1);
        }
        
        .done-watching-btn.is-done {
            background-color: #17a2b8;
            opacity: 1;
            transform: scale(1);
        }
        
        .done-watching-btn.is-done i:before {
            content: "\f058"; /* check-circle */
        }
        
        .loading {
            text-align: center;
            padding: 2rem;
            font-size: 1.2rem;
            color: var(--gray);
        }
        
        .loading i {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes slideInRight {
            0% { 
                transform: translateX(100%);
                opacity: 0;
            }
            100% { 
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .modal.active {
            opacity: 1;
            pointer-events: all;
        }

        /* Modal dropdowns (sort/filter) */
        .modal-select {
            background: rgba(255,255,255,0.08);
            color: var(--light);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 0.35rem 0.6rem;
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: 0.2px;
        }
        .modal-select:focus {
            outline: none;
            border-color: rgba(168,85,247,0.45);
            box-shadow: 0 0 0 3px rgba(168,85,247,0.15);
        }
        .modal-select option {
            background: #1f1140;
            color: #fff;
            font-weight: 600;
        }

        /* Episode details overlay used in showEpisodeDetails() */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 5000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }

        /* Ensure resume modal is above all other overlays */
        #resumeModal { z-index: 6000; }
        
        .modal-content {
            background-color: var(--card-bg);
            border-radius: 10px;
            overflow: hidden;
            width: 90%;
            max-width: 1000px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }
        
        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-header {
            position: relative;
            height: 400px;
            overflow: hidden;
        }
        
        .modal-backdrop {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: brightness(0.4);
        }
        
        .modal-header-content {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 2rem;
            display: flex;
            gap: 2rem;
        }
        
        .modal-poster {
            width: 200px;
            height: 300px;
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
        }
        
        .modal-title {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }
        
        .modal-info {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
        }
        
        .modal-rating {
            background-color: var(--tertiary);
            color: #1f1140;
            padding: 0.3rem 0.8rem;
            border-radius: 30px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .modal-year {
            font-size: 1.2rem;
            color: var(--gray);
        }
        
        .modal-tagline {
            font-style: italic;
            margin-bottom: 1rem;
            color: var(--tertiary);
        }
        
        .modal-body {
            padding: 2rem;
            background: var(--card-bg);
        }
        
        .modal-section-title {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--vlc-orange);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* Anime dropdown and button styles */
        #animeSeasonSelector:hover,
        #animeEpisodeSelector:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.25), rgba(37, 99, 235, 0.25));
            border-color: rgba(59, 130, 246, 0.5);
        }
        
        #animeSeasonSelector:focus,
        #animeEpisodeSelector:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
        
        #animeSeasonSelector option,
        #animeEpisodeSelector option {
            background: #1a1a2e;
            color: var(--light);
            padding: 0.5rem;
            font-weight: 500;
        }
        
        #animeCustomSearchBtn:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }
        
        #animeCustomSearchBtn:active {
            transform: translateY(0);
        }
        
        #animeCustomSearchInput:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
        
        .modal-overview {
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .cast-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .cast-card {
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        
        .cast-card:hover {
            transform: translateY(-5px);
        }
        
        .cast-img {
            width: 100%;
            height: 160px;
            object-fit: cover;
            border-radius: 10px;
            margin-bottom: 0.5rem;
        }
        
        .cast-name {
            font-weight: 600;
            margin-bottom: 0.2rem;
            font-size: 0.9rem;
        }
        
        .cast-character {
            font-size: 0.8rem;
            color: var(--gray);
        }
        
        .similar-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
        }
        
        .seasons-container {
            margin-bottom: 2rem;
        }
        
        .season-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        .season-btn {
            padding: 0.5rem 1rem;
            background-color: var(--input-bg);
            border: none;
            border-radius: 30px;
            color: var(--light);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .season-btn.active {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .episodes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .episode-card {
            background-color: var(--input-bg);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .episode-card:hover {
            border-color: var(--secondary);
        }

        .episode-card.selected {
            border-color: var(--vlc-orange);
            background-color: rgba(255, 105, 0, 0.1);
        }

        .episode-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            justify-content: flex-end;
        }

        .episode-done-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .episode-done-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .episode-done-btn.is-done {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border-color: #22c55e;
            color: white;
        }

        .episode-done-btn.is-done:hover {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
        }

        .episode-badge {
            position: absolute;
            top: 0.5rem;
            left: 0.5rem;
            background: linear-gradient(135deg, #ed1c24 0%, #d41920 100%);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            z-index: 5;
        }

        .episode-subtitle {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin: 0.25rem 0;
            font-style: italic;
        }

        .episode-details-btn {
            position: absolute;
            bottom: 12px;
            right: 12px;
            transform: none;
            width: auto;
            height: 36px;
            padding: 0 14px;
            border: none;
            border-radius: 18px;
            background: linear-gradient(135deg, var(--secondary) 0%, var(--vlc-orange) 100%);
            color: white;
            cursor: pointer;
            transition: all 0.25s ease;
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 0.2px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            z-index: 4;
            box-shadow: 0 6px 14px rgba(0,0,0,0.35);
            backdrop-filter: blur(6px);
            border: 1px solid rgba(255,255,255,0.15);
        }

        .episode-details-btn:hover {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, var(--secondary) 100%);
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.45);
        }

        .episode-modal {
            max-width: 700px;
            max-height: 85vh;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .episode-modal .modal-header {
            display: flex;
            align-items: center;
            padding: 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            position: relative;
        }

        .episode-modal .show-poster {
            width: 60px;
            height: 90px;
            border-radius: 8px;
            object-fit: cover;
            margin-right: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        .episode-modal .header-content {
            flex: 1;
        }

        .episode-modal .modal-header h2 {
            margin: 0 0 8px 0;
            color: white;
            font-size: 24px;
            font-weight: 700;
        }

        .episode-modal .modal-subtitle {
            margin: 0;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 500;
        }

        .episode-modal .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .episode-modal .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .episode-modal .modal-body {
            padding: 0;
            max-height: calc(85vh - 140px);
            overflow-y: auto;
        }

        .episode-list {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .episode-item {
            display: flex;
            align-items: center;
            padding: 16px 24px;
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.3s ease;
            position: relative;
        }

        .episode-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .episode-item:last-child {
            border-bottom: none;
        }

        .episode-number {
            flex-shrink: 0;
            width: 70px;
            height: 50px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            margin-right: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .episode-info {
            flex: 1;
        }

        .episode-info h4 {
            margin: 0 0 6px 0;
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            line-height: 1.3;
        }

        .episode-info p {
            margin: 0;
            color: #8a92b2;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .episode-info p i {
            color: #667eea;
        }

        .episode-remove-btn {
            flex-shrink: 0;
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: rgba(244, 67, 54, 0.8);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(244, 67, 54, 0.3);
        }

        .episode-remove-btn:hover {
            background: #f44336;
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.5);
        }
        
        .episode-img {
            width: 100%;
            height: 120px;
            object-fit: cover;
        }
        
        .episode-info {
            padding: 0.8rem;
        }
        
        .episode-title {
            font-weight: 600;
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
        }
        
        .episode-date {
            font-size: 0.8rem;
            color: var(--gray);
        }
        
        .torrents-container {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 1.5rem;
            margin-top: 2rem;
        }
        
        .torrents-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .torrents-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .torrent-item {
            background-color: var(--input-bg);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }
        
        .torrent-info {
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }
        
        .torrent-name {
            font-weight: 600;
            margin-bottom: 0.5rem;
            word-break: break-word;
            overflow-wrap: break-word;
        }
        
        .torrent-details {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            color: var(--gray);
            flex-wrap: wrap;
        }
        
        .torrent-quality {
            background-color: var(--tertiary);
            color: var(--dark);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.8rem;
        }
        
        .torrent-actions {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        .torrent-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 1rem;
        }

        .torrent-pagination button {
            background: none;
            border: none;
            color: var(--light);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .torrent-pagination button:disabled {
            color: var(--gray);
            cursor: not-allowed;
        }

        /* Chromecast Device Selection Styles */
        .chromecast-modal-header {
            padding: 1.5rem 2rem;
            border-bottom: 2px solid rgba(139, 92, 246, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chromecast-modal-header h3 {
            font-size: 1.5rem;
            color: var(--light);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 0;
        }

        .chromecast-modal-header i {
            color: var(--tertiary);
        }

        .chromecast-device-list {
            min-height: 200px;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .chromecast-device-item {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(168, 85, 247, 0.05));
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px;
            padding: 1.25rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .chromecast-device-item:hover {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(168, 85, 247, 0.1));
            border-color: var(--tertiary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }

        .chromecast-device-icon {
            font-size: 2rem;
            color: var(--tertiary);
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(139, 92, 246, 0.2);
            border-radius: 50%;
        }

        .chromecast-device-info {
            flex: 1;
        }

        .chromecast-device-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--light);
            margin-bottom: 0.25rem;
        }

        .chromecast-device-host {
            font-size: 0.9rem;
            color: var(--gray);
        }

        .loading-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            padding: 3rem;
            color: var(--gray);
        }

        .loading-spinner i {
            font-size: 2.5rem;
            color: var(--tertiary);
        }

        .chromecast-no-devices {
            text-align: center;
            padding: 3rem;
            color: var(--gray);
        }

        .chromecast-no-devices i {
            font-size: 3rem;
            color: var(--gray);
            margin-bottom: 1rem;
        }

        .chromecast-no-devices h4 {
            margin-bottom: 0.5rem;
            color: var(--light);
        }

        .chromecast-refresh-btn {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, var(--secondary), var(--tertiary));
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .chromecast-refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }


        .torrent-pagination span {
            margin: 0 1rem;
        }
        
        .provider-buttons {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            flex-wrap: nowrap; /* keep on one line */
            overflow-x: auto; /* horizontal scroll */
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x proximity;
            padding-bottom: 0.25rem;
        }
        
        .provider-btn {
            padding: 0.75rem 1.25rem;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            color: var(--light);
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.2s ease;
            white-space: nowrap;
            flex: 0 0 auto; /* don't shrink */
            scroll-snap-align: start;
            min-width: 120px;
        }
        
        .provider-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }
        
        .provider-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .provider-btn.active:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        /* Pretty pill/ghost button helpers */
        .btn-pill { border-radius: 999px; padding: 0.6rem 1rem; font-weight: 700; letter-spacing: .2px; }
        .btn-ghost { background: transparent; border: 2px solid rgba(255,255,255,0.15); color: var(--light); }
        .btn-ghost:hover { border-color: rgba(255,255,255,0.35); background: rgba(255,255,255,0.06); }
        .btn-accent { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: #fff; box-shadow: 0 8px 22px rgba(102,126,234,.35); }
        .btn-accent:hover { transform: translateY(-1px); box-shadow: 0 10px 28px rgba(102,126,234,.45); }
        
        .torrent-btn {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-play {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .btn-copy {
            background-color: var(--secondary);
            color: white;
        }

        .btn-play-now {
            background-color: var(--success);
            color: white;
        }

        /* API Key Setup Modal */
        .api-setup-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 5000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .api-setup-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .api-setup-content {
            background: var(--modal-bg);
            border-radius: 15px;
            padding: 3rem;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--vlc-orange);
        }
        
        .api-setup-title {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: var(--vlc-orange);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .api-setup-description {
            color: var(--light);
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .api-input-group {
            margin-bottom: 2rem;
        }
        
        .api-input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--tertiary);
            font-weight: 600;
        }
        
        .api-input {
            width: 100%;
            padding: 1rem;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background-color: var(--input-bg);
            color: var(--light);
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .api-input:focus {
            outline: none;
            border-color: var(--vlc-orange);
            background-color: var(--hover-bg);
        }
        
        #torrentSourceSelect {
            appearance: none;
            background-image: linear-gradient(45deg, transparent 50%, var(--primary) 50%),
                              linear-gradient(135deg, var(--primary) 50%, transparent 50%);
            background-position: calc(100% - 20px) calc(50% - 2px),
                                 calc(100% - 15px) calc(50% - 2px);
            background-size: 5px 5px, 5px 5px;
            background-repeat: no-repeat;
        }
        
        #torrentSourceSelect:hover {
            background-color: rgba(255,255,255,0.12);
            border-color: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }
        
        #torrentSourceSelect:focus {
            outline: none;
            border-color: var(--primary);
            background-color: rgba(255,255,255,0.12);
            box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.2);
        }
        
        #torrentSourceSelect option {
            background: #1a1a1a;
            color: #fff;
            padding: 0.75rem;
            font-weight: 500;
        }
        
        /* Theme selector styles */
        #themeSelector {
            transition: all 0.3s ease;
        }
        
        #themeSelector:hover {
            background: rgba(255,255,255,0.12);
            border-color: var(--vlc-orange);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        #themeSelector:focus {
            outline: none;
            border-color: var(--vlc-orange);
            background: rgba(255,255,255,0.12);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.3);
        }
        
        #themeSelector option {
            background: var(--primary);
            color: var(--light);
            padding: 1rem;
            font-weight: 500;
            font-size: 1rem;
        }
        
        #themeSelector option:hover {
            background: var(--secondary);
        }
                .torrent-source-btn {
            position: relative;
            overflow: hidden;
        }

        .torrent-source-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .torrent-source-btn.active {
            background: rgba(76, 175, 80, 0.2) !important;
            border-color: #4CAF50 !important;
            color: #4CAF50 !important;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
        }

        .torrent-source-btn:not(.active):hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
        }
        
        .api-setup-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        
        .api-btn {
            padding: 1rem 2rem;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
        }
        
        .api-btn-primary {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .api-btn-primary:hover {
            background-color: #e55a00;
            transform: translateY(-2px);
        }

        /* Debrid provider select styling */
        #debridProvider {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            min-width: 240px;
            max-width: 320px;
            background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 10px;
            padding: 0.55rem 2.25rem 0.55rem 0.85rem;
            color: #e9ecef;
            font-weight: 600;
            letter-spacing: 0.2px;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 20 20' fill='none'%3E%3Cpath d='M5 7l5 6 5-6' stroke='%23cfd4da' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.6rem center;
            background-size: 12px;
        }
        #debridProvider:hover {
            border-color: rgba(255,255,255,0.28);
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.05));
        }
        #debridProvider:focus {
            outline: none;
            border-color: var(--vlc-orange);
            box-shadow: 0 0 0 2px rgba(255,117,24,0.25);
        }
        /* Attempt to style dropdown menu items (supported in Chromium) */
        #debridProvider option {
            background-color: #151a20;
            color: #e9ecef;
        }
        
        .api-btn-secondary {
            background-color: transparent;
            color: var(--gray);
            border: 2px solid var(--gray);
        }
        
        .api-btn-secondary:hover {
            color: var(--light);
            border-color: var(--light);
        }

        /* Donate modal removed */

        /* Discord Modal */
        .discord-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 6000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .discord-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .discord-content {
            background: linear-gradient(135deg, #5865F2, #4752C4);
            border-radius: 20px;
            padding: 3rem;
            max-width: 520px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(88, 101, 242, 0.4);
            border: 2px solid #7289DA;
            position: relative;
            animation: modalSlideIn 0.4s ease;
        }
        
        @keyframes modalSlideIn {
            from {
                transform: scale(0.9) translateY(-20px);
                opacity: 0;
            }
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        
        .discord-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: rgba(0, 0, 0, 0.3);
            border: none;
            color: #fff;
            font-size: 1.5rem;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .discord-close:hover {
            background-color: #ED4245;
            transform: rotate(90deg);
        }
        
        .discord-title {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            font-weight: 700;
        }
        
        .discord-logo {
            width: 48px;
            height: 48px;
        }
        
        .discord-message {
            color: #fff;
            margin-bottom: 2rem;
            line-height: 1.8;
            font-size: 1.05rem;
        }
        
        .discord-join-btn {
            padding: 1rem 2.5rem;
            border-radius: 30px;
            border: none;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            background: #fff;
            color: #5865F2;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .discord-join-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);
        }

        /* Settings Modal */
        .settings-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 4000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .settings-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .settings-content {
            background: var(--modal-bg);
            border-radius: 15px;
            padding: 2rem;
            max-width: 800px;
            width: min(92%, 800px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--vlc-orange);
            max-height: 85vh;
            overflow: auto;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }
        
        .settings-title {
            font-size: 1.8rem;
            color: var(--vlc-orange);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .settings-close {
            background: transparent;
            border: none;
            color: var(--gray);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s ease;
            padding: 0.5rem;
        }
        
        .settings-close:hover {
            color: var(--light);
        }
        
        .settings-section {
            margin-bottom: 2rem;
        }
        
        .settings-section h3 {
            color: var(--tertiary);
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }
        .source-badge { display:inline-block; padding:2px 8px; border-radius: 12px; font-size: 0.75rem; font-weight:700; margin-left: 8px; background: #6c757d; color: #fff; }
        .source-badge.debrid { background:#198754; }
        .source-badge.webtorrent { background:#0d6efd; }
        .source-badge.direct-stream { background:#dc3545; }
        
        .current-api-key {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            color: var(--gray);
            font-family: monospace;
        }
        
        .settings-buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        /* Floating Navigation Arrow (Old UI Only, Home Page Only) */
        .floating-nav-container {
            position: fixed;
            right: 30px;
            bottom: 30px;
            z-index: 1000;
            display: none;
        }

        .floating-nav-btn {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--vlc-orange) 0%, var(--secondary) 100%);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 1.4rem;
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(168, 85, 247, 0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .floating-nav-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 12px 30px rgba(168, 85, 247, 0.4);
            background: linear-gradient(135deg, var(--tertiary) 0%, var(--vlc-orange) 100%);
        }

        .floating-nav-btn:active {
            transform: translateY(0) scale(0.95);
        }

        .floating-nav-menu {
            position: absolute;
            bottom: 70px;
            right: 0;
            background: rgba(42, 24, 71, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 0.5rem 0;
            min-width: 160px;
            /* Make the menu usable on small screens */
            max-height: calc(100vh - 140px); /* leave room for FAB and margins */
            overflow-y: auto;
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            pointer-events: none;
            transition: all 0.3s ease;
        }

        .floating-nav-container.active .floating-nav-menu {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: all;
        }

        .floating-nav-container.active .floating-nav-btn {
            background: linear-gradient(135deg, #6d28d9, #553c9a);
        }

        .floating-nav-container.active #floatingNavIcon {
            transform: rotate(180deg);
        }

        .floating-nav-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .floating-nav-item:last-child {
            border-bottom: none;
        }

        .floating-nav-item:hover {
            background: rgba(139, 92, 246, 0.2);
            color: #c084fc;
        }

        .floating-nav-item i {
            width: 16px;
            text-align: center;
            opacity: 0.8;
        }

        .floating-nav-item span {
            font-weight: 500;
            font-size: 0.9rem;
        }

        /* Show floating nav only in old UI on home page */
        body:not(.ui-new) .floating-nav-container.show-on-home {
            display: block;
        }

        /* Hide in new UI */
        body.ui-new .floating-nav-container {
            display: none !important;
        }

        /* Books Page Styles */
        .books-search-section {
            margin-bottom: 2rem;
        }

        .books-search-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .books-search-bar {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 16px;
            padding: 0.5rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .books-search-bar:focus-within {
            border-color: rgba(245, 158, 11, 0.5);
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.15);
        }

        .books-search-icon {
            position: absolute;
            left: 1.25rem;
            color: #9ca3af;
            font-size: 1.1rem;
        }

        #books-search-input, #music-search-input {
            flex: 1;
            padding: 1rem 1.5rem;
            padding-left: 3rem;
            background: transparent;
            border: none;
            color: #fff;
            font-size: 1.1rem;
            outline: none;
        }

        #books-search-input::placeholder, #music-search-input::placeholder {
            color: #9ca3af;
        }

        .books-search-button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            border-radius: 12px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .books-search-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.3);
        }

        .books-loading {
            text-align: center;
            padding: 4rem 2rem;
            color: #9ca3af;
        }

        .books-loading-spinner {
            font-size: 3rem;
            margin-bottom: 1.5rem;
            color: #f59e0b;
        }

        .books-empty {
            text-align: center;
            padding: 4rem 2rem;
            color: #9ca3af;
        }

        .books-empty-icon {
            font-size: 4rem;
            margin-bottom: 2rem;
            color: #f59e0b;
        }

        .books-empty h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #fff;
        }

        .books-results {
            animation: fadeIn 0.5s ease;
        }

        .books-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .books-results-header h3 {
            font-size: 1.5rem;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .books-results-count {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: #fff;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .books-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
        }

        /* Music (compact) overrides using books classes */
        #music-page .books-results-grid {
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem;
        }
        #music-page .books-book-card {
            cursor: default;
        }
        .music-card {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 14px;
            overflow: hidden;
            transition: all 0.25s ease;
        }
        .music-card:hover {
            transform: translateY(-4px);
            border-color: rgba(236, 72, 153, 0.45);
            box-shadow: 0 10px 30px rgba(236, 72, 153, 0.15);
        }
        .music-cover {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: linear-gradient(135deg, #374151, #1f2937);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .music-cover img { width: 100%; height: 100%; object-fit: cover; }
        .music-info { padding: 0.75rem 0.85rem; }
        .music-title { font-size: 0.95rem; font-weight: 700; color: #fff; margin: 0 0 0.25rem 0; line-height: 1.25; }
        .music-artist { font-size: 0.85rem; color: #ec4899; margin: 0 0 0.5rem 0; }
        .music-actions { display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; }
        .music-play-btn {
            flex: 1;
            display: inline-flex; align-items: center; justify-content: center; gap: 0.4rem;
            padding: 0.5rem 0.75rem;
            background: linear-gradient(135deg, #ec4899, #a855f7);
            border: none; border-radius: 10px; color: #fff; font-weight: 700; cursor: pointer;
        }
        .music-open-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(236,72,153,0.35); background: rgba(236,72,153,0.12); color: #ec4899; cursor: pointer;
        }
        .music-heart-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(236,72,153,0.35); background: rgba(236,72,153,0.12); color: #ec4899; cursor: pointer;
        }
        .music-heart-btn.added {
            border-color: rgba(244,114,182,0.6);
            background: rgba(244,114,182,0.2);
            color: #f472b6;
        }
        .music-plus-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(56,189,248,0.35); background: rgba(56,189,248,0.12); color: #38bdf8; cursor: pointer;
        }
        .music-download-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(34,197,94,0.35); background: rgba(34,197,94,0.12); color: #22c55e; cursor: pointer;
            transition: all 0.2s ease;
        }
        .music-download-btn.downloaded {
            border-color: rgba(34,197,94,0.6);
            background: rgba(34,197,94,0.25);
            color: #22c55e;
        }
        .music-download-btn:hover {
            filter: brightness(1.15);
            transform: scale(1.05);
        }
        .music-folder-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(251,191,36,0.35); background: rgba(251,191,36,0.12); color: #fbbf24; cursor: pointer;
        }
        .music-delete-downloaded-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(239,68,68,0.35); background: rgba(239,68,68,0.12); color: #ef4444; cursor: pointer;
        }
        .music-play-btn:hover, .music-open-btn:hover, .music-heart-btn:hover, .music-plus-btn:hover, .music-folder-btn:hover, .music-delete-downloaded-btn:hover {
            filter: brightness(1.08);
        }
        /* Playlist open view header tweak */
        #music-page.playlist-open .books-results-header h3 i { display: none; }
        #music-page.playlist-open .books-results-header h3 { gap: 0; }

        /* Playlists list view buttons */
        .playlist-open-btn {
            display: inline-flex; align-items: center; gap: 0.4rem;
            padding: 0.45rem 0.7rem; border-radius: 10px; border: none;
            background: linear-gradient(135deg, #a855f7, #ec4899); color: #fff; cursor: pointer;
            font-weight: 700; font-size: 0.9rem;
        }
        .playlist-delete-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(239,68,68,0.45); background: rgba(239,68,68,0.12); color: #ef4444; cursor: pointer;
        }
        .playlist-open-btn:hover, .playlist-delete-btn:hover { filter: brightness(1.08); }

        /* Close playlist header button */
        .playlist-close-btn {
            display: inline-flex; align-items: center; gap: 0.45rem;
            padding: 0.5rem 0.8rem; border-radius: 10px; border: 1px solid rgba(148,163,184,0.35);
            background: rgba(148,163,184,0.12); color: #e2e8f0; cursor: pointer;
            font-weight: 700; margin-left: auto;
        }
        .playlist-close-btn:hover { filter: brightness(1.08); }
        .music-add-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(16,185,129,0.35); background: rgba(16,185,129,0.12); color: #10b981; cursor: pointer;
        }
        .music-add-btn.added {
            border-color: rgba(34,197,94,0.6);
            background: rgba(34,197,94,0.18);
            color: #22c55e;
        }

        /* Albums UI */
        .album-card {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(59,130,246,0.18);
            border-radius: 14px;
            overflow: hidden;
            transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }
        .album-card:hover { transform: translateY(-3px); border-color: rgba(59,130,246,0.35); box-shadow: 0 14px 34px rgba(2,6,23,0.45); }
        .album-cover { width: 100%; aspect-ratio: 1 / 1; object-fit: cover; background:#111827; display:block; }
        .album-body { padding: 0.75rem; display:flex; flex-direction:column; gap:0.4rem; }
        .album-title { font-weight: 800; color:#e5e7eb; line-height:1.2; }
        .album-artist { color:#9ca3af; font-size:0.9rem; }
        .album-meta { color:#94a3b8; font-size:0.82rem; display:flex; gap:0.5rem; align-items:center; }
        .album-open-btn { display:inline-flex; align-items:center; gap:0.4rem; padding:0.45rem 0.75rem; border:none; border-radius:10px; background: linear-gradient(135deg,#38bdf8,#0ea5e9); color:#05222e; font-weight:800; cursor:pointer; }
        .album-open-btn:hover { filter: brightness(1.05); }

        .album-tracks-list .track-row {
            display:grid; grid-template-columns: 32px 1fr 90px 210px; gap:0.75rem; align-items:center;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(59,130,246,0.14);
            border-radius: 12px; padding: 0.5rem 0.6rem;
            transition: background 0.2s ease, border-color 0.2s ease;
        }
        .track-row:hover { background: rgba(255,255,255,0.07); border-color: rgba(59,130,246,0.25); }
        .track-index { color:#94a3b8; font-weight:700; text-align:center; }
        .track-title { color:#e5e7eb; font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .track-duration { color:#94a3b8; text-align:right; font-variant-numeric: tabular-nums; }
        .track-actions { display:flex; justify-content:flex-end; gap:0.4rem; flex-wrap:wrap; }
        .track-play-btn, .track-plus-btn, .track-heart-btn {
            display:inline-flex; align-items:center; gap:0.35rem; border-radius: 10px; cursor:pointer;
            padding: 0.4rem 0.65rem; font-size: 0.8rem; font-weight: 800; border: 1px solid rgba(148,163,184,0.25);
            background: linear-gradient(135deg, rgba(51,65,85,0.8), rgba(15,23,42,0.6)); color:#e5e7eb;
            transition: transform 0.12s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }
        .track-play-btn:hover, .track-plus-btn:hover, .track-heart-btn:hover { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(2,6,23,0.35); border-color: rgba(148,163,184,0.4); }
        .track-play-btn { background: linear-gradient(135deg, #34d399, #10b981); color:#052e2b; border:none; }
        .track-plus-btn { background: linear-gradient(135deg, #c4b5fd, #a78bfa); color:#1e1b4b; border:none; }
        .track-heart-btn { background: linear-gradient(135deg, #fda4af, #fb7185); color:#4c0519; border:none; }
        .album-empty { color:#94a3b8; text-align:center; padding:1rem 0; }

        /* My Albums heart button */
        .album-heart-btn {
            width: 38px; height: 38px; display:inline-flex; align-items:center; justify-content:center;
            border-radius: 10px; border: 1px solid rgba(236,72,153,0.35); background: rgba(236,72,153,0.12); color:#ec4899; cursor:pointer;
            transition: filter 0.15s ease;
        }
        .album-heart-btn.added {
            border-color: rgba(236,72,153,0.6); background: rgba(236,72,153,0.2); color:#f472b6;
        }
        .album-heart-btn:hover { filter: brightness(1.08); }

        .books-book-card {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .books-book-card:hover {
            transform: translateY(-5px);
            border-color: rgba(245, 158, 11, 0.4);
            box-shadow: 0 10px 40px rgba(245, 158, 11, 0.15);
        }

        .books-book-cover {
            position: relative;
            width: 100%;
            height: 200px;
            overflow: hidden;
            background: linear-gradient(135deg, #374151, #1f2937);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .books-book-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }

        .books-book-card:hover .books-book-cover img {
            transform: scale(1.05);
        }

        .books-book-cover-placeholder {
            font-size: 3rem;
            color: #9ca3af;
        }

        .books-book-format {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: #fff;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .books-book-info {
            padding: 1.5rem;
        }

        .books-book-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 0.5rem;
            line-height: 1.4;
            display: -webkit-box;
            line-clamp: 2;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .books-book-author {
            color: #9ca3af;
            font-size: 0.95rem;
            margin-bottom: 0.75rem;
        }

        .books-book-year {
            display: inline-block;
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .books-book-actions {
            display: flex;
            gap: 0.75rem;
        }

        .books-read-btn {
            flex: 1;
            padding: 0.75rem;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            border-radius: 10px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .books-read-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.3);
        }
        /* Ensure Library "Read" buttons look styled as well */
        .read-btn {
            width: 100%;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            border-radius: 12px;
            color: #fff;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.25s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: 0 4px 14px rgba(245, 158, 11, 0.25);
        }
        .read-btn:hover { transform: translateY(-2px); box-shadow: 0 8px 22px rgba(245, 158, 11, 0.35); }
        .read-btn:active { transform: translateY(0); }

        .books-download-btn {
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: #9ca3af;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .books-download-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            color: #fff;
        }

        /* Books Reader Modal */
        .books-reader-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.98);
            z-index: 9999;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .books-reader-content {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            display: flex;
            flex-direction: column;
            background: var(--dark);
            overflow: hidden;
        }
        
        /* Music player modal gets constrained size */
        #music-player-modal .books-reader-content {
            width: 90%;
            max-width: 560px;
            height: auto;
            max-height: 90vh;
        }

        .books-reader-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 2rem;
            background: var(--primary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
            min-height: 70px;
        }

        .books-reader-back-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .books-reader-back-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(-2px);
        }

        .books-reader-title {
            color: #fff;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .books-reader-frame-container {
            flex: 1;
            width: 100%;
            height: calc(100vh - 70px);
            position: relative;
            background: #fff;
            overflow: hidden;
        }

        .books-reader-frame {
            width: 100%;
            height: 100%;
            border: none;
            background: #fff;
            display: block;
        }

        /* Ensure no body scroll when reader is open */
        body.books-reader-open {
            overflow: hidden;
        }

        /* IPTV Source Selector */
        .iptv-source-selector {
            background: #1a0f2e;
            padding: 15px 20px;
            border-bottom: 1px solid #2d1b4e;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .iptv-source-label {
            color: #a78bfa;
            font-size: 14px;
            font-weight: 600;
            min-width: 80px;
        }

        .iptv-source-dropdown {
            background: #2d1b4e;
            border: 1px solid #4c1d95;
            border-radius: 8px;
            color: #e5e7eb;
            padding: 8px 12px;
            font-size: 14px;
            min-width: 300px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .iptv-source-dropdown:hover {
            border-color: #7c3aed;
            background: #362159;
        }

        .iptv-source-dropdown:focus {
            outline: none;
            border-color: #a78bfa;
            box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.1);
        }

        .iptv-source-dropdown option {
            background: #2d1b4e;
            color: #e5e7eb;
            padding: 8px 12px;
            border: none;
        }

        .iptv-source-dropdown option:hover {
            background: #4c1d95;
        }

        .iptv-source-dropdown option:selected {
            background: #7c3aed;
            color: #ffffff;
        }

        /* Server Selection Modal */
        .server-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            /* Match page background instead of pure black overlay */
            background: var(--dark);
            z-index: 9998;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }

        .server-selection-content {
            width: 100%;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background: var(--dark);
            overflow: visible;
        }

        .server-selection-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 2rem;
            background: var(--primary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
            min-height: 70px;
        }

        .server-selection-back-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .server-selection-back-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(-2px);
        }

        .server-selection-title {
            color: #fff;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .server-selection-body {
            flex: 1;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            /* Make the server selection (and embedded iframe) a bit wider */
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .server-selection-info {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 1.5rem;
        }

        .media-info {
            display: flex;
            gap: 1.5rem;
            align-items: flex-start;
        }

        .media-poster {
            width: 120px;
            height: 180px;
            border-radius: 12px;
            object-fit: cover;
            background: linear-gradient(135deg, #374151, #1f2937);
        }

        .media-details {
            flex: 1;
        }

        .media-details h4 {
            font-size: 1.5rem;
            color: #fff;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .media-details p {
            color: #9ca3af;
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        .media-meta {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .media-year {
            background: rgba(168, 85, 247, 0.2);
            color: #a855f7;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .media-rating {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .server-dropdown-section {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 2rem;
        }

        .server-dropdown-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .server-dropdown-container {
            position: relative;
        }

        .server-dropdown {
            width: 100%;
            padding: 1rem 1.5rem;
            padding-right: 4.5rem; /* extra space so custom chevron never overlaps scrollbar */
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            color: #fff;
            font-size: 1rem;
            font-weight: 500;
            appearance: none;
            cursor: pointer;
            transition: all 0.3s ease;
            max-height: 200px;
            overflow-y: auto;
            /* Make the dropdown scrollbar easier to see */
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #22d3ee rgba(255, 255, 255, 0.12); /* thumb color | track color */
            scrollbar-gutter: stable both-edges; /* reserve space for scrollbar (Chromium/Firefox) */
        }

        /* WebKit-based scrollbars (Chromium/Electron) */
        .server-dropdown::-webkit-scrollbar {
            width: 14px; /* thicker for visibility */
        }

        .server-dropdown::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5); /* darker track for contrast */
            border-radius: 8px;
        }

        .server-dropdown::-webkit-scrollbar-thumb {
            background: #22d3ee; /* bright cyan for high contrast */
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.15);
        }

        .server-dropdown::-webkit-scrollbar-thumb:hover {
            background: #06b6d4;
        }

        .server-dropdown option {
            background: var(--dark);
            color: #fff;
            padding: 0.5rem;
        }

        .server-dropdown:focus {
            outline: none;
            border-color: rgba(168, 85, 247, 0.5);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.15);
        }

        .server-dropdown option {
            background: var(--primary);
            color: #fff;
            padding: 1rem;
            font-weight: 500;
        }

        .server-dropdown-arrow {
            position: absolute;
            right: 2.5rem; /* shift left so it never covers the scrollbar */
            top: 50%;
            transform: translateY(-50%);
            color: #9ca3af;
            pointer-events: none;
            transition: transform 0.3s ease;
        }

        .server-dropdown:focus + .server-dropdown-arrow {
            transform: translateY(-50%) rotate(180deg);
        }

        .server-actions {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .server-watch-btn {
            flex: 1;
            padding: 1rem 2rem;
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            border: none;
            border-radius: 12px;
            color: #fff;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            min-width: 200px;
        }

        .server-watch-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(139, 92, 246, 0.3);
        }

        .server-torrent-btn {
            padding: 1rem 2rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            color: #9ca3af;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            min-width: 180px;
        }

        .server-torrent-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            color: #fff;
        }

        /* Embedded Video Player Section */
        .server-video-section {
            margin-top: 2rem;
            background: var(--dark);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .server-video-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background: var(--dark);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .server-video-header h4 {
            color: #fff;
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .server-video-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .server-video-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #e50914;
        }

        .server-video-container {
            position: relative;
            width: 100%;
            /* Make the embedded server player noticeably larger and responsive */
            height: 70vh;
            min-height: 480px;
            /* Match the app background so the area under the iframe blends in */
            background: var(--dark);
        }

        .server-video-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .server-video-controls {
            padding: 1rem 1.5rem;
            background: var(--dark);
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        /* Video Player Modal */
        .video-player-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.98);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .video-player-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: var(--dark);
            overflow: hidden;
        }

        .video-player-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 2rem;
            background: var(--primary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
            min-height: 70px;
        }

        .video-player-back-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .video-player-back-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(-2px);
        }

        .video-player-title {
            color: #fff;
            font-size: 1.2rem;
            font-weight: 600;
            flex: 1;
            margin: 0 2rem;
        }

        .video-player-controls {
            display: flex;
            gap: 0.5rem;
        }

        .video-player-control-btn {
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .video-player-control-btn:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .video-player-frame-container {
            flex: 1;
            width: 100%;
            height: calc(100vh - 70px);
            position: relative;
            background: #000;
            overflow: hidden;
        }

        .video-player-frame {
            width: 100%;
            height: 100%;
            border: none;
            background: #000;
            display: block;
        }

        /* Prevent body scroll when modals are open */
        body.server-modal-open,
        body.video-modal-open {
            overflow: hidden;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* BookTorrio Page Styles */
        .booktorrio-nav {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            justify-content: center;
        }

        /* EPUB Reader Styles */
        #epubReaderOverlay {
            position: fixed;
            inset: 0;
            background: var(--bg);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            /* Solid bar theming variables (no transparency) */
            --bar-bg: #202225; /* solid by default (dark) */
            --bar-border: rgba(255,255,255,0.1);
            --bar-btn-bg: #2b2b2b;       /* dark default */
            --bar-btn-border: #3a3a3a;
            --bar-input-bg: #1f1f1f;
            --bar-input-border: #3a3a3a;
        }
        /* Light theme overrides */
        #epubReaderOverlay.theme-light {
            --bar-bg: #ffffff;
            --bar-border: rgba(0,0,0,0.08);
            --bar-btn-bg: #f3f4f6;      /* slate-100 */
            --bar-btn-border: #e5e7eb;  /* slate-200 */
            --bar-input-bg: #ffffff;
            --bar-input-border: #e5e7eb;
        }
        /* Night theme overrides */
        #epubReaderOverlay.theme-night {
            --bar-bg: #000000;
            --bar-border: rgba(255,255,255,0.12);
            --bar-btn-bg: #111111;
            --bar-btn-border: #262626;
            --bar-input-bg: #0b0b0b;
            --bar-input-border: #262626;
        }
        .reader-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            padding: 0.75rem 1rem;
            background-color: var(--bar-bg) !important;
            /* Solid header bar, no transparency */
            backdrop-filter: none;
            border-bottom: 1px solid var(--bar-border);
            box-shadow: 0 2px 6px rgba(0,0,0,0.22);
            position: sticky;
            top: 0;
            z-index: 2100;
        }
        .reader-esc-hint {
            color: var(--text);
            font-size: 0.85rem;
            white-space: nowrap;
            /* Make the hint itself solid (no transparency) */
            background: var(--bar-btn-bg);
            border: 1px solid var(--bar-btn-border);
            padding: 0.35rem 0.6rem;
            border-radius: 6px;
        }
        .reader-title { 
            text-align: center; 
            color: var(--text); 
            font-weight: 600; 
            flex: 1;
        }
        #readerContainer { 
            flex: 1; 
            overflow-y: auto; 
            overflow-x: hidden;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Bottom navigation bar */
        .reader-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            padding: 0.75rem 1rem;
            background-color: var(--bar-bg) !important;
            /* Solid footer bar, no transparency */
            backdrop-filter: none;
            border-top: 1px solid var(--bar-border);
            box-shadow: 0 -2px 6px rgba(0,0,0,0.22);
            position: sticky;
            bottom: 0;
            z-index: 2100;
        }
        .reader-nav-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
            justify-content: center;
        }
        .reader-chapter-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text);
        }
        .reader-chapter-controls .chapter-count-label {
            font-size: 0.9rem;
            opacity: 0.8;
            white-space: nowrap;
        }
        .reader-chapter-controls input[type="number"] {
            width: 84px;
            height: 36px;
            padding: 0 0.5rem;
            border-radius: 6px;
            border: 1px solid var(--bar-input-border);
            background: var(--bar-input-bg);
            color: var(--text);
            outline: none;
        }
        .reader-chapter-controls input[type="number"]::placeholder {
            color: rgba(255,255,255,0.55);
        }
        .reader-nav-btn, .reader-gear, .reader-back-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 44px; 
            height: 44px;
            padding: 0 1rem;
            border-radius: 8px;
            border: 1px solid var(--bar-btn-border);
            background: var(--bar-btn-bg);
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
            gap: 0.5rem;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .reader-nav-btn {
            min-width: 44px;
            padding: 0;
        }
        .reader-nav-btn:hover:not(:disabled), .reader-gear:hover, .reader-back-btn:hover {
            background: #6d28d9; /* solid purple on hover */
            border-color: #7c3aed;
            color: #fff;
            transform: translateY(-2px);
        }
        .reader-back-btn:hover {
            background: #dc2626; /* solid red for back hover */
            border-color: #ef4444;
            color: #fff;
        }
        .reader-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .reader-settings {
            position: fixed;
            bottom: 60px; /* above footer */
            right: 0;
            width: 320px;
            max-height: 400px;
            background: var(--bg);
            color: #eee;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px 0 0 0;
            transform: translateX(0);
            transition: transform 0.2s ease;
            padding: 1rem;
            z-index: 2050;
        }
        .reader-settings.hidden { transform: translateX(100%); }
        .settings-section { margin-bottom: 1rem; }
        .settings-row { display: flex; gap: 0.5rem; }
        .theme-btn { padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.06); color: #eee; cursor: pointer; }

        /* Themes for overlay container */
        .theme-light { --bg: #ffffff; --text: #111111; }
        .theme-dark  { --bg: #202225; --text: #f2f2f2; }
        .theme-night { --bg: #000000; --text: #e5e7eb; }
        
        .booktorrio-tab-btn {
            padding: 1rem 2rem;
            border-radius: 12px;
            border: 2px solid rgba(168, 85, 247, 0.3);
            background: rgba(42, 24, 71, 0.4);
            color: var(--light);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            backdrop-filter: blur(10px);
        }
        
        .booktorrio-tab-btn:hover {
            border-color: #06b6d4;
            background: rgba(6, 182, 212, 0.1);
        }
        
        .booktorrio-tab-btn.active {
            border-color: #06b6d4;
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
        }
        
        .booktorrio-tab {
            display: block;
        }
        
        .search-container-books {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .search-input-books {
            flex: 1;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            border: 2px solid rgba(168, 85, 247, 0.3);
            background: rgba(42, 24, 71, 0.4);
            color: var(--light);
            font-size: 1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .search-input-books:focus {
            outline: none;
            border-color: var(--vlc-orange);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.2);
        }
        
        .search-btn-books {
            padding: 1rem 2rem;
            border-radius: 12px;
            border: none;
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .search-btn-books:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(6, 182, 212, 0.4);
        }
        
        .books-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .book-card {
            background: rgba(42, 24, 71, 0.4);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 16px;
            padding: 1.5rem;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
        }
        
        .book-card:hover {
            transform: translateY(-4px);
            border-color: #06b6d4;
            box-shadow: 0 8px 25px rgba(6, 182, 212, 0.2);
        }
        
        .book-cover {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 12px;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
        }
        
        .book-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--light);
            margin-bottom: 0.5rem;
            line-height: 1.3;
            display: -webkit-box;
            line-clamp: 2;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .book-author {
            color: #06b6d4;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        
        .book-details {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .book-tag {
            background: rgba(6, 182, 212, 0.2);
            color: #06b6d4;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            border: 1px solid rgba(6, 182, 212, 0.3);
        }
        
        .book-tag.epub-highlight {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border-color: #10b981;
        }
        
        .download-btn {
            width: 100%;
            padding: 0.75rem 1rem;
            border-radius: 12px;
            border: none;
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(6, 182, 212, 0.4);
        }
        
        .search-placeholder {
            grid-column: 1 / -1;
            text-align: center;
            padding: 3rem;
            color: var(--gray);
        }
        
        .search-placeholder h3 {
            color: var(--light);
            margin-bottom: 0.5rem;
        }
        
        /* Spinner for loading */
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(6, 182, 212, 0.3);
            border-left-color: #06b6d4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* EPUB Download Modal Styles */
        .epub-download-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
        }
        
        .epub-modal-content {
            background: linear-gradient(135deg, var(--primary) 0%, #1a0d2e 100%);
            border-radius: 16px;
            border: 1px solid rgba(168, 85, 247, 0.3);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }
        
        .epub-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
        }
        
        .epub-modal-header h3 {
            color: var(--light);
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .epub-modal-close {
            background: none;
            border: none;
            color: var(--gray);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .epub-modal-close:hover {
            background: rgba(168, 85, 247, 0.2);
            color: var(--light);
        }
        
        .epub-modal-body {
            padding: 1.5rem;
        }
        
        .epub-download-instruction {
            margin-bottom: 1.5rem;
        }
        
        .epub-download-instruction p {
            color: var(--light);
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        
        .epub-path-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid rgba(168, 85, 247, 0.2);
            margin-bottom: 1rem;
        }
        
        .epub-path-container code {
            flex: 1;
            color: #06b6d4;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            word-break: break-all;
        }
        
        .copy-path-btn {
            background: rgba(6, 182, 212, 0.2);
            border: 1px solid #06b6d4;
            color: #06b6d4;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .copy-path-btn:hover {
            background: #06b6d4;
            color: white;
        }
        
        .epub-note {
            font-size: 0.9rem;
            color: var(--gray);
            font-style: italic;
        }
        
        .epub-modal-actions {
            display: flex;
            justify-content: center;
        }
        
        .epub-download-btn {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
        }
        
        .epub-download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(6, 182, 212, 0.4);
        }

        /* VLC Player Styles */
        .vlc-player-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--vlc-dark);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            /* Prevent any child from increasing the viewport height */
            overflow: hidden;
        }
        
        .vlc-player-container.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .vlc-player-header {
            background-color: rgba(0, 0, 0, 0.8);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--vlc-orange);
            position: sticky;
            top: 0;
            z-index: 2100;
        }
        
        .vlc-player-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
            position: relative;
            z-index: 2101;
        }
        
        .vlc-player-close {
            background: var(--vlc-orange);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 600;
            position: relative;
            z-index: 2102;
            pointer-events: auto;
        }
        
        .vlc-player-close:hover {
            background: #e55a00;
        }
        
        .vlc-player-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--vlc-dark);
            /* Allow inner flex children to shrink within viewport */
            min-height: 0;
            min-width: 0;
            position: relative;
            z-index: 1;
        }
        
        .file-selector {
            background: rgba(0, 0, 0, 0.5);
            padding: 1rem 2rem;
            border-bottom: 1px solid #444;
            position: relative;
            z-index: 1;
        }
        
        .file-selector h3 {
            color: var(--vlc-orange);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .file-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
            max-height: 400px;
            overflow-y: auto;
        }

        /* MPV controls layout and spacing */
        #mpvControls {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem 0 1.25rem;
            position: relative;
            z-index: 0;
        }

        #mpvControls .vlc-btn { width: auto; }
        
        .file-item {
            position: relative;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .file-item:hover {
            background: rgba(255, 105, 0, 0.2);
            border-color: var(--vlc-orange);
        }
        
        .file-name {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.9rem;
        }

        .file-name-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--dark);
            color: var(--light);
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
            white-space: normal;
            width: max-content;
            max-width: 300px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        
        .file-size {
            color: var(--gray);
            font-size: 0.9rem;
        }
        
        .vlc-player-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            position: relative;
            /* Ensure contained media never pushes layout */
            min-height: 0;
            min-width: 0;
            overflow: hidden;
            z-index: 1;
        }
        
        .vlc-loading {
            color: var(--vlc-orange);
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            position: relative;
            z-index: 2;
            pointer-events: none;
        }
        
        .vlc-loading i {
            animation: spin 1s linear infinite;
        }
        
        /* Base button styles for MPV/WCJS action buttons */
        .vlc-btn {
            background: var(--vlc-orange);
            border: none;
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
        }

        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 2rem 2rem 1rem;
            transition: transform 0.25s ease, opacity 0.25s ease;
            z-index: 3;
        }
        
        .vlc-btn:hover {
            background: #e55a00;
            transform: translateY(-2px);
        }
        
        .vlc-btn.secondary {
            background: var(--secondary);
        }
        
        .vlc-btn.secondary:hover {
            background: #0199c7;
        }
        
        .subtitle-controls {
            background: rgba(0, 0, 0, 0.5);
            padding: 1rem 2rem;
            flex-direction: column;
            position: relative;
            z-index: 0;
        }
        
        .subtitle-controls h4 {
            color: var(--vlc-orange);
            margin-bottom: 1rem;
        }
        
        .subtitle-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            max-height: 200px;
            overflow-y: auto;
            padding-right: 1rem; /* For scrollbar */
        }
        
        .subtitle-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }
        
        .subtitle-item:hover {
            background: rgba(255, 105, 0, 0.2);
            border-color: var(--vlc-orange);
        }

        .subtitle-item.selected {
            border-color: var(--success);
            background-color: rgba(40, 167, 69, 0.2);
        }
        
        .subtitle-lang {
            font-weight: 600;
            color: white;
            flex-grow: 1;
        }

        /* Custom Video Player Styles */
        .custom-player-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 3000;
            display: flex;
            flex-direction: column;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            /* Lock overlay to viewport */
            overflow: hidden;
        }

        .custom-player-container.active {
            opacity: 1;
            pointer-events: all;
        }

        .player-header {
            background: none;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 5;
        }

        .player-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .player-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .subtitle-upload {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .subtitle-upload input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .upload-btn {
            background: var(--secondary);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .upload-btn:hover {
            background: #0199c7;
            transform: translateY(-1px);
        }

        .close-player-btn {
            background: var(--danger);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .close-player-btn:hover {
            background: #c82333;
            transform: translateY(-1px);
        }

        .video-container {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Critical for flex children so they don't overflow the viewport */
            min-height: 0;
            min-width: 0;
            overflow: hidden;
        }

        .custom-video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Always fit inside container */
            /* Ensure the video stays beneath overlays */
            z-index: 1;
        }
        
        /* Video.js subtitle positioning and styling */
        .video-js .vjs-text-track-display {
            bottom: 8em !important;
            pointer-events: none;
        }
        
        .video-js .vjs-text-track-cue {
            pointer-events: auto;
        }
        
        /* Hide Video.js error messages */
        .video-js .vjs-error-display,
        .video-js .vjs-modal-dialog {
            display: none !important;
        }

        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 2rem 2rem 1rem;
            /* Always visible to avoid being pushed off-screen */
            transform: translateY(0);
            transition: transform 0.3s ease;
            z-index: 2;
        }

        /* Auto-hide behavior scoped to custom player only */
        .custom-player-container .video-controls { transform: translateY(100%); opacity: 0; pointer-events: none; }
        .custom-player-container .video-container.show-controls .video-controls,
        .custom-player-container .video-controls.force-visible {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        /* Hide player header (title and close button) when controls are hidden */
        .custom-player-container .player-header { 
            transform: translateY(-100%); 
            opacity: 0; 
            pointer-events: none; 
            transition: transform 0.25s ease, opacity 0.25s ease;
        }
        .custom-player-container.show-controls .player-header,
        .custom-player-container .player-header.force-visible {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        /* Hide cursor when controls are hidden */
        .custom-player-container:not(.show-controls) {
            cursor: none;
        }
        .custom-player-container:not(.show-controls) * {
            cursor: none;
        }

        .progress-container {
            margin-bottom: 1rem;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .progress-filled {
            height: 100%;
            background: var(--vlc-orange);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s ease;
        }

        .progress-time {
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        .control-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }
        .control-left,
        .control-right { display:flex; align-items:center; gap:1rem; }

        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 0.8rem;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            width: 50px;
            height: 50px;
        }

        .control-btn:hover {
            background: var(--vlc-orange);
            transform: scale(1.1);
        }

        .control-btn.play-pause {
            background: var(--vlc-orange);
            font-size: 1.5rem;
            width: 60px;
            height: 60px;
        }

        .control-btn.play-pause:hover {
            background: #e55a00;
        }

        .fullscreen-btn {
            position: absolute;
            right: 1rem;
            bottom: 1rem;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--vlc-orange);
            font-size: 1.5rem;
            z-index: 2; /* below controls, above video */
        }

        .subtitle-display {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 1.1rem;
            font-weight: 500;
            text-align: center;
            max-width: 80%;
            display: none;
        }
        
        .notification {
            position: fixed;
            top: 2rem;
            right: 2rem;
            background: linear-gradient(135deg, rgba(40, 40, 40, 0.95) 0%, rgba(30, 30, 30, 0.95) 100%);
            color: var(--text-primary);
            padding: 1.25rem 1.75rem;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10000;
            transform: translateY(-100px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            max-width: 400px;
            min-width: 300px;
            font-weight: 500;
            font-size: 0.95rem;
            line-height: 1.4;
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            /* Allow clicks to pass through so it never blocks UI like the music search bar */
            pointer-events: none;
        }

        .notification.success {
            border-left: 4px solid #22c55e;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(40, 40, 40, 0.95) 100%);
        }

        .notification.success::before {
            content: '';
            color: #22c55e;
            font-weight: bold;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        .notification.error {
            border-left: 4px solid #ef4444;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(40, 40, 40, 0.95) 100%);
        }

        .notification.error::before {
            content: '';
            color: #ef4444;
            font-weight: bold;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        .notification.info {
            border-left: 4px solid #3b82f6;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(40, 40, 40, 0.95) 100%);
        }

        .notification.info::before {
            content: '';
            color: #3b82f6;
            font-weight: bold;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        .notification.warning {
            border-left: 4px solid #f59e0b;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(40, 40, 40, 0.95) 100%);
        }

        .notification.warning::before {
            content: '';
            color: #f59e0b;
            font-weight: bold;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        /* Subtitles menu panel */
        .subs-panel {
            position: absolute;
            right: 1rem;
            bottom: 6rem;
            width: 340px;
            max-height: 40vh;
            overflow: auto;
            background: rgba(0,0,0,0.9);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 0.5rem;
            display: none;
            z-index: 10;
        }
        .subs-item { display:flex; align-items:center; justify-content:space-between; background: rgba(255,255,255,0.06); color:#fff; padding:0.5rem 0.6rem; border-radius:6px; margin:0.35rem 0; cursor:pointer; }
        .subs-item:hover { background: rgba(168,85,247,0.25); }
        .subs-badge { font-size: 0.75rem; color:#ccc; }
        .subs-source { font-size: 0.75rem; opacity: 0.8; margin-left: 0.4rem; }
        .row-spread { display:flex; align-items:center; justify-content:space-between; gap:0.5rem; }
        .subs-header { display:flex; align-items:center; justify-content:space-between; color:#fff; margin-bottom:0.25rem; }
        .subs-help { color:#bbb; font-size:0.8rem; margin-bottom:0.25rem; }
        .menu-actions { display:flex; align-items:center; gap:0.5rem; }
        .menu-refresh { background: rgba(255,255,255,0.15); border:none; color:#fff; padding:0.2rem 0.5rem; border-radius:4px; cursor:pointer; }
        
        /* Subtitle Upload and Customization Styles */
        .subs-upload { display:flex; flex-direction:column; gap:0.4rem; margin:0.5rem 0; background: rgba(255,255,255,0.06); padding:0.5rem; border-radius:6px; }
        .subs-upload-btn { background: var(--vlc-orange); color:#fff; border:none; padding:0.45rem 0.75rem; border-radius:6px; cursor:pointer; display:flex; align-items:center; gap:0.4rem; font-weight:600; justify-content:center; font-size:0.85rem; }
        .subs-upload-btn:hover { background:#e55a00; }
        .subs-divider { height:1px; background: rgba(255,255,255,0.12); margin:0.6rem 0; }
        .subs-settings { display:flex; flex-direction:column; gap:0.5rem; margin:0.5rem 0; }
        .subs-setting-row { display:flex; align-items:center; gap:0.5rem; font-size:0.8rem; color:#eee; }
        .subs-setting-row label { flex: 0 0 85px; }
        .subs-setting-row input[type="range"] { flex:1; }
        .subs-setting-row input[type="color"] { width:42px; height:28px; border:none; padding:0; background:none; cursor:pointer; }
        .subs-setting-row select { 
            flex:1; 
            padding:0.4rem 0.6rem; 
            border-radius:6px; 
            border:1px solid rgba(255,255,255,0.15); 
            background: rgba(255,255,255,0.08); 
            color:#fff; 
            font-size:0.85rem;
            font-weight:500;
            cursor:pointer;
        }
        .subs-setting-row select option {
            background: #1a1a1a;
            color: #fff;
        }
        .subs-setting-value { min-width:46px; text-align:right; color:#bbb; font-size:0.75rem; }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }

        /* ===== TRAKT PAGE STYLES ===== */
        .trakt-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .trakt-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .trakt-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 32px rgba(237, 28, 36, 0.2);
            border-color: rgba(237, 28, 36, 0.3);
        }

        .trakt-card-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            background: linear-gradient(90deg, rgba(237, 28, 36, 0.1) 0%, transparent 100%);
        }

        .trakt-card-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .trakt-card-header i {
            color: #ed1c24;
            font-size: 1.1rem;
        }

        .trakt-card-body {
            padding: 2rem;
        }

        .trakt-status-card {
            border: 2px solid rgba(237, 28, 36, 0.3);
        }

        .trakt-status-section {
            text-align: center;
        }

        .trakt-status-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .trakt-status-indicator.connected {
            color: #22c55e;
        }

        .trakt-status-indicator.disconnected {
            color: #ef4444;
        }

        .trakt-status-indicator i {
            font-size: 1.3rem;
        }

        .trakt-description {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 2rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .trakt-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
            font-size: 0.95rem;
        }

        .trakt-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .trakt-btn-primary {
            background: linear-gradient(135deg, #ed1c24 0%, #d41920 100%);
            color: white;
        }

        .trakt-btn-primary:hover:not(:disabled) {
            background: linear-gradient(135deg, #d41920 0%, #b8161c 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(237, 28, 36, 0.4);
        }

        .trakt-btn-secondary {
            background: rgba(255,255,255,0.1);
            color: var(--text-primary);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .trakt-btn-secondary:hover:not(:disabled) {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        .trakt-btn-info {
            background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
            color: white;
        }

        .trakt-btn-info:hover:not(:disabled) {
            background: linear-gradient(135deg, #0284c7 0%, #0369a1 100%);
        }

        .trakt-user-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Device Code Panel */
        .trakt-device-code {
            margin-top: 2rem;
            padding: 2rem;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            border: 1px solid rgba(237, 28, 36, 0.2);
        }

        .trakt-code-header h4 {
            margin: 0 0 1.5rem 0;
            color: var(--text-primary);
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .trakt-code-content {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .trakt-code-display {
            text-align: center;
        }

        .trakt-code-display label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .trakt-code-value {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .trakt-code-value span {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 1.5rem;
            font-weight: 800;
            background: rgba(255,255,255,0.1);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: 2px solid rgba(237, 28, 36, 0.3);
            color: #ed1c24;
            letter-spacing: 0.2em;
        }

        .trakt-copy-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .trakt-copy-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .trakt-verify-section {
            text-align: center;
        }

        .trakt-verify-section p {
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .trakt-verify-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .trakt-status-message {
            padding: 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border-left: 4px solid #ed1c24;
        }

        .trakt-status-message span {
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Actions Grid */
        .trakt-actions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
        }

        .trakt-action-card {
            cursor: pointer;
            padding: 2rem;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .trakt-action-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #ed1c24 0%, #d41920 100%);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .trakt-action-card:hover::before {
            transform: scaleX(1);
        }

        .trakt-action-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 32px rgba(237, 28, 36, 0.15);
        }

        .trakt-action-icon {
            margin-bottom: 1rem;
        }

        .trakt-action-icon i {
            font-size: 2.5rem;
            color: #ed1c24;
        }

        .trakt-action-content h4 {
            margin: 0 0 0.5rem 0;
            color: var(--text-primary);
            font-size: 1.1rem;
        }

        .trakt-action-content p {
            margin: 0 0 1rem 0;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .trakt-action-count {
            display: inline-block;
            background: linear-gradient(135deg, #ed1c24 0%, #d41920 100%);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .trakt-action-badge {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            color: var(--text-primary);
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
            border: 1px solid rgba(255,255,255,0.2);
        }

        /* Settings Grid */
        .trakt-settings-grid {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .trakt-setting-item {
            padding: 1.5rem;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        .trakt-setting-item:hover {
            background: rgba(255,255,255,0.08);
            border-color: rgba(237, 28, 36, 0.3);
        }

        .trakt-setting-main {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .trakt-setting-content h4 {
            margin: 0 0 0.25rem 0;
            color: var(--text-primary);
            font-size: 1rem;
        }

        .trakt-setting-content p {
            margin: 0;
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.4;
        }

        /* Custom Toggle Switch */
        .trakt-toggle {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            flex-shrink: 0;
        }

        .trakt-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .trakt-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255,255,255,0.2);
            transition: 0.3s;
            border-radius: 24px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .trakt-toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .trakt-toggle input:checked + .trakt-toggle-slider {
            background: linear-gradient(135deg, #ed1c24 0%, #d41920 100%);
            border-color: #ed1c24;
        }

        .trakt-toggle input:checked + .trakt-toggle-slider:before {
            transform: translateX(26px);
        }

        /* Activity List */
        .trakt-activity-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .trakt-activity-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border-left: 4px solid #ed1c24;
        }

        .trakt-activity-icon {
            flex-shrink: 0;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #ed1c24 0%, #d41920 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .trakt-activity-content {
            flex: 1;
        }

        .trakt-activity-title {
            margin: 0 0 0.25rem 0;
            color: var(--text-primary);
            font-weight: 600;
            font-size: 0.95rem;
        }

        .trakt-activity-meta {
            margin: 0;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .trakt-container {
                padding: 1rem;
                gap: 1.5rem;
            }

            .trakt-card-body {
                padding: 1.5rem;
            }

            .trakt-actions-grid {
                grid-template-columns: 1fr;
            }

            .trakt-verify-actions {
                flex-direction: column;
                align-items: center;
            }

            .trakt-user-actions {
                flex-direction: column;
                align-items: center;
            }

            .trakt-setting-main {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.75rem;
            }
        }
        /* ===== END TRAKT PAGE STYLES ===== */

        .error-message {
            background-color: var(--danger);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Genres pages styles */
        .genre-card {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 120px;
            text-align: center;
        }
        .genre-title {
            color: var(--light);
            font-size: 1.2rem;
        }
        .genre-chip {
            display: inline-block;
            margin-top: 0.5rem;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            background: rgba(255,255,255,0.1);
            color: var(--tertiary);
            border: 1px solid rgba(255,255,255,0.15);
        }
        .genre-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .genre-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .toggle-btn {
            padding: 0.5rem 1rem;
            border-radius: 30px;
            border: 2px solid var(--vlc-orange);
            background: transparent;
            color: var(--vlc-orange);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .toggle-btn.active {
            background: var(--vlc-orange);
            color: #fff;
        }
        
        @media (max-width: 768px) {
            .header-container {
                flex-direction: column;
                gap: 1rem;
            }
            
            .search-container {
                margin: 1rem 0;
                width: 100%;
            }
            
            .modal-header-content {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .modal-poster {
                width: 150px;
                height: 225px;
            }
            
            .modal-title {
                font-size: 1.8rem;
            }
            
            .file-list {
                grid-template-columns: 1fr;
            }
            
            .video-controls {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            
            .vlc-btn { /* mobile sizing override only */
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
            .player-header {
                z-index: 3;
                padding: 0.5rem 1rem;
                flex-direction: column;
                gap: 1rem;
            }

            .player-actions {
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .control-buttons {
                gap: 0.5rem;
            }

            .control-btn {
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }

            .control-btn.play-pause {
                width: 50px;
                height: 50px;
                font-size: 1.3rem;
            }

            .api-setup-content {
                padding: 2rem;
            }

            .api-setup-buttons {
                flex-direction: column;
            }

            .settings-content {
                padding: 1.5rem;
            }

            .settings-buttons {
                flex-direction: column;
            }
        }

        /* ========================================
           NEW UI STYLES - Modern App Interface
           ======================================== */
        
        /* OLD UI: Show app-container but without flex layout, hide sidebar */
        body.ui-old {
            display: block;
            height: auto;
            overflow: visible;
        }
        
        body.ui-old .app-container {
            display: block;
            height: auto;
        }
        
        body.ui-old .app-sidebar {
            display: none !important;
        }
        
        body.ui-old .app-main {
            display: block;
            overflow: visible;
            height: auto;
        }
        
        body.ui-old header {
            position: sticky;
            top: 0;
        }
        
        body.ui-old main {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 1rem;
            overflow: visible;
        }
        
        /* NEW UI: Sidebar Navigation */
        body.ui-new {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        body.ui-new .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        body.ui-new .app-sidebar {
            display: flex;
            width: 240px;
            background: var(--modal-bg);
            border-right: 1px solid rgba(168, 85, 247, 0.2);
            flex-direction: column;
            overflow-y: auto;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
        }
        
        body.ui-new .sidebar-logo {
            padding: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--light);
            border-bottom: 1px solid rgba(168, 85, 247, 0.15);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        body.ui-new .sidebar-logo:hover {
            background: rgba(168, 85, 247, 0.1);
        }
        
        body.ui-new .sidebar-logo i {
            color: var(--vlc-orange);
            font-size: 1.8rem;
        }
        
        /* Sidebar Stats Panel */
        body.ui-new .sidebar-stats {
            padding: 1rem 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        body.ui-new .stat-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: rgba(168, 85, 247, 0.08);
            border-radius: 8px;
            border: 1px solid rgba(168, 85, 247, 0.15);
        }
        
        body.ui-new .stat-item i {
            font-size: 1.5rem;
            color: var(--vlc-orange);
            width: 32px;
            text-align: center;
        }
        
        body.ui-new .stat-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        body.ui-new .stat-label {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        body.ui-new .stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--light);
        }
        
        body.ui-new .sidebar-divider {
            height: 1px;
            background: rgba(168, 85, 247, 0.15);
            margin: 0.5rem 1rem;
        }
        
        body.ui-new .nav-section-title {
            padding: 1rem 1.5rem 0.5rem;
            font-size: 0.7rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 1px;
        }
        
        body.ui-new .nav-badge {
            margin-left: auto;
            padding: 0.15rem 0.5rem;
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 600;
        }
        
        /* Sidebar Quick Actions */
        body.ui-new .sidebar-quick-actions {
            padding: 0.75rem 1.5rem;
            margin-top: auto;
        }
        
        body.ui-new .quick-action-title {
            font-size: 0.7rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 1px;
            margin-bottom: 0.5rem;
        }
        
        body.ui-new .quick-action-btn {
            width: 100%;
            padding: 0.65rem;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            color: var(--light);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        
        body.ui-new .quick-action-btn:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: var(--vlc-orange);
            transform: translateY(-1px);
        }
        
        body.ui-new .sidebar-user-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        body.ui-new .sidebar-user-info i {
            font-size: 1.5rem;
            color: var(--vlc-orange);
        }
        
        body.ui-new .sidebar-nav {
            flex: 1;
            padding: 0.5rem 0;
        }
        
        body.ui-new .nav-item {
            padding: 0.85rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
            font-weight: 500;
        }
        
        body.ui-new .nav-item:hover {
            background: rgba(168, 85, 247, 0.1);
            color: var(--light);
            border-left-color: var(--vlc-orange);
        }
        
        body.ui-new .nav-item.active {
            background: rgba(168, 85, 247, 0.15);
            color: var(--light);
            border-left-color: var(--vlc-orange);
        }
        
        body.ui-new .nav-item i {
            width: 20px;
            text-align: center;
        }
        
        body.ui-new .sidebar-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid rgba(168, 85, 247, 0.15);
        }
        
        /* Main Content Area */
        body.ui-new .app-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--dark);
        }
        
        /* Modern Header */
        body.ui-new header {
            position: static;
            background: linear-gradient(90deg, var(--primary) 0%, #1f1035 100%);
            padding: 1.25rem 2rem;
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.2);
        }
        
        body.ui-new .header-container {
            justify-content: space-between;
            max-width: none;
        }
        
        body.ui-new .logo {
            display: none; /* Logo in sidebar instead */
        }
        
        body.ui-new .search-container {
            flex: 0 1 500px;
            margin: 0;
        }
        
        body.ui-new .search-container input {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .search-container input:focus {
            background: rgba(0, 0, 0, 0.4);
            border-color: var(--vlc-orange);
        }
        
        body.ui-new .user-actions {
            gap: 0.75rem;
        }
        
        body.ui-new .btn {
            border-radius: 8px;
            padding: 0.65rem 1.1rem;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .btn-outline {
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.4);
        }
        
        body.ui-new .btn-outline.active {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-color: transparent;
            color: white;
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.4);
        }
        
        body.ui-new .btn-primary {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);
        }
        
        /* Connection Status */
        body.ui-new .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(40, 167, 69, 0.1);
            border: 1px solid rgba(40, 167, 69, 0.3);
            border-radius: 20px;
            font-size: 0.85rem;
            color: #28a745;
        }
        
        body.ui-new .connection-status i {
            font-size: 0.5rem;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        /* Hide connection status in OLD UI */
        body.ui-old .connection-status {
            display: none;
        }
        
        /* Enhanced Page Header */
        body.ui-new .page-header-enhanced {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(168, 85, 247, 0.05);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .page-title-section {
            flex: 1;
        }
        
        body.ui-new .page-subtitle {
            margin-top: 0.5rem;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }
        
        body.ui-new .page-actions {
            display: flex;
            gap: 0.75rem;
        }
        
        body.ui-new .action-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.65rem 1.25rem;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            color: var(--light);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }
        
        body.ui-new .action-btn:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: var(--vlc-orange);
            transform: translateY(-2px);
        }
        
        /* Hide enhanced elements in OLD UI */
        body.ui-old .page-header-enhanced {
            display: none;
        }
        
        body.ui-old .page-subtitle {
            display: none;
        }
        
        /* Content Area */
        body.ui-new main {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            margin: 0;
            padding: 2rem 2.5rem;
            max-width: none;
            background: linear-gradient(135deg, var(--dark) 0%, #0a0612 100%);
        }
        
        /* Modern Section Titles */
        body.ui-new .section-title {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid rgba(168, 85, 247, 0.3);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        body.ui-new .section-title i {
            color: var(--vlc-orange);
        }
        
        /* Category Pills */
        body.ui-new .categories {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }
        
        body.ui-new .category {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1.5rem;
            border-radius: 25px;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.25s ease;
            font-weight: 500;
        }
        
        body.ui-new .category i {
            font-size: 0.9rem;
        }
        
        body.ui-new .category:hover {
            background: var(--hover-bg);
            border-color: var(--vlc-orange);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.2);
        }
        
        body.ui-new .category.active {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-color: transparent;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
        }
        
        /* Modern Movie Cards with Glass Morphism */
        body.ui-new .movie-card {
            background: var(--card-bg);
            border: 1px solid rgba(168, 85, 247, 0.2);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        body.ui-new .movie-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 12px 30px rgba(168, 85, 247, 0.35);
            border-color: var(--vlc-orange);
        }
        
        body.ui-new .movie-poster {
            position: relative;
            overflow: hidden;
        }
        
        body.ui-new .movie-poster::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.7) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        body.ui-new .movie-card:hover .movie-poster::after {
            opacity: 1;
        }
        
        body.ui-new .movie-poster img {
            transition: transform 0.3s ease;
        }
        
        body.ui-new .movie-card:hover .movie-poster img {
            transform: scale(1.1);
        }
        
        /* New UI Add to List Button */
        body.ui-new .add-to-list-btn {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(168, 85, 247, 0.5);
            color: var(--light);
            padding: 0.6rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            transform: scale(0.7) translateY(10px);
            backdrop-filter: blur(10px);
            z-index: 2;
        }
        
        body.ui-new .movie-card:hover .add-to-list-btn {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
        
        body.ui-new .add-to-list-btn:hover {
            background: var(--success);
            border-color: var(--success);
            transform: scale(1.1) translateY(0);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }
        
        body.ui-new .add-to-list-btn.in-list {
            background: var(--success);
            border-color: var(--success);
            opacity: 1;
            transform: scale(1) translateY(0);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }
        
        body.ui-new .add-to-list-btn.in-list i:before {
            content: "\f00c"; /* checkmark */
        }
        
        /* New UI Done Watching Button */
        body.ui-new .done-watching-btn {
            position: absolute;
            top: 12px;
            left: 60px; /* Position next to the add-to-list button */
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(23, 162, 184, 0.5);
            color: var(--light);
            padding: 0.6rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            transform: scale(0.7) translateY(10px);
            backdrop-filter: blur(10px);
            z-index: 2;
        }
        
        body.ui-new .movie-card:hover .done-watching-btn {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
        
        body.ui-new .done-watching-btn:hover {
            background: #17a2b8;
            border-color: #17a2b8;
            transform: scale(1.1) translateY(0);
            box-shadow: 0 4px 15px rgba(23, 162, 184, 0.4);
        }
        
        body.ui-new .done-watching-btn.is-done {
            background: #17a2b8;
            border-color: #17a2b8;
            opacity: 1;
            transform: scale(1) translateY(0);
            box-shadow: 0 4px 15px rgba(23, 162, 184, 0.3);
        }
        
        body.ui-new .done-watching-btn.is-done i:before {
            content: "\f058"; /* check-circle */
        }
        
        body.ui-new .movie-info {
            padding: 1.25rem;
            background: linear-gradient(180deg, rgba(42, 24, 71, 0.6) 0%, rgba(18, 10, 31, 0.8) 100%);
        }
        
        body.ui-new .movie-title {
            font-size: 1.05rem;
            margin-bottom: 0.5rem;
            color: var(--light);
        }
        
        body.ui-new .movie-meta {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            font-size: 0.85rem;
        }
        
        body.ui-new .movie-rating {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.2) 0%, rgba(255, 152, 0, 0.2) 100%);
            border: 1px solid rgba(255, 193, 7, 0.4);
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .movie-year {
            background: rgba(168, 85, 247, 0.15);
            border: 1px solid rgba(168, 85, 247, 0.3);
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
        }
        
        /* Genre Boxes */
        body.ui-new .genre-box {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.15) 0%, rgba(139, 92, 246, 0.1) 100%);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            transition: all 0.3s ease;
        }
        
        body.ui-new .genre-box:hover {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.25) 0%, rgba(139, 92, 246, 0.2) 100%);
            border-color: var(--vlc-orange);
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(168, 85, 247, 0.3);
        }
        
        /* Modern Modal */
        body.ui-new .modal-content {
            background: linear-gradient(135deg, rgba(42, 24, 71, 0.95) 0%, rgba(18, 10, 31, 0.95) 100%);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        body.ui-new .modal-close {
            background: rgba(168, 85, 247, 0.2);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
        }
        
        body.ui-new .modal-close:hover {
            background: rgba(220, 53, 69, 0.3);
            border-color: #dc3545;
            transform: rotate(90deg);
        }
        
        /* Buttons in Modal */
        body.ui-new .play-btn {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border: none;
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.4);
        }
        
        body.ui-new .play-btn:hover {
            box-shadow: 0 8px 25px rgba(168, 85, 247, 0.6);
            transform: translateY(-2px);
        }
        
        /* Settings Modal */
        body.ui-new .settings-content {
            background: linear-gradient(135deg, rgba(42, 24, 71, 0.95) 0%, rgba(18, 10, 31, 0.95) 100%);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(20px);
        }
        
        body.ui-new .settings-section {
            background: rgba(168, 85, 247, 0.05);
            border: 1px solid rgba(168, 85, 247, 0.2);
            backdrop-filter: blur(10px);
        }
        
        /* Loading Indicators */
        body.ui-new .loading {
            color: var(--vlc-orange);
        }
        
        /* Scrollbar Styling for New UI */
        body.ui-new ::-webkit-scrollbar {
            width: 10px;
        }
        
        body.ui-new ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }
        
        body.ui-new ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-radius: 5px;
        }
        
        body.ui-new ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #9333ea 0%, var(--vlc-orange) 100%);
        }
        
        /* Settings Page Styles */
        .settings-page-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .settings-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid rgba(168, 85, 247, 0.2);
            padding-bottom: 0;
            flex-wrap: wrap;
        }
        
        .settings-tab {
            padding: 1rem 2rem;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            position: relative;
            bottom: -2px;
        }
        
        .settings-tab:hover {
            color: var(--light);
            background: rgba(168, 85, 247, 0.05);
        }
        
        .settings-tab.active {
            color: var(--vlc-orange);
            border-bottom-color: var(--vlc-orange);
            background: rgba(255, 111, 0, 0.05);
        }
        
        .settings-sections {
            position: relative;
        }
        
        .settings-section {
            display: none;
            animation: fadeIn 0.3s ease;
        }
        
        .settings-section.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .settings-card {
            background: var(--card-bg);
            border-radius: 12px;
            margin-bottom: 1.5rem;
            overflow: hidden;
            border: 1px solid rgba(168, 85, 247, 0.15);
            transition: all 0.3s ease;
        }
        
        .settings-card:hover {
            border-color: rgba(168, 85, 247, 0.3);
            box-shadow: 0 4px 20px rgba(168, 85, 247, 0.1);
        }
        
        .settings-card-header {
            background: var(--modal-bg);
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid rgba(168, 85, 247, 0.15);
        }
        
        .settings-card-header h3 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--light);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .settings-card-header h3 i {
            color: var(--vlc-orange);
        }
        
        .settings-card-body {
            padding: 1.5rem;
        }
        
        .settings-card-body .form-group {
            margin-bottom: 1.5rem;
        }
        
        .settings-card-body .form-group:last-child {
            margin-bottom: 0;
        }
        
        .settings-card-body label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .settings-card-body input[type="text"],
        .settings-card-body input[type="url"],
        .settings-card-body input[type="password"],
        .settings-card-body select,
        .settings-card-body textarea {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--input-bg);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 8px;
            color: var(--light);
            font-size: 0.95rem;
            transition: all 0.2s ease;
        }
        
        .settings-card-body input:focus,
        .settings-card-body select:focus,
        .settings-card-body textarea:focus {
            outline: none;
            border-color: var(--vlc-orange);
            background: rgba(0, 0, 0, 0.4);
        }
        
        .settings-card-body button {
            padding: 0.75rem 1.5rem;
            background: var(--vlc-orange);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .settings-card-body button:hover {
            background: #e65100;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 111, 0, 0.3);
        }
        
        .settings-card-body .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .settings-card-body .checkbox-group input[type="checkbox"] {
            width: auto;
            cursor: pointer;
        }
        
        .settings-card-body .radio-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .settings-card-body .radio-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: rgba(168, 85, 247, 0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .settings-card-body .radio-option:hover {
            background: rgba(168, 85, 247, 0.1);
        }
        
        .settings-card-body .radio-option input[type="radio"] {
            width: auto;
            cursor: pointer;
        }
        
        /* Responsive adjustments for New UI */
        @media (max-width: 1024px) {
            body.ui-new .app-sidebar {
                width: 200px;
            }
            
            body.ui-new main {
                padding: 1.5rem 1.5rem;
            }
        }
        
        @media (max-width: 768px) {
            body.ui-new .app-sidebar {
                position: fixed;
                left: -240px;
                top: 0;
                bottom: 0;
                z-index: 1000;
                transition: left 0.3s ease;
            }
            
            body.ui-new .app-sidebar.mobile-open {
                left: 0;
            }
            
            body.ui-new .search-container {
                flex: 1;
            }
        }
    </style>
    <!-- Google Cast SDK -->
    <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>
</head>
<body>
<!-- API Setup Modal -->
<div class="api-setup-modal" id="apiSetupModal">
    <div class="api-setup-content">
        <h2 class="api-setup-title">
            <i class="fas fa-key"></i>
            Setup Required
        </h2>
        <p class="api-setup-description">
            Welcome to PlayTorrio Streamer! To search for torrents, you need to provide your Jackett API key.
            Please install Jackett, add the indexers you'd like to search torrents from, and paste the API key below.
            You can download the installer by clicking
            <button type="button" id="openJackettLink" style="background:#0d6efd;color:#fff;border:none;border-radius:6px;padding:0.25rem 0.6rem;cursor:pointer;font-weight:600;">Here</button>.
            This will be saved locally and used to access your Jackett server.
        </p>
        <div class="api-input-group">
            <label for="firstTimeApiKey">Jackett API Key:</label>
            <input type="text" id="firstTimeApiKey" class="api-input" placeholder="Enter your Jackett API key..." />
        </div>
        <div class="api-setup-buttons">
            <button class="api-btn api-btn-primary" id="saveFirstTimeApiKey">
                <i class="fas fa-save"></i>
                Save & Continue
            </button>
            <button class="api-btn api-btn-secondary" id="useTorrentlessSetup">
                <i class="fas fa-play"></i>
                Watch without Jackett
            </button>
            <button class="api-btn" id="videoTutorialFirst" style="background:#0d6efd; color:#fff;">
                <i class="fas fa-video"></i> Video Tutorial
            </button>
        </div>
    </div>
</div>

<!-- Donate modal removed -->

<!-- Discord Modal -->
<div class="discord-modal" id="discordModal">
    <div class="discord-content">
        <button class="discord-close" id="discordClose">
            <i class="fas fa-times"></i>
        </button>
        <h2 class="discord-title">
            <svg class="discord-logo" viewBox="0 0 71 55" fill="none" xmlns="http://www.w3.org/2000/svg">
                <g clip-path="url(#clip0)">
                    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z" fill="white"/>
                </g>
                <defs>
                    <clipPath id="clip0">
                        <rect width="71" height="55" fill="white"/>
                    </clipPath>
                </defs>
            </svg>
            Join the Discord
        </h2>
        <div class="discord-message">
            <p>Suggest features, report bugs, be a part of the community, and help me make a better app.</p>
        </div>
        <div style="display:flex; gap:0.75rem; flex-wrap: wrap;">
            <button class="discord-join-btn" id="discordJoinBtn" style="flex:1;">
                <i class="fab fa-discord"></i>
                Join Discord
            </button>
            <button class="discord-join-btn" id="discordDontShowBtn" style="background: rgba(255,255,255,0.12); flex:1;">
                <i class="fas fa-eye-slash"></i>
                Don't show again
            </button>
        </div>
    </div>
</div>

<!-- Update Announcement Modal -->
<div class="discord-modal" id="updateModal">
    <div class="discord-content" style="max-width: 600px;">
        <button class="discord-close" id="updateClose">
            <i class="fas fa-times"></i>
        </button>
        <h2 class="discord-title" style="display: flex; align-items: center; gap: 1rem; font-size: 1.8rem;">
            <i class="fas fa-rocket" style="color: var(--vlc-orange);"></i>
            New in v1.5.3
        </h2>
        <div class="discord-message" style="text-align: left;">
            <p style="font-size: 1.1rem; margin-bottom: 1.2rem;">
                This update delivers enhanced media playback, optimized streaming, and new entertainment options:
            </p>
            <ul style="list-style: none; padding: 0; margin-bottom: 1.2rem;">
                <li style="margin-bottom: 0.9rem; padding-left: 2rem; position: relative;">
                    <i class="fas fa-play-circle" style="position: absolute; left: 0; color: var(--vlc-orange); margin-top: 0.2rem;"></i>
                    <strong>VLC Media Player Integration</strong>  Added VLC as a new external player option alongside MPV for superior format compatibility and playback control.
                </li>
                <li style="margin-bottom: 0.9rem; padding-left: 2rem; position: relative;">
                    <i class="fas fa-filter" style="position: absolute; left: 0; color: var(--vlc-orange); margin-top: 0.2rem;"></i>
                    <strong>Optimized Streaming Servers</strong>  Removed non-functional providers and refined server selection for faster, more reliable streaming.
                </li>
                <li style="margin-bottom: 0.9rem; padding-left: 2rem; position: relative;">
                    <i class="fas fa-gamepad" style="position: absolute; left: 0; color: var(--vlc-orange); margin-top: 0.2rem;"></i>
                    <strong>MiniGames Platform</strong>  Introducing PlayTorrio MiniGames  access a curated collection of browser-based games directly within the app.
                </li>
            </ul>
            <p style="color: var(--secondary); font-size: 0.95rem; margin-top: 0.5rem;">
                <i class="fas fa-info-circle"></i> Thank you for updating! Enjoy the enhanced media experience and new features.
            </p>
        </div>
        <button class="discord-join-btn" id="updateGotItBtn" style="background: var(--vlc-orange); width: 100%;">
            <i class="fas fa-check"></i>
            Got It!
        </button>
    </div>
</div>

<!-- What's New v1.6.3 Modal -->
<div class="discord-modal" id="version163Modal" style="display: none;">
    <div class="discord-content" style="max-width: 600px;">
        <button class="discord-close" id="version163Close">
            <i class="fas fa-times"></i>
        </button>
        <h2 class="discord-title" style="display: flex; align-items: center; gap: 1rem; font-size: 1.8rem;">
            <i class="fas fa-sparkles" style="color: var(--vlc-orange);"></i>
            Welcome to v1.6.3
        </h2>
        <div class="discord-message" style="text-align: left;">
            <p style="font-size: 1.05rem; margin-bottom: 1rem;">
                Thanks for updating! Here's what's new in this version:
            </p>
            
            <div style="background: rgba(255,255,255,0.05); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                <h3 style="color: #ec4899; margin-bottom: 0.75rem; font-size: 1.1rem;">
                    <i class="fas fa-music"></i> Music Player Enhancements
                </h3>
                <ul style="list-style: none; padding-left: 0; color: #e5e7eb;">
                    <li style="margin-bottom: 0.5rem;"> <strong>Minimize Mode:</strong> Keep music playing in a compact notification-style player while browsing other sections</li>
                    <li style="margin-bottom: 0.5rem;"> <strong>Background Playback:</strong> Navigate freely through the app without interrupting your music</li>
                    <li style="margin-bottom: 0.5rem;"> <strong>Full Controls:</strong> Play/pause, skip, rewind, and track navigation from the mini player</li>
                </ul>
            </div>
            
            <div style="background: rgba(255,255,255,0.05); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                <h3 style="color: #10b981; margin-bottom: 0.75rem; font-size: 1.1rem;">
                    <i class="fas fa-sort-amount-down"></i> Torrent Sorting & Filtering
                </h3>
                <ul style="list-style: none; padding-left: 0; color: #e5e7eb;">
                    <li style="margin-bottom: 0.5rem;"> <strong>Sort by File Size:</strong> Organize torrents by size (ascending/descending) or seeders</li>
                    <li style="margin-bottom: 0.5rem;"> <strong>Size Filters:</strong> Filter torrents by size ranges (1GB+, 2GB+, 2-4GB, 4-8GB, 8GB+)</li>
                    <li style="margin-bottom: 0.5rem;"> <strong>Instant Updates:</strong> Results update immediately when changing sort or filter options</li>
                </ul>
            </div>
            
            <div style="background: rgba(255,255,255,0.05); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                <h3 style="color: #3b82f6; margin-bottom: 0.75rem; font-size: 1.1rem;">
                    <i class="fas fa-cloud-download-alt"></i> Improved Debrid Support
                </h3>
                <ul style="list-style: none; padding-left: 0; color: #e5e7eb;">
                    <li style="margin-bottom: 0.5rem;"> <strong>Single File Downloads:</strong> Real-Debrid now only downloads your selected file, not the entire torrent</li>
                    <li style="margin-bottom: 0.5rem;"> <strong>Bandwidth Optimization:</strong> Saves bandwidth and storage across all debrid providers</li>
                    <li style="margin-bottom: 0.5rem;"> <strong>Default Client ID:</strong> Automatic fallback for Real-Debrid authentication</li>
                </ul>
            </div>
            
            <div style="background: rgba(255,255,255,0.05); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                <h3 style="color: #f59e0b; margin-bottom: 0.75rem; font-size: 1.1rem;">
                    <i class="fas fa-book-reader"></i> Manga Reader Improvements
                </h3>
                <ul style="list-style: none; padding-left: 0; color: #e5e7eb;">
                    <li style="margin-bottom: 0.5rem;"> <strong>Cleaner Interface:</strong> Removed top navigation bar for distraction-free reading</li>
                    <li style="margin-bottom: 0.5rem;"> <strong>Floating Back Button:</strong> Sticky back button stays accessible while reading</li>
                    <li style="margin-bottom: 0.5rem;"> <strong>Keyboard Hint:</strong> On-screen reminder to use arrow keys for navigation</li>
                </ul>
            </div>
            
            <p style="font-size: 0.95rem; margin-top: 1rem; color: #9ca3af;">
                If you enjoy PlayTorrio, consider supporting development!
            </p>
        </div>
        <div style="display:flex; gap:0.75rem;">
            <button class="discord-join-btn" id="version163DonateBtn" style="background: var(--vlc-orange); flex:1;">
                <i class="fas fa-heart"></i>
                Donate
            </button>
            <button class="discord-join-btn" id="version163GotItBtn" style="background: rgba(255,255,255,0.12); flex:1;">
                <i class="fas fa-check"></i>
                Got it
            </button>
        </div>
    </div>
    <style>
        /* Ensure modal uses same visibility behavior as others */
        #version163Modal.active { display: flex !important; }
    </style>
</div>

<!-- Settings Modal -->
<div class="settings-modal" id="settingsModal">
    <div class="settings-content">
        <div class="settings-header">
            <h2 class="settings-title">
                <i class="fas fa-cog"></i>
                Settings
            </h2>
            <button class="settings-close" id="settingsClose">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="settings-section">
            <h3>Jackett API Configuration</h3>
            <div class="current-api-key" id="currentApiKey">
                No API key configured
            </div>
            <div class="api-input-group">
                <label for="newApiKey">New API Key:</label>
                <input type="text" id="newApiKey" class="api-input" placeholder="Enter new Jackett API key..." />
            </div>
            <div class="api-input-group" style="margin-top:1rem;">
                <label for="jackettUrl">Jackett Base URL:</label>
                <input type="text" id="jackettUrl" class="api-input" placeholder="http://127.0.0.1:9117/api/v2.0/indexers/all/results/torznab" />
                <small style="color:var(--secondary); font-size:0.85rem; margin-top:0.25rem;">Default: http://127.0.0.1:9117/api/v2.0/indexers/all/results/torznab</small>
            </div>
            <!-- Removed: Watch without Jackett & Torrent Source options -->
        </div>

        <div class="settings-section" style="margin-top:1.25rem;">
            <h3>Streaming Mode</h3>
            <div style="margin-top:0.5rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                    <input type="checkbox" id="useStreamingServersToggle" />
                    <span>Use Streaming Servers instead of Torrents</span>
                </label>
                <div style="margin-top:0.5rem; color:#10b981; font-size:0.9rem;">
                    Stream directly from web servers (faster startup, no downloads)
                </div>
                <div style="margin-top:0.25rem; color:#9ca3af; font-size:0.85rem;">
                    When enabled, movies/shows will stream from online servers instead of torrent files
                </div>
            </div>
        </div>

        <div class="settings-section" style="margin-top:1.25rem;">
            <h3>Cache & Storage</h3>
            <div style="margin-top:0.5rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                <div class="api-input-group">
                    <label for="cacheLocation">Cache Location:</label>
                    <div style="display:flex; gap:0.5rem; align-items:center;">
                        <input type="text" id="cacheLocation" class="api-input" readonly placeholder="System default temp folder" style="flex:1;" />
                        <button class="api-btn" id="selectCacheBtn" style="background:#0d6efd; color:#fff; white-space:nowrap;">
                            <i class="fas fa-folder-open"></i> Browse
                        </button>
                    </div>
                    <small style="color:var(--secondary); font-size:0.85rem; margin-top:0.25rem;">
                        <i class="fas fa-info-circle"></i> Location where WebTorrent streams and subtitles are cached
                    </small>
                </div>
            </div>
        </div>

        <div class="settings-section" id="debridSection" style="margin-top:1.25rem;">
            <h3>Debrid (Cloud Cache) </h3>
            <div style="margin-top:0.5rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05); display:flex; flex-direction: column; gap:0.75rem;">
                <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                    <input type="checkbox" id="useDebridToggle" />
                    <span>Use Debrid</span>
                </label>
                <div style="display:flex; gap:0.75rem; align-items:center; flex-wrap: wrap;">
                    <label for="debridProvider">Provider:</label>
                    <select id="debridProvider" class="api-input" style="min-width:220px; max-width:260px;">
                        <option value="realdebrid">RealDebrid</option>
                        <option value="alldebrid">AllDebrid</option>
                        <option value="torbox">TorBox</option>
                        <option value="premiumize">Premiumize</option>
                    </select>
                    <span id="debridStatus" style="font-size:0.9rem; opacity:0.85;">Not logged in</span>
                </div>
                <div class="api-input-group" id="rdClientIdGroup">
                    <label for="rdClientId">RealDebrid Client ID (device flow):</label>
                    <input type="text" id="rdClientId" class="api-input" placeholder="Enter your RD Client ID (e.g., XXXXXXXXXXXXX)" />
                </div>
                <div id="rdButtons" style="display:flex; gap:0.5rem; flex-wrap: wrap; align-items:center;">
                    <button class="api-btn" id="rdDeviceLogin" style="background:#198754; color:#fff;">
                        <i class="fas fa-sign-in-alt"></i> Login with RealDebrid
                    </button>
                    <small style="opacity:0.85;">No password needed. Authenticate on realdebrid.com using a short code.</small>
                </div>
                <div id="rdCodePanel" style="display:none; margin-top:0.5rem; padding:0.75rem; background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.1); border-radius:8px;">
                    <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                        <div>Code:</div>
                        <div id="rdUserCode" style="font-family:monospace; font-weight:800; background:rgba(255,255,255,0.1); padding:0.25rem 0.5rem; border-radius:6px;">----</div>
                        <button class="api-btn" id="rdCopyCode" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-copy"></i> Copy</button>
                    </div>
                    <div style="margin-top:0.5rem; display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                        <div>Verify at:</div>
                        <a id="rdVerifyUrl" href="#" target="_blank" style="color:#0d6efd; text-decoration:underline;">https://real-debrid.com/device</a>
                        <button class="api-btn" id="rdOpenVerify" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-external-link-alt"></i> Open</button>
                        <span id="rdLoginStatus" style="margin-left:auto; font-size:0.9rem; opacity:0.9;">Waiting for approval</span>
                        <button class="api-btn api-btn-secondary" id="rdCancelLogin"><i class="fas fa-times"></i> Cancel</button>
                    </div>
                </div>
                <div class="api-input-group" id="rdTokenGroup">
                    <label for="debridToken">RealDebrid Token (temporary MVP):</label>
                    <input type="password" id="debridToken" class="api-input" placeholder="Paste RD token..." />
                </div>
                <div id="rdTokenButtons" style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                    <button class="api-btn" id="saveDebridToken" style="background:#0d6efd; color:#fff;">
                        <i class="fas fa-key"></i> Save Token
                    </button>
                    <button class="api-btn api-btn-secondary" id="clearDebridToken">
                        <i class="fas fa-sign-out-alt"></i> Logout
                    </button>
                </div>
                <div style="margin-top:0.25rem; color:#ffc107; font-size:0.9rem;">Your token is stored locally and never exposed to websites.</div>

                <!-- AllDebrid PIN Login UI -->
                <div id="adSection" style="display:none; margin-top:1rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                    <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
                        <button class="api-btn" id="adStartPin" style="background:#198754; color:#fff;"><i class="fas fa-sign-in-alt"></i> Login with AllDebrid (PIN)</button>
                        <small style="opacity:0.85;">Authenticate on alldebrid.com/pin with the code shown.</small>
                    </div>
                    <div id="adPinPanel" style="display:none; margin-top:0.5rem; padding:0.75rem; background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.1); border-radius:8px;">
                        <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                            <div>PIN:</div>
                            <div id="adPinCode" style="font-family:monospace; font-weight:800; background:rgba(255,255,255,0.1); padding:0.25rem 0.5rem; border-radius:6px;">----</div>
                            <button class="api-btn" id="adCopyPin" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-copy"></i> Copy</button>
                        </div>
                        <div style="margin-top:0.5rem; display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                            <div>Open:</div>
                            <a id="adUserUrl" href="https://alldebrid.com/pin/" target="_blank" style="color:#0d6efd; text-decoration:underline;">https://alldebrid.com/pin/</a>
                            <button class="api-btn" id="adOpenUserUrl" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-external-link-alt"></i> Open</button>
                            <span id="adLoginStatus" style="margin-left:auto; font-size:0.9rem; opacity:0.9;">Waiting</span>
                            <button class="api-btn api-btn-secondary" id="adCancelPin"><i class="fas fa-times"></i> Cancel</button>
                        </div>
                    </div>
                    <div class="api-input-group" style="margin-top:0.75rem;">
                        <label for="adApiKey">AllDebrid API Key (optional/manual):</label>
                        <input type="password" id="adApiKey" class="api-input" placeholder="Paste AD API key..." />
                    </div>
                    <div style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                        <button class="api-btn" id="adSaveApiKey" style="background:#0d6efd; color:#fff;"><i class="fas fa-key"></i> Save API Key</button>
                        <button class="api-btn api-btn-secondary" id="adClearApiKey"><i class="fas fa-sign-out-alt"></i> Logout</button>
                    </div>
                </div>

                <!-- TorBox Auth (token) -->
                <div id="tbSection" style="display:none; margin-top:1rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                    <div class="api-input-group">
                        <label for="tbToken">TorBox Token (temporary):</label>
                        <input type="password" id="tbToken" class="api-input" placeholder="Paste TorBox token..." />
                    </div>
                    <div style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                        <button class="api-btn" id="tbSaveToken" style="background:#0d6efd; color:#fff;"><i class="fas fa-key"></i> Save Token</button>
                        <button class="api-btn api-btn-secondary" id="tbClearToken"><i class="fas fa-sign-out-alt"></i> Logout</button>
                    </div>
                    <div style="margin-top:0.25rem; color:#ffc107; font-size:0.9rem;">Token stored locally.</div>
                </div>

                <!-- Premiumize Auth (API Key) -->
                <div id="pmSection" style="display:none; margin-top:1rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                    <div class="api-input-group">
                        <label for="pmApiKey">Premiumize API Key:</label>
                        <input type="password" id="pmApiKey" class="api-input" placeholder="Enter your Premiumize API key..." />
                    </div>
                    <div style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                        <button class="api-btn" id="pmSaveApiKey" style="background:#0d6efd; color:#fff;"><i class="fas fa-key"></i> Save API Key</button>
                        <button class="api-btn api-btn-secondary" id="pmClearApiKey"><i class="fas fa-sign-out-alt"></i> Logout</button>
                    </div>
                    <div style="margin-top:0.25rem; color:#ffc107; font-size:0.9rem;">
                        Get your API key from <a href="https://www.premiumize.me/account" target="_blank" style="color:#0d6efd; text-decoration:underline;">premiumize.me/account</a>
                    </div>
                </div>
            </div>
        </div>

        <div class="settings-section" style="margin-top:1.25rem;">
            <h3>User Interface</h3>
            <div style="margin-top:0.5rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                <!-- Fullscreen toggle (first option) -->
                <div style="margin-bottom:1rem; padding-bottom:0.75rem; border-bottom:1px solid rgba(255,255,255,0.1);">
                    <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                        <input type="checkbox" id="fullscreenToggle" />
                        <span><i class="fas fa-expand-arrows-alt" style="margin-right:0.25rem; color:var(--vlc-orange);"></i><strong>Fullscreen Mode</strong></span>
                    </label>
                    <div style="margin-top:0.25rem; color:var(--secondary); font-size:0.85rem; margin-left:1.85rem;">
                        <i class="fas fa-info-circle"></i> Toggle between fullscreen and windowed mode
                    </div>
                </div>
                
                <div style="display:flex; flex-direction:column; gap:0.75rem;">
                    <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                        <input type="radio" name="uiMode" value="new" id="uiModeNew" checked />
                        <span><strong>NEW UI</strong> - Modern app-like interface</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                        <input type="radio" name="uiMode" value="old" id="uiModeOld" />
                        <span><strong>OLD UI</strong> - Classic website layout</span>
                    </label>
                </div>
                <div style="margin-top:0.5rem; color:var(--secondary); font-size:0.9rem;">
                    <i class="fas fa-info-circle"></i> Changes will apply immediately after saving
                </div>
                
                <!-- Theme Selector -->
                <div style="margin-top:1.5rem; padding-top:1rem; border-top:1px solid rgba(255,255,255,0.1);">
                    <label style="display:block; margin-bottom:0.75rem; color:var(--light); font-weight:600; font-size:1rem;">
                        <i class="fas fa-palette" style="margin-right:0.5rem; color:var(--vlc-orange);"></i>
                        Color Theme
                    </label>
                    <select id="themeSelector" class="api-input" style="width:100%; max-width:350px; padding:0.75rem 1rem; background: rgba(255,255,255,0.08); border: 2px solid rgba(255,255,255,0.2); border-radius:10px; color:var(--light); font-size:0.95rem; font-weight:500; cursor:pointer; transition: all 0.3s ease; appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27rgba(255,255,255,0.6)%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.75rem center; background-size: 1.25rem; padding-right: 2.5rem;">
                        <option value="default">Default (Purple Dream)</option>
                        <option value="green-forest">Green Forest</option>
                        <option value="cyberpunk-neon">Cyberpunk Neon</option>
                        <option value="ocean-breeze">Ocean Breeze</option>
                        <option value="cherry-blossom">Cherry Blossom</option>
                        <option value="midnight-dark">Midnight Dark</option>
                        <option value="sunset-orange">Sunset Orange</option>
                    </select>
                    <div style="margin-top:0.5rem; color:var(--secondary); font-size:0.85rem;">
                        <i class="fas fa-info-circle"></i> Choose your preferred color scheme
                    </div>
                </div>
            </div>
        </div>

        <!-- Nuvio Febbox Token Section -->
        <div class="settings-section" style="margin-top:1.25rem;">
            <h3>
                <i class="fas fa-stream" style="color: #667eea; margin-right: 0.5rem;"></i>
                Nuvio Configuration
            </h3>
            <div style="padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                <div style="margin-bottom: 1rem; color: var(--secondary); font-size: 0.9rem;">
                    <i class="fas fa-info-circle"></i>
                    Configure your Febbox token for Nuvio streaming (ShowBox). A default token is provided, but you can use your own.
                </div>
                
                <label for="febboxTokenInput" style="display: block; margin-bottom: 0.5rem; font-weight: 500;">
                    Febbox JWT Token (Optional)
                </label>
                <input 
                    type="text" 
                    id="febboxTokenInput" 
                    placeholder="Leave empty to use default token or paste your Febbox JWT token here"
                    style="width: 100%; padding: 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: var(--light); font-size: 0.95rem; font-family: monospace; margin-bottom: 1rem;"
                />
                
                <button id="saveFebboxToken" class="btn" style="width: 100%;">
                    <i class="fas fa-save"></i> Save Token
                </button>
                
                <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(103, 126, 234, 0.1); border-left: 3px solid var(--secondary); border-radius: 4px; font-size: 0.85rem;">
                    <i class="fas fa-check-circle" style="color: var(--secondary);"></i> Default token is active. You can continue using Nuvio without adding your own token.
                </div>
            </div>
        </div>

        <!-- Trakt Integration Section -->
        <div class="settings-section" style="margin-top:1.25rem;">
            <h3>
                <i class="fas fa-tv" style="color: #ed1c24; margin-right: 0.5rem;"></i>
                Trakt Integration
            </h3>
            <div style="padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                <div style="margin-bottom: 1rem; color: var(--secondary); font-size: 0.9rem;">
                    <i class="fas fa-info-circle"></i>
                    Sync your watch history, progress, and manage your watchlist with Trakt.tv
                </div>
                
                <div id="traktNotConnected" style="display: block;">
                    <div style="margin-bottom: 1rem;">
                        <span id="traktStatus" style="color: #dc3545; font-weight: 500;">
                            <i class="fas fa-times-circle"></i> Not connected
                        </span>
                    </div>
                    <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                        <button class="api-btn" id="traktLogin" style="background: #ed1c24; color: #fff;">
                            <i class="fas fa-sign-in-alt"></i> Connect to Trakt
                        </button>
                        <small style="opacity: 0.85;">Authenticate with your Trakt.tv account using a secure device code</small>
                    </div>
                </div>

                <div id="traktConnected" style="display: none;">
                    <div style="margin-bottom: 1rem;">
                        <span id="traktConnectedStatus" style="color: #198754; font-weight: 500;">
                            <i class="fas fa-check-circle"></i> Connected as <span id="traktUsername">User</span>
                        </span>
                    </div>
                    <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; margin-bottom: 1rem;">
                        <button class="api-btn" id="traktViewWatchlist" style="background: #0d6efd; color: #fff;">
                            <i class="fas fa-list"></i> View Watchlist
                        </button>
                        <button class="api-btn" id="traktViewHistory" style="background: #6f42c1; color: #fff;">
                            <i class="fas fa-history"></i> View History
                        </button>
                        <button class="api-btn" id="traktViewStats" style="background: #17a2b8; color: #fff;">
                            <i class="fas fa-chart-bar"></i> View Stats
                        </button>
                    </div>
                    <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                        <button class="api-btn api-btn-secondary" id="traktDisconnect">
                            <i class="fas fa-sign-out-alt"></i> Disconnect
                        </button>
                    </div>
                </div>

                <!-- Trakt Device Code Panel -->
                <div id="traktCodePanel" style="display: none; margin-top: 1rem; padding: 0.75rem; background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                    <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
                        <div>Device Code:</div>
                        <div id="traktUserCode" style="font-family: monospace; font-weight: 800; background: rgba(255,255,255,0.1); padding: 0.25rem 0.5rem; border-radius: 6px;">----</div>
                        <button class="api-btn" id="traktCopyCode" style="padding: 0.4rem 0.6rem; background: #0d6efd; color: #fff;">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                        <div>Authorize at:</div>
                        <a id="traktVerifyUrl" href="#" target="_blank" style="color: #0d6efd; text-decoration: underline;">https://trakt.tv/activate</a>
                        <button class="api-btn" id="traktOpenVerify" style="padding: 0.4rem 0.6rem; background: #0d6efd; color: #fff;">
                            <i class="fas fa-external-link-alt"></i> Open
                        </button>
                        <span id="traktLoginStatus" style="margin-left: auto; font-size: 0.9rem; opacity: 0.9;">Waiting for authorization</span>
                        <button class="api-btn api-btn-secondary" id="traktCancelLogin">
                            <i class="fas fa-times"></i> Cancel
                        </button>
                    </div>
                </div>

                <!-- Trakt Settings -->
                <div id="traktSettings" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                    <h4 style="margin-bottom: 0.75rem; color: var(--text-primary);">Scrobbling Settings</h4>
                    <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                        <label style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer;">
                            <input type="checkbox" id="traktAutoScrobble" checked />
                            <span>Automatically track what I watch</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer;">
                            <input type="checkbox" id="traktScrobbleProgress" checked />
                            <span>Sync watch progress</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer;">
                            <input type="checkbox" id="traktSyncWatchlist" checked />
                            <span>Show Trakt watchlist items in search</span>
                        </label>
                    </div>
                    <div style="margin-top: 0.5rem; color: var(--secondary); font-size: 0.85rem;">
                        <i class="fas fa-info-circle"></i> Your viewing activity will be automatically synchronized with Trakt.tv
                    </div>
                </div>
            </div>
        </div>
        
        <div class="settings-buttons">
            <button class="api-btn api-btn-secondary" id="cancelSettings">
                <i class="fas fa-times"></i>
                Cancel
            </button>
            <button class="api-btn api-btn-primary" id="saveSettings">
                <i class="fas fa-save"></i>
                Save Changes
            </button>
        </div>
    </div>
</div>

<!-- Floating Navigation Arrow (Old UI Only, Home Page Only) -->
<div class="floating-nav-container" id="floatingNavContainer">
    <button class="floating-nav-btn" id="floatingNavBtn">
        <i class="fas fa-chevron-up" id="floatingNavIcon"></i>
    </button>
    <div class="floating-nav-menu" id="floatingNavMenu">
        <div class="floating-nav-item" data-action="settings">
            <i class="fas fa-cog"></i>
            <span>Settings</span>
        </div>
        <div class="floating-nav-item" data-action="home">
            <i class="fas fa-home"></i>
            <span>Home</span>
        </div>
        <div class="floating-nav-item" data-action="genres">
            <i class="fas fa-layer-group"></i>
            <span>Genres</span>
        </div>
        <div class="floating-nav-item" data-action="my-list">
            <i class="fas fa-list"></i>
            <span>My List</span>
        </div>
        <div class="floating-nav-item" data-action="done-watching">
            <i class="fas fa-check-double"></i>
            <span>Done Watching</span>
        </div>
        <div class="floating-nav-item" data-action="trakt">
            <i class="fas fa-tv"></i>
            <span>Trakt</span>
        </div>
        <div class="floating-nav-item" data-action="livetv">
            <i class="fas fa-broadcast-tower"></i>
            <span>Live TV</span>
        </div>
        <div class="floating-nav-item" data-action="iptv">
            <i class="fas fa-tv"></i>
            <span>IPTV</span>
        </div>
        <div class="floating-nav-item" data-action="books">
            <i class="fas fa-book"></i>
            <span>Books</span>
        </div>
        <div class="floating-nav-item" data-action="booktorrio">
            <i class="fas fa-book-open"></i>
            <span>BookTorrio</span>
        </div>
        <div class="floating-nav-item" data-action="anime">
            <i class="fas fa-dragon"></i>
            <span>Anime</span>
        </div>
        <div class="floating-nav-item" data-action="manga">
            <i class="fas fa-book-dead"></i>
            <span>Manga</span>
        </div>
        <div class="floating-nav-item" data-action="music">
            <i class="fas fa-music"></i>
            <span>Music</span>
        </div>
        <div class="floating-nav-item" data-action="games-downloader">
            <i class="fas fa-download"></i>
            <span>Games Downloader</span>
        </div>
        <div class="floating-nav-item" data-action="minigames">
            <i class="fas fa-gamepad"></i>
            <span>MiniGames</span>
        </div>
        <div class="floating-nav-item" data-action="downloader">
            <i class="fas fa-download"></i>
            <span>Media Downloader</span>
        </div>
        <div class="floating-nav-item" data-action="trakt">
            <i class="fab fa-trakt"></i>
            <span>Trakt</span>
        </div>
    </div>
</div>

<!-- MPV Install Helper Modal removed -->

<!-- App Container for New UI -->
<div class="app-container">
    <!-- Sidebar Navigation (New UI Only) -->
    <aside class="app-sidebar">
        <div class="sidebar-logo" id="sidebarLogo" style="cursor: pointer;">
            <i class="fas fa-play-circle"></i>
            <div><span style="color: var(--vlc-orange);">Play</span>Torrio</div>
        </div>
        
        <div class="sidebar-divider"></div>
        
        <nav class="sidebar-nav">
            <div class="nav-section-title">DISCOVER</div>
            <div class="nav-item active" data-page="home">
                <i class="fas fa-home"></i>
                <span>Home</span>
                <span class="nav-badge">New</span>
            </div>
            <div class="nav-item" data-page="genres">
                <i class="fas fa-layer-group"></i>
                <span>Genres</span>
            </div>
            <div class="nav-item" data-page="my-list">
                <i class="fas fa-heart"></i>
                <span>My List</span>
            </div>
            <div class="nav-item" data-page="done-watching">
                <i class="fas fa-check-circle"></i>
                <span>Done Watching</span>
            </div>
            
            <div class="nav-section-title">LIBRARY</div>
            <div class="nav-item" data-page="trakt">
                <i class="fas fa-tv" style="color: #ed1c24;"></i>
                <span>Trakt</span>
                <span class="nav-badge" style="background: #ed1c24;">Sync</span>
            </div>
            <div class="nav-item" data-page="livetv">
                <i class="fas fa-broadcast-tower" style="color: #10b981;"></i>
                <span>Live TV</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #10b981, #059669);">Live</span>
            </div>
            <div class="nav-item" data-page="iptv">
                <i class="fas fa-tv" style="color: #3b82f6;"></i>
                <span>IPTV</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #3b82f6, #2563eb);">M3U8</span>
            </div>
            <div class="nav-item" data-page="books">
                <i class="fas fa-book" style="color: #f59e0b;"></i>
                <span>Books</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #f59e0b, #d97706);">Z-Lib</span>
            </div>
            <div class="nav-item" data-page="booktorrio">
                <i class="fas fa-book-open" style="color: #06b6d4;"></i>
                <span>BookTorrio</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #06b6d4, #0891b2);">EPUB</span>
            </div>
            <div class="nav-item" data-page="anime">
                <i class="fas fa-dragon" style="color: #3b82f6;"></i>
                <span>Anime</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #3b82f6, #2563eb);">Nyaa</span>
            </div>
            <div class="nav-item" data-page="manga">
                <i class="fas fa-book-reader" style="color: #ec4899;"></i>
                <span>Manga</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #ec4899, #db2777);">MangaDex</span>
            </div>
            <div class="nav-item" data-page="music">
                <i class="fas fa-music" style="color: #ec4899;"></i>
                <span>Music</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #ec4899, #db2777);">HiFi</span>
            </div>
            <div class="nav-item" data-page="games-downloader">
                <i class="fas fa-download" style="color: #8b5cf6;"></i>
                <span>Games Downloader</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #8b5cf6, #7c3aed);">PC</span>
            </div>
            <div class="nav-item" data-page="minigames">
                <i class="fas fa-gamepad" style="color: #10b981;"></i>
                <span>MiniGames</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #10b981, #059669);">Play</span>
            </div>
            <div class="nav-item" data-page="downloader">
                <i class="fas fa-download" style="color: #a855f7;"></i>
                <span>Media Downloader</span>
            </div>
            <div class="nav-item" id="sidebarClearCache">
                <i class="fas fa-trash"></i>
                <span>Clear Cache</span>
            </div>
        </nav>
        
        <!-- Quick Actions -->
        <div class="sidebar-quick-actions">
            <div class="quick-action-title">QUICK ACTIONS</div>
            <button class="quick-action-btn" id="quickRefresh">
                <i class="fas fa-sync-alt"></i>
                <span>Refresh</span>
            </button>
        </div>
        
        <div class="sidebar-footer">
            <div class="sidebar-user-info">
                <i class="fas fa-user-circle"></i>
                <span id="windowsUsername">Local User</span>
            </div>
            <button class="btn btn-primary" id="sidebarSettings" style="width: 100%; margin-top: 0.5rem;">
                <i class="fas fa-cog"></i> Settings
            </button>
        </div>
    </aside>
    
    <!-- Main App Content -->
    <div class="app-main">
        <!-- Header -->
        <header>
        <div class="header-container">
        <a class="logo" href="http://localhost:3000">
        <i class="fas fa-play-circle"></i>
        <span>Play</span> Torrio
                    </a>
        <div class="search-container">
        <i class="fas fa-search search-icon"></i>
        <input id="searchInput" placeholder="Search for movies, shows, anime..." type="text"/>
        </div>
        <div class="user-actions">
        <!-- Connection Status (NEW UI only) -->
        <div class="connection-status">
            <i class="fas fa-circle"></i>
            <span>Connected</span>
        </div>
        <button class="btn btn-outline" id="doneWatchingBtn">
        <i class="fas fa-check-circle"></i> Done Watching
                        </button>
        <button class="btn btn-outline" id="clearCacheBtn">
        <i class="fas fa-trash"></i> Clear Cache
                        </button>
    <!-- Donate button removed -->
        <button class="btn btn-outline" id="discordBtn" title="Join Discord Community">
        <i class="fab fa-discord"></i> Discord
                        </button>
        <button class="btn btn-outline" id="genresBtn">
        <i class="fas fa-layer-group"></i> Genres
                        </button>
        <button class="btn btn-outline" id="myListBtn">
        <i class="fas fa-heart"></i> My List
                        </button>
        <button class="btn btn-primary" id="donateBtn" title="Support development" style="margin-left: 1rem;">
        <i class="fas fa-heart"></i> Donate
                        </button>
        <!-- Install MPV button removed -->
        </div>
        </div>
        </header>

<!-- Main Content -->
<main>
    <!-- Home Page -->
    <div id="homePage">
        <!-- Enhanced Title Bar with Stats -->
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title" id="homePageTitle">
                    <i class="fas fa-fire" id="homePageIcon"></i> <span id="homePageText">Trending Now</span>
                </h2>
                <p class="page-subtitle">Discover the most popular content this week</p>
            </div>
            <div class="page-actions">
                <button class="action-btn" id="sortBtn">
                    <i class="fas fa-sort-amount-down"></i>
                    <span>Sort</span>
                </button>
                <button class="action-btn" id="filterBtn">
                    <i class="fas fa-filter"></i>
                    <span>Filter</span>
                </button>
            </div>
        </div>
        
        <div class="categories">
            <div class="category active" data-category="all">
                <i class="fas fa-th"></i> All
            </div>
            <div class="category" data-category="movie">
                <i class="fas fa-film"></i> Movies
            </div>
            <div class="category" data-category="tv">
                <i class="fas fa-tv"></i> TV Shows
            </div>
        </div>
        <div class="movies-grid" id="moviesGrid" style="content-visibility:auto; contain-intrinsic-size: 1000px 1000px;">
            <!-- Movie cards will be loaded here -->
        </div>
        <div class="loading" id="loadingIndicator">
            <i class="fas fa-spinner"></i> Loading more content...
        </div>
    </div>

    <!-- Music Page -->
    <div id="music-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-music" style="color: #ec4899;"></i> <span>Music</span>
                </h2>
                <p class="page-subtitle">Search and stream high-quality music</p>
            </div>
            <div class="page-actions">
                <button class="action-btn" id="music-my-btn" title="Open My Music">
                    <i class="fas fa-heart"></i>
                    <span>My Music</span>
                </button>
                <button class="action-btn" id="music-my-albums-btn" title="Open My Albums">
                    <i class="fas fa-compact-disc"></i>
                    <span>My Albums</span>
                </button>
                <button class="action-btn" id="music-playlists-btn" title="Open Playlists">
                    <i class="fas fa-list"></i>
                    <span>Playlists</span>
                </button>
                <button class="action-btn" id="music-downloaded-btn" title="Open Downloaded Music">
                    <i class="fas fa-download"></i>
                    <span>Downloaded</span>
                </button>
                
            </div>
        </div>

        <div class="page-content">
            <!-- Search Section -->
            <div class="books-search-section">
                <div class="books-search-container">
                    <div class="books-search-bar">
                        <i class="fas fa-search books-search-icon"></i>
                        <input 
                            type="text" 
                            id="music-search-input" 
                            placeholder="Search for songs, artists, or albums..."
                            autocomplete="off"
                        />
                        <button id="music-search-btn" class="books-search-button">
                            <i class="fas fa-search"></i>
                            Search
                        </button>
                        <button id="music-album-search-btn" class="books-search-button" style="margin-left:0.5rem; background: linear-gradient(135deg, #38bdf8, #0ea5e9);">
                            <i class="fas fa-compact-disc"></i>
                            Albums
                        </button>
                    </div>
                </div>
            </div>

            <!-- Loading State -->
            <div id="music-loading" class="books-loading" style="display: none;">
                <div class="books-loading-spinner">
                    <i class="fas fa-spinner fa-spin"></i>
                </div>
                <p>Searching HiFi...</p>
            </div>

            <!-- Empty State -->
            <div id="music-empty" class="books-empty">
                <div class="books-empty-icon">
                    <i class="fas fa-music"></i>
                </div>
                <h3>Welcome to HiFi Music</h3>
                <p>Search for any song, artist, or album to get started.</p>
            </div>

            <!-- Results Section -->
            <div id="music-results" class="books-results" style="display: none;">
                <div class="books-results-header">
                    <h3 id="music-results-title">Search Results</h3>
                    <div id="music-results-count" class="books-results-count"></div>
                </div>
                <div id="music-results-grid" class="books-results-grid">
                    <!-- Results will be populated here -->
                </div>
            </div>

            <!-- Albums Results Section -->
            <div id="music-albums" class="books-results" style="display:none;">
                <div class="books-results-header">
                    <h3 id="music-albums-title"><i class="fas fa-compact-disc" style="color:#38bdf8"></i> Album Results</h3>
                    <div id="music-albums-count" class="books-results-count"></div>
                </div>
                <div id="music-albums-grid" class="books-results-grid"></div>
            </div>

            <!-- Album View (open a specific album) -->
            <div id="music-album-view" class="books-results" style="display:none;">
                <div class="books-results-header" style="align-items:center; gap:1rem; flex-wrap:wrap;">
                    <div style="display:flex; align-items:center; gap:0.75rem;">
                        <img id="album-view-cover" src="" alt="Album Cover" style="width:68px; height:68px; border-radius:10px; object-fit:cover; border:1px solid rgba(255,255,255,0.1);">
                        <div>
                            <h3 id="album-view-title" style="margin:0; display:flex; align-items:center; gap:0.5rem;"></h3>
                            <div id="album-view-meta" style="color:#9ca3af; font-size:0.9rem;"></div>
                        </div>
                    </div>
                    <button id="album-play-all-btn" class="action-btn" style="background: linear-gradient(135deg, #ec4899, #a855f7);">
                        <i class="fas fa-play"></i>
                        <span>Play All</span>
                    </button>
                    <button id="album-close-btn" class="playlist-close-btn" style="margin-left:auto;">
                        <i class="fas fa-times"></i>
                        <span>Close Album</span>
                    </button>
                </div>
                <div id="album-tracks" class="album-tracks-list" style="display:flex; flex-direction:column; gap:0.5rem;"></div>
            </div>

            <!-- My Albums Section -->
            <div id="my-albums" class="books-results" style="display:none;">
                <div class="books-results-header">
                    <h3><i class="fas fa-compact-disc" style="color:#38bdf8"></i> My Albums</h3>
                    <div id="my-albums-count" class="books-results-count"></div>
                </div>
                <div id="my-albums-grid" class="books-results-grid"></div>
                <div id="my-albums-empty" class="books-empty" style="display:none;">
                    <div class="books-empty-icon"><i class="fas fa-compact-disc"></i></div>
                    <h3>No saved albums yet</h3>
                    <p>Click the heart on any album to add it here.</p>
                </div>
            </div>

            <!-- My Music Section -->
            <div id="my-music" class="books-results" style="display: none;">
                <div class="books-results-header" style="align-items:center; gap:1rem;">
                    <h3><i class="fas fa-heart" style="color:#ec4899"></i> My Music</h3>
                    <div id="my-music-count" class="books-results-count"></div>
                    <button id="my-music-play-all-btn" class="action-btn" style="margin-left:auto; background: linear-gradient(135deg, #ec4899, #a855f7);">
                        <i class="fas fa-play"></i>
                        <span>Play All</span>
                    </button>
                </div>
                <div id="my-music-grid" class="books-results-grid"></div>
                <div id="my-music-empty" class="books-empty" style="display:none;">
                    <div class="books-empty-icon"><i class="fas fa-heart"></i></div>
                    <h3>No saved tracks yet</h3>
                    <p>Click the heart on any track to add it here for quick access.</p>
                </div>
            </div>

            <!-- Playlists Section -->
            <div id="music-playlists" class="books-results" style="display: none;">
                <div class="books-results-header" style="gap: 1rem; align-items: center;">
                    <h3><i class="fas fa-list" style="color:#38bdf8"></i> Playlists</h3>
                    <div style="flex:1"></div>
                    <input id="playlist-name-input" placeholder="New playlist name" style="padding:0.5rem 0.75rem; border-radius:8px; background:var(--surface); border:1px solid var(--border); color:var(--light); width:220px;" />
                    <button class="action-btn" id="playlist-create-btn"><i class="fas fa-plus"></i><span>Create</span></button>
                </div>
                <div id="playlists-list" class="books-results-grid"></div>
                <div id="playlists-empty" class="books-empty" style="display:none;">
                    <div class="books-empty-icon"><i class="fas fa-list"></i></div>
                    <h3>No playlists yet</h3>
                    <p>Create a playlist to get started.</p>
                </div>
            </div>

            <!-- Downloaded Music Section -->
            <div id="music-downloaded" class="books-results" style="display: none;">
                <div class="books-results-header" style="align-items:center; gap:1rem;">
                    <h3><i class="fas fa-download" style="color:#10b981"></i> Downloaded Music</h3>
                    <div id="music-downloaded-count" class="books-results-count"></div>

                </div>
                <div id="music-downloaded-grid" class="books-results-grid"></div>
                <div id="music-downloaded-empty" class="books-empty" style="display:none;">
                    <div class="books-empty-icon"><i class="fas fa-download"></i></div>
                    <h3>No downloaded tracks yet</h3>
                    <p>Download tracks to listen offline.</p>
                </div>
            </div>

            
        </div>
    </div>

    <!-- Download Progress Modal -->
    <div id="music-download-modal" class="books-reader-modal" style="display:none; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); align-items: center; justify-content: center; padding: 0.75rem;">
        <div class="books-reader-content" style="max-width:300px; width:90%; margin: 0 auto; border:2px solid rgba(16,185,129,0.4); border-radius:12px; overflow:hidden; box-shadow: 0 12px 36px rgba(0,0,0,0.55);">
            <div style="background: linear-gradient(135deg, rgba(16,185,129,0.15), rgba(5,150,105,0.15)); border-bottom: 1px solid rgba(16,185,129,0.2); padding: 0.6rem 0.85rem; display: flex; align-items: center; justify-content: space-between;">
                <div style="display:flex; align-items:center; gap:0.4rem;">
                    <i class="fas fa-download" style="color:#10b981; font-size:0.85rem;"></i>
                    <span style="font-size:0.85rem; font-weight:600; color:var(--light);">Downloading</span>
                </div>
                <div style="display:flex; gap:0.25rem;">
                    <button id="music-download-minimize-btn" style="background:none; border:none; color:#38bdf8; cursor:pointer; padding:0.2rem 0.4rem; font-size:0.85rem; border-radius:4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(56,189,248,0.1)'" onmouseout="this.style.background='none'" title="Minimize">
                        <i class="fas fa-minus"></i>
                    </button>
                    <button id="music-download-cancel-btn" style="background:none; border:none; color:#ef4444; cursor:pointer; padding:0.2rem 0.4rem; font-size:0.85rem; border-radius:4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(239,68,68,0.1)'" onmouseout="this.style.background='none'" title="Cancel">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            <div style="padding:0.85rem;">
                <div id="music-download-info" style="margin-bottom:0.6rem;">
                    <div id="music-download-song-name" style="font-weight:600; color:var(--light); margin-bottom:0.1rem; font-size:0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
                    <div id="music-download-artist-name" style="color:#10b981; font-size:0.75rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
                </div>
                <div style="width:100%; height:5px; background: rgba(16,185,129,0.15); border-radius:2.5px; overflow:hidden; border: 1px solid rgba(16,185,129,0.2);">
                    <div id="music-download-progress-fill" style="height:100%; width:0%; background: linear-gradient(90deg, #10b981, #059669, #10b981); background-size: 200% 100%; animation: shimmer 2s infinite; transition: width 0.4s ease;"></div>
                </div>
                <div id="music-download-status" style="margin-top:0.4rem; text-align:center; color:var(--secondary); font-size:0.75rem;"></div>
            </div>
        </div>
    </div>

    <!-- Minimized Download Progress (in notification area) -->
    <div id="music-download-minimized" style="display:none; position:fixed; bottom:20px; right:20px; background:rgba(26,26,46,0.95); border:2px solid rgba(16,185,129,0.4); border-radius:10px; padding:0.75rem 1rem; min-width:280px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); z-index:9999;">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:0.5rem;">
            <div style="display:flex; align-items:center; gap:0.5rem;">
                <i class="fas fa-download" style="color:#10b981; font-size:0.9rem;"></i>
                <span style="font-size:0.85rem; font-weight:600; color:var(--light);">Downloading...</span>
            </div>
            <div style="display:flex; gap:0.25rem;">
                <button id="music-download-restore-btn" style="background:none; border:none; color:#38bdf8; cursor:pointer; padding:0.2rem 0.4rem; font-size:0.85rem; border-radius:4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(56,189,248,0.1)'" onmouseout="this.style.background='none'" title="Restore">
                    <i class="fas fa-window-maximize"></i>
                </button>
                <button id="music-download-cancel-minimized-btn" style="background:none; border:none; color:#ef4444; cursor:pointer; padding:0.2rem 0.4rem; font-size:0.85rem; border-radius:4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(239,68,68,0.1)'" onmouseout="this.style.background='none'" title="Cancel">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>
        <div id="music-download-minimized-info" style="margin-bottom:0.5rem;">
            <div id="music-download-minimized-song" style="font-weight:600; color:var(--light); font-size:0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
            <div id="music-download-minimized-artist" style="color:#10b981; font-size:0.75rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
        </div>
        <div style="width:100%; height:5px; background: rgba(16,185,129,0.15); border-radius:2.5px; overflow:hidden; border: 1px solid rgba(16,185,129,0.2);">
            <div id="music-download-minimized-progress" style="height:100%; width:0%; background: linear-gradient(90deg, #10b981, #059669, #10b981); background-size: 200% 100%; animation: shimmer 2s infinite; transition: width 0.4s ease;"></div>
        </div>
        <div id="music-download-minimized-status" style="margin-top:0.4rem; text-align:center; color:var(--secondary); font-size:0.75rem;"></div>
    </div>

    <!-- Music Player Modal (transparent overlay + custom controls) -->
    <div id="music-player-modal" class="books-reader-modal" style="display: none; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px);">
        <div class="books-reader-content" style="border:2px solid #ec4899; border-radius: 16px; max-width:560px; width:90%;">
            <div class="books-reader-header">
                <button id="music-player-back" class="books-reader-back-btn">
                    <i class="fas fa-arrow-left"></i>
                    Back
                </button>
                <h3 id="music-player-title">Now Playing</h3>
                <button id="music-player-minimize" class="books-reader-back-btn" style="margin-left: auto; margin-right: 0;">
                    <i class="fas fa-minus"></i>
                    Minimize
                </button>
            </div>
            <div class="books-reader-frame-container" style="display:flex; flex-direction:column; align-items:center; justify-content:center; padding: 1.75rem; background: linear-gradient(135deg, rgba(26,26,46,0.95), rgba(22,33,62,0.95));">
                <img id="music-player-cover" src="" alt="Album Cover" style="width: 240px; height: 240px; object-fit: cover; border-radius: 12px; margin-bottom: 1rem; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);">
                <h2 id="music-player-song-title" style="color: var(--light); margin-bottom: 0.25rem; text-align: center; font-size:1.3rem;"></h2>
                <p id="music-player-artist" style="color: #ec4899; font-size: 1rem; margin-bottom: 1rem; text-align: center;"></p>
                
                <!-- Custom Controls -->
                <div style="width:100%; max-width:520px;">
                    <div class="audio-progress-bar" id="music-progress-bar" style="width:100%; height:6px; background: rgba(255,255,255,0.12); border-radius:3px; cursor:pointer; overflow:hidden;">
                        <div class="audio-progress-fill" id="music-progress-fill" style="height:100%; width:0%; background: linear-gradient(90deg, #ec4899, #a855f7);"></div>
                    </div>
                    <div class="audio-time-display" style="display:flex; justify-content:space-between; color:#9ca3af; font-size:0.85rem; margin-top:0.5rem;">
                        <span id="music-current-time">0:00</span>
                        <span id="music-total-time">0:00</span>
                    </div>
                    <div class="audio-controls-buttons" style="display:flex; justify-content:center; align-items:center; gap:1rem; margin-top:1rem; flex-wrap:wrap;">
                        <button class="audio-control-btn" id="music-prev-track-btn" title="Previous track" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:42px; height:42px; display:flex; align-items:center; justify-content:center;"><i class="fas fa-step-backward"></i></button>
                        <button class="audio-control-btn" id="music-backward-btn" title="Back 10s" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:46px; height:46px; display:flex; align-items:center; justify-content:center;"><i class="fas fa-backward"></i></button>
                        <button class="audio-control-btn" id="music-play-pause-btn" title="Play/Pause" style="background: linear-gradient(135deg, #ec4899, #a855f7); color:white; border:none; border-radius:50%; width:56px; height:56px; display:flex; align-items:center; justify-content:center; font-size:1.1rem;"><i class="fas fa-play"></i></button>
                        <button class="audio-control-btn" id="music-forward-btn" title="Forward 10s" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:46px; height:46px; display:flex; align-items:center; justify-content:center;"><i class="fas fa-forward"></i></button>
                        <button class="audio-control-btn" id="music-next-track-btn" title="Next track" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:42px; height:42px; display:flex; align-items:center; justify-content:center;"><i class="fas fa-step-forward"></i></button>
                    </div>
                    <div style="display:flex; justify-content:center; align-items:center; margin-top:0.5rem;">
                        <button id="music-autoplay-toggle" title="Autoplay next track" style="display:inline-flex; align-items:center; gap:0.4rem; padding:0.35rem 0.7rem; border-radius:999px; background: rgba(236,72,153,0.08); border:1px solid rgba(236,72,153,0.35); color:#ec4899; font-weight:600;">
                            <i class="fas fa-play-circle"></i>
                            <span>Autoplay Next</span>
                        </button>
                    </div>
                    <div class="audio-volume-control" style="display:flex; align-items:center; gap:0.75rem; margin-top:1rem;">
                        <i class="fas fa-volume-up" id="music-volume-icon" style="color:#ec4899;"></i>
                        <div class="audio-volume-slider" id="music-volume-slider" style="flex:1; height:4px; background: rgba(255,255,255,0.12); border-radius:2px; cursor:pointer;">
                            <div class="audio-volume-fill" id="music-volume-fill" style="height:100%; width:100%; background:#ec4899;"></div>
                        </div>
                    </div>
                </div>

                <audio id="music-player-audio" style="display:none;" crossorigin="anonymous" preload="metadata"></audio>
            </div>
        </div>
    </div>

    <!-- Mini Music Player (Notification Style) -->
    <div id="music-mini-player" style="display: none; position: fixed; bottom: 1.5rem; right: 1.5rem; z-index: 10000; background: linear-gradient(135deg, rgba(26,26,46,0.98), rgba(22,33,62,0.98)); border: 2px solid #ec4899; border-radius: 12px; padding: 1rem; box-shadow: 0 10px 40px rgba(0,0,0,0.6); backdrop-filter: blur(10px); width: 340px;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">
            <h4 id="mini-player-song-title" style="color: var(--light); margin: 0; font-size: 0.95rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1;"></h4>
            <button id="music-player-maximize" style="background: rgba(236,72,153,0.1); border: 1px solid rgba(236,72,153,0.3); color: #ec4899; border-radius: 6px; padding: 0.4rem 0.6rem; cursor: pointer; margin-left: 0.5rem;">
                <i class="fas fa-expand"></i>
            </button>
        </div>
        <p id="mini-player-artist" style="color: #ec4899; font-size: 0.85rem; margin: 0 0 0.75rem 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></p>
        
        <!-- Mini Progress Bar -->
        <div class="audio-progress-bar" id="mini-progress-bar" style="width:100%; height:4px; background: rgba(255,255,255,0.12); border-radius:2px; cursor:pointer; overflow:hidden; margin-bottom: 0.5rem;">
            <div class="audio-progress-fill" id="mini-progress-fill" style="height:100%; width:0%; background: linear-gradient(90deg, #ec4899, #a855f7);"></div>
        </div>
        
        <!-- Mini Time Display -->
        <div style="display:flex; justify-content:space-between; color:#9ca3af; font-size:0.75rem; margin-bottom:0.75rem;">
            <span id="mini-current-time">0:00</span>
            <span id="mini-total-time">0:00</span>
        </div>
        
        <!-- Mini Controls -->
        <div style="display:flex; justify-content:center; align-items:center; gap:0.75rem;">
            <button class="audio-control-btn" id="mini-prev-track-btn" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:36px; height:36px; display:flex; align-items:center; justify-content:center; font-size:0.85rem;"><i class="fas fa-step-backward"></i></button>
            <button class="audio-control-btn" id="mini-backward-btn" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:36px; height:36px; display:flex; align-items:center; justify-content:center; font-size:0.85rem;"><i class="fas fa-backward"></i></button>
            <button class="audio-control-btn" id="mini-play-pause-btn" style="background: linear-gradient(135deg, #ec4899, #a855f7); color:white; border:none; border-radius:50%; width:44px; height:44px; display:flex; align-items:center; justify-content:center; font-size:1rem;"><i class="fas fa-play"></i></button>
            <button class="audio-control-btn" id="mini-forward-btn" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:36px; height:36px; display:flex; align-items:center; justify-content:center; font-size:0.85rem;"><i class="fas fa-forward"></i></button>
            <button class="audio-control-btn" id="mini-next-track-btn" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:36px; height:36px; display:flex; align-items:center; justify-content:center; font-size:0.85rem;"><i class="fas fa-step-forward"></i></button>
        </div>
    </div>

    <!-- Playlist Chooser Modal -->
    <div id="music-playlist-chooser" class="books-reader-modal" style="display:none; background: rgba(0,0,0,0.7); backdrop-filter: blur(6px);">
        <div class="books-reader-content" style="max-width:520px; width:90%; border:1px solid rgba(56,189,248,0.35); border-radius:14px; overflow:hidden;">
            <div class="books-reader-header">
                <button id="playlist-chooser-back" class="books-reader-back-btn">
                    <i class="fas fa-arrow-left"></i>
                    Back
                </button>
                <h3>Add to Playlist</h3>
            </div>
            <div style="padding:1rem; display:flex; flex-direction:column; gap:0.75rem;">
                <div style="display:flex; gap:0.5rem;">
                    <input id="playlist-chooser-new-name" placeholder="New playlist name" style="flex:1; padding:0.6rem 0.8rem; border-radius:8px; background:var(--surface); border:1px solid var(--border); color:var(--light);" />
                    <button id="playlist-chooser-create" class="action-btn"><i class="fas fa-plus"></i><span>Create</span></button>
                </div>
                <div id="playlist-chooser-empty" class="books-empty" style="display:none; margin:0;">
                    <div class="books-empty-icon"><i class="fas fa-list"></i></div>
                    <h3>No playlists yet</h3>
                    <p>Create one above, then add your track.</p>
                </div>
                <div id="playlist-chooser-list" class="books-results-grid" style="grid-template-columns: 1fr; gap:0.5rem;"></div>
            </div>
        </div>
    </div>
    <!-- Genres Page -->
    <div id="genresPage" style="display: none;">
        <h2 class="section-title">
            <i class="fas fa-layer-group"></i> Genres
        </h2>
        <div class="genre-grid" id="genresGrid">
            <!-- Genre boxes will be loaded here -->
        </div>
        <div class="loading" id="genresLoading" style="display:none;">
            <i class="fas fa-spinner"></i> Loading genres...
        </div>
    </div>

    <!-- Genre Details Page -->
    <div id="genreDetailsPage" style="display: none;">
        <div class="genre-header">
            <h2 class="section-title" id="genreHeaderTitle">
                <i class="fas fa-tags"></i> <span id="genreTitle">Genre</span>
            </h2>
            <div class="genre-controls">
                <button class="toggle-btn" id="toggleMovies">Movies</button>
                <button class="toggle-btn" id="toggleTV">TV Shows</button>
            </div>
        </div>
        <div class="genre-results-grid" id="genreResultsGrid">
            <!-- Genre media items will be loaded here -->
        </div>
        <div class="loading" id="genreLoadingIndicator" style="display:none;">
            <i class="fas fa-spinner"></i> Loading more...
        </div>
        <div class="loading" id="genreEmptyMessage" style="display:none;">
            <i class="fas fa-info-circle"></i> No results found for this selection.
        </div>
    </div>

    <!-- My List Page -->
    <div id="myListPage" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-heart"></i> <span>My List</span>
                </h2>
                <p class="page-subtitle">Your personal collection of movies and shows</p>
            </div>
            <div class="page-actions">
                <button class="action-btn" id="clearMyListBtn">
                    <i class="fas fa-trash"></i>
                    <span>Clear All</span>
                </button>
            </div>
        </div>
        
        <div class="movies-grid" id="myListGrid">
            <!-- My list items will be loaded here -->
        </div>
        <div class="loading" id="myListLoading" style="display:none;">
            <i class="fas fa-spinner"></i> Loading your list...
        </div>
        <div class="loading" id="myListEmpty" style="display:none;">
            <i class="fas fa-heart-broken"></i> Your list is empty. Start adding movies and shows!
        </div>
    </div>

    <!-- Done Watching Page -->
    <div id="doneWatchingPage" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-check-circle"></i> <span>Done Watching</span>
                </h2>
                <p class="page-subtitle">Movies and shows you've finished watching</p>
            </div>
            <div class="page-actions">
                <button class="action-btn" id="clearDoneWatchingBtn">
                    <i class="fas fa-trash"></i>
                    <span>Clear All</span>
                </button>
            </div>
        </div>
        
        <div class="movies-grid" id="doneWatchingGrid">
            <!-- Done watching items will be loaded here -->
        </div>
        <div class="loading" id="doneWatchingLoading" style="display:none;">
            <i class="fas fa-spinner"></i> Loading your completed items...
        </div>
        <div class="loading" id="doneWatchingEmpty" style="display:none;">
            <i class="fas fa-check-circle"></i> No completed items yet. Mark movies and shows as done when you finish watching!
        </div>
    </div>

    <!-- Trakt Page -->
    <div id="trakt-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-tv" style="color: #ed1c24;"></i> <span>Trakt Integration</span>
                </h2>
                <p class="page-subtitle">Sync your watching activity with Trakt.tv</p>
            </div>
        </div>

        <div class="trakt-container">
            <!-- Connection Status Card -->
            <div class="trakt-card trakt-status-card">
                <div class="trakt-card-header">
                    <h3><i class="fas fa-wifi"></i> Connection Status</h3>
                </div>
                <div class="trakt-card-body">
                    <div id="traktPageNotConnected" class="trakt-status-section">
                        <div id="traktStatusIndicator" class="trakt-status-indicator disconnected">
                            <i class="fas fa-times-circle"></i>
                            <span>Not Connected</span>
                        </div>
                        <p id="traktStatusDescription" class="trakt-description">
                            Connect your Trakt.tv account to automatically track your watching activity, 
                            sync progress, and manage your watchlist.
                        </p>
                        <div id="traktStatusActions">
                            <button id="traktAuthenticateBtn" class="trakt-btn trakt-btn-primary">
                                <i class="fas fa-link"></i>Connect to Trakt
                            </button>
                        </div>
                    </div>

                    <div id="traktPageConnected" class="trakt-status-section" style="display: none;">
                        <div class="trakt-status-indicator connected">
                            <i class="fas fa-check-circle"></i>
                            <span>Connected as <strong id="traktPageUsername">User</strong></span>
                        </div>
                        <p class="trakt-description">
                            Your account is connected and actively syncing. All your watching activity 
                            is being tracked automatically.
                        </p>
                        <div class="trakt-user-actions">
                            <button class="trakt-btn trakt-btn-secondary" id="traktPageDisconnect">
                                <i class="fas fa-sign-out-alt"></i> Disconnect
                            </button>
                            <button class="trakt-btn trakt-btn-info" id="traktPageRefresh">
                                <i class="fas fa-sync-alt"></i> Refresh Status
                            </button>
                        </div>
                    </div>

                    <!-- Device Code Panel -->
                    <div id="traktDeviceCodePanel" class="trakt-device-code" style="display: none;">
                        <div class="trakt-code-header">
                            <h4><i class="fas fa-mobile-alt"></i> Device Authorization</h4>
                        </div>
                        <div class="trakt-code-content">
                            <div class="trakt-code-display">
                                <label>Device Code:</label>
                                <div class="trakt-code-value">
                                    <span id="traktUserCode">----</span>
                                    <button id="traktCopyCodeBtn" class="trakt-copy-btn">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <label>Visit URL:</label>
                                <div class="trakt-code-value">
                                    <span id="traktVerificationUrl">https://trakt.tv/activate</span>
                                </div>
                            </div>
                            <div class="trakt-verify-section">
                                <p>Visit the URL above and enter the device code</p>
                                <div class="trakt-verify-actions">
                                    <button id="traktOpenUrlBtn" class="trakt-btn trakt-btn-primary">
                                        <i class="fas fa-external-link-alt"></i> Open Trakt URL
                                    </button>
                                    <button id="traktVerifyDeviceBtn" class="trakt-btn trakt-btn-secondary">
                                        <i class="fas fa-check"></i> Verify Code
                                    </button>
                                </div>
                                <div id="traktDeviceCodeStatus" class="trakt-status-message">
                                    <span>Waiting for authorization...</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Quick Actions Grid -->
            <div class="trakt-actions-grid">
                <div class="trakt-card trakt-action-card" data-action="watchlist">
                    <div class="trakt-action-icon">
                        <i class="fas fa-list"></i>
                    </div>
                    <div class="trakt-action-content">
                        <h4>Your Watchlist</h4>
                        <p>View and manage your Trakt watchlist</p>
                        <span class="trakt-action-count">0</span>
                    </div>
                </div>

                <div class="trakt-card trakt-action-card" data-action="history">
                    <div class="trakt-action-icon">
                        <i class="fas fa-history"></i>
                    </div>
                    <div class="trakt-action-content">
                        <h4>Watch History</h4>
                        <p>See your recently watched content</p>
                        <span class="trakt-action-count">0</span>
                    </div>
                </div>

                <div class="trakt-card trakt-action-card" data-action="collection">
                    <div class="trakt-action-icon">
                        <i class="fas fa-collection"></i>
                    </div>
                    <div class="trakt-action-content">
                        <h4>Collection</h4>
                        <p>Your collected movies and shows</p>
                        <span class="trakt-action-count">0</span>
                    </div>
                </div>

                <div class="trakt-card trakt-action-card" data-action="ratings">
                    <div class="trakt-action-icon">
                        <i class="fas fa-star"></i>
                    </div>
                    <div class="trakt-action-content">
                        <h4>Ratings</h4>
                        <p>Your rated content</p>
                        <span class="trakt-action-count">0</span>
                    </div>
                </div>
            </div>

            <!-- Scrobbling Settings Card -->
            <div class="trakt-card">
                <div class="trakt-card-header">
                    <h3><i class="fas fa-play-circle"></i> Scrobbling Settings</h3>
                </div>
                <div class="trakt-card-body">
                    <div class="trakt-settings-grid">
                        <div class="trakt-setting-item">
                            <div class="trakt-setting-main">
                                <label class="trakt-toggle">
                                    <input type="checkbox" id="traktPageAutoScrobble" checked>
                                    <span class="trakt-toggle-slider"></span>
                                </label>
                                <div class="trakt-setting-content">
                                    <h4>Auto-Track Watching</h4>
                                    <p>Automatically track movies and shows you watch</p>
                                </div>
                            </div>
                        </div>

                        <div class="trakt-setting-item">
                            <div class="trakt-setting-main">
                                <label class="trakt-toggle">
                                    <input type="checkbox" id="traktPageScrobbleProgress" checked>
                                    <span class="trakt-toggle-slider"></span>
                                </label>
                                <div class="trakt-setting-content">
                                    <h4>Sync Progress</h4>
                                    <p>Keep your watch progress synchronized in real-time</p>
                                </div>
                            </div>
                        </div>

                        <div class="trakt-setting-item">
                            <div class="trakt-setting-main">
                                <label class="trakt-toggle">
                                    <input type="checkbox" id="traktPageWatchlistSync" checked>
                                    <span class="trakt-toggle-slider"></span>
                                </label>
                                <div class="trakt-setting-content">
                                    <h4>Watchlist Integration</h4>
                                    <p>Show Trakt watchlist items in search results</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Recent Activity -->
            <div class="trakt-card" id="traktRecentActivity" style="display: none;">
                <div class="trakt-card-header">
                    <h3><i class="fas fa-clock"></i> Recent Activity</h3>
                </div>
                <div class="trakt-card-body">
                    <div class="trakt-activity-list" id="traktActivityList">
                        <!-- Activity items will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Page -->
    <div id="settings-page" style="display: none;">
        <div class="settings-page-container">
            <div class="page-header-enhanced">
                <h2 class="section-title">Settings</h2>
            </div>
            
            <div class="settings-tabs">
                <button class="settings-tab active" data-section="streaming">Streaming</button>
                <button class="settings-tab" data-section="debrid">Debrid</button>
                <button class="settings-tab" data-section="ui">User Interface</button>
                <button class="settings-tab" data-section="trakt">Trakt Integration</button>
            </div>

            <div class="settings-sections">
                <!-- Streaming Section -->
                <div id="streamingContent" class="settings-section active">
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-server"></i> Jackett Configuration</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="current-api-key" id="currentApiKey">
                                No API key configured
                            </div>
                            <div class="form-group">
                                <label for="newApiKey">New API Key:</label>
                                <input type="text" id="newApiKey" placeholder="Enter new Jackett API key..." />
                            </div>
                            <div class="form-group">
                                <label for="jackettUrl">Jackett Base URL:</label>
                                <input type="text" id="jackettUrl" placeholder="http://127.0.0.1:9117/api/v2.0/indexers/all/results/torznab" />
                                <small style="color:var(--secondary); font-size:0.85rem; margin-top:0.25rem; display:block;">Default: http://127.0.0.1:9117/api/v2.0/indexers/all/results/torznab</small>
                            </div>
                        </div>
                    </div>
                    
                    
                    
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-play-circle"></i> Streaming Mode</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="checkbox-group">
                                <input type="checkbox" id="useStreamingServersToggle" />
                                <label for="useStreamingServersToggle">Use Streaming Servers instead of Torrents</label>
                            </div>
                            <div style="margin-top:0.5rem; color:#10b981; font-size:0.9rem;">
                                Stream directly from web servers (faster startup, no downloads)
                            </div>
                            <div style="margin-top:0.25rem; color:#9ca3af; font-size:0.85rem;">
                                When enabled, movies/shows will stream from online servers instead of torrent files
                            </div>
                        </div>
                    </div>
                    
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-hdd"></i> Cache & Storage</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="form-group">
                                <label for="cacheLocation">Cache Location:</label>
                                <div style="display:flex; gap:0.5rem; align-items:center;">
                                    <input type="text" id="cacheLocation" readonly placeholder="System default temp folder" style="flex:1;" />
                                    <button class="api-btn" id="selectCacheBtn" style="background:#0d6efd; color:#fff; white-space:nowrap;">
                                        <i class="fas fa-folder-open"></i> Browse
                                    </button>
                                </div>
                                <small style="color:var(--secondary); font-size:0.85rem; margin-top:0.25rem; display:block;">
                                    <i class="fas fa-info-circle"></i> Location where WebTorrent streams and subtitles are cached
                                </small>
                            </div>
                        </div>
                    </div>
                    
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-stream" style="color: #667eea;"></i> Nuvio Configuration</h3>
                        </div>
                        <div class="settings-card-body">
                            <div style="margin-bottom: 1rem; color: var(--secondary); font-size: 0.9rem;">
                                <i class="fas fa-info-circle"></i>
                                Configure your Febbox token for Nuvio streaming (ShowBox). A default token is provided, but you can use your own.
                            </div>
                            
                            <div class="form-group">
                                <label for="febboxTokenInput">
                                    Febbox JWT Token (Optional)
                                </label>
                                <input 
                                    type="text" 
                                    id="febboxTokenInput" 
                                    placeholder="Leave empty to use default token or paste your Febbox JWT token here"
                                    style="font-family: monospace;"
                                />
                            </div>
                            
                            <button id="saveFebboxToken" class="btn" style="width: 100%;">
                                <i class="fas fa-save"></i> Save Token
                            </button>
                            
                            <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(103, 126, 234, 0.1); border-left: 3px solid var(--secondary); border-radius: 4px; font-size: 0.85rem;">
                                <i class="fas fa-check-circle" style="color: var(--secondary);"></i> Default token is active. You can continue using Nuvio without adding your own token.
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Debrid Section -->
                <div id="debridContent" class="settings-section">
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-cloud"></i> Debrid Services (Cloud Cache)</h3>
                        </div>
                        <div class="settings-card-body" id="debridSection">
                            <div class="checkbox-group">
                                <input type="checkbox" id="useDebridToggle" />
                                <label for="useDebridToggle">Use Debrid</label>
                            </div>
                            
                            <div class="form-group">
                                <div style="display:flex; gap:0.75rem; align-items:center; flex-wrap: wrap;">
                                    <label for="debridProvider">Provider:</label>
                                    <select id="debridProvider" style="min-width:220px; max-width:260px;">
                                        <option value="realdebrid">RealDebrid</option>
                                        <option value="alldebrid">AllDebrid</option>
                                        <option value="torbox">TorBox</option>
                                        <option value="premiumize">Premiumize</option>
                                    </select>
                                    <span id="debridStatus" style="font-size:0.9rem; opacity:0.85;">Not logged in</span>
                                </div>
                            </div>
                            
                            <!-- Real-Debrid Section -->
                            <div class="form-group" id="rdClientIdGroup">
                                <label for="rdClientId">RealDebrid Client ID (device flow):</label>
                                <input type="text" id="rdClientId" placeholder="Enter your RD Client ID (e.g., XXXXXXXXXXXXX)" />
                            </div>
                            
                            <div id="rdButtons" style="display:flex; gap:0.5rem; flex-wrap: wrap; align-items:center;">
                                <button class="api-btn" id="rdDeviceLogin" style="background:#198754; color:#fff;">
                                    <i class="fas fa-sign-in-alt"></i> Login with RealDebrid
                                </button>
                                <small style="opacity:0.85;">No password needed. Authenticate on realdebrid.com using a short code.</small>
                            </div>
                            
                            <div id="rdCodePanel" style="display:none; margin-top:0.5rem; padding:0.75rem; background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.1); border-radius:8px;">
                                <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                                    <div>Code:</div>
                                    <div id="rdUserCode" style="font-family:monospace; font-weight:800; background:rgba(255,255,255,0.1); padding:0.25rem 0.5rem; border-radius:6px;">----</div>
                                    <button class="api-btn" id="rdCopyCode" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-copy"></i> Copy</button>
                                </div>
                                <div style="margin-top:0.5rem; display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                                    <div>Verify at:</div>
                                    <a id="rdVerifyUrl" href="#" target="_blank" style="color:#0d6efd; text-decoration:underline;">https://real-debrid.com/device</a>
                                    <button class="api-btn" id="rdOpenVerify" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-external-link-alt"></i> Open</button>
                                    <span id="rdLoginStatus" style="margin-left:auto; font-size:0.9rem; opacity:0.9;">Waiting for approval</span>
                                    <button class="api-btn api-btn-secondary" id="rdCancelLogin"><i class="fas fa-times"></i> Cancel</button>
                                </div>
                            </div>
                            
                            <div class="form-group" id="rdTokenGroup">
                                <label for="debridToken">RealDebrid Token (temporary MVP):</label>
                                <input type="password" id="debridToken" placeholder="Paste RD token..." />
                            </div>
                            
                            <div id="rdTokenButtons" style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                                <button class="api-btn" id="saveDebridToken" style="background:#0d6efd; color:#fff;">
                                    <i class="fas fa-key"></i> Save Token
                                </button>
                                <button class="api-btn api-btn-secondary" id="clearDebridToken">
                                    <i class="fas fa-sign-out-alt"></i> Logout
                                </button>
                            </div>
                            
                            <div style="margin-top:0.25rem; color:#ffc107; font-size:0.9rem;">Your token is stored locally and never exposed to websites.</div>

                            <!-- AllDebrid PIN Login UI -->
                            <div id="adSection" style="display:none; margin-top:1rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                                <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
                                    <button class="api-btn" id="adStartPin" style="background:#198754; color:#fff;"><i class="fas fa-sign-in-alt"></i> Login with AllDebrid (PIN)</button>
                                    <small style="opacity:0.85;">Authenticate on alldebrid.com/pin with the code shown.</small>
                                </div>
                                <div id="adPinPanel" style="display:none; margin-top:0.5rem; padding:0.75rem; background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.1); border-radius:8px;">
                                    <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                                        <div>PIN:</div>
                                        <div id="adPinCode" style="font-family:monospace; font-weight:800; background:rgba(255,255,255,0.1); padding:0.25rem 0.5rem; border-radius:6px;">----</div>
                                        <button class="api-btn" id="adCopyPin" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-copy"></i> Copy</button>
                                    </div>
                                    <div style="margin-top:0.5rem; display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                                        <div>Open:</div>
                                        <a id="adUserUrl" href="https://alldebrid.com/pin/" target="_blank" style="color:#0d6efd; text-decoration:underline;">https://alldebrid.com/pin/</a>
                                        <button class="api-btn" id="adOpenUserUrl" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-external-link-alt"></i> Open</button>
                                        <span id="adLoginStatus" style="margin-left:auto; font-size:0.9rem; opacity:0.9;">Waiting</span>
                                        <button class="api-btn api-btn-secondary" id="adCancelPin"><i class="fas fa-times"></i> Cancel</button>
                                    </div>
                                </div>
                                <div class="form-group" style="margin-top:0.75rem;">
                                    <label for="adApiKey">AllDebrid API Key (optional/manual):</label>
                                    <input type="password" id="adApiKey" placeholder="Paste AD API key..." />
                                </div>
                                <div style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                                    <button class="api-btn" id="adSaveApiKey" style="background:#0d6efd; color:#fff;"><i class="fas fa-key"></i> Save API Key</button>
                                    <button class="api-btn api-btn-secondary" id="adClearApiKey"><i class="fas fa-sign-out-alt"></i> Logout</button>
                                </div>
                            </div>

                            <!-- TorBox Auth (token) -->
                            <div id="tbSection" style="display:none; margin-top:1rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                                <div class="form-group">
                                    <label for="tbToken">TorBox Token (temporary):</label>
                                    <input type="password" id="tbToken" placeholder="Paste TorBox token..." />
                                </div>
                                <div style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                                    <button class="api-btn" id="tbSaveToken" style="background:#0d6efd; color:#fff;"><i class="fas fa-key"></i> Save Token</button>
                                    <button class="api-btn api-btn-secondary" id="tbClearToken"><i class="fas fa-sign-out-alt"></i> Logout</button>
                                </div>
                                <div style="margin-top:0.25rem; color:#ffc107; font-size:0.9rem;">Token stored locally.</div>
                            </div>

                            <!-- Premiumize Auth (API Key) -->
                            <div id="pmSection" style="display:none; margin-top:1rem; padding:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                                <div class="form-group">
                                    <label for="pmApiKey">Premiumize API Key:</label>
                                    <input type="password" id="pmApiKey" placeholder="Enter your Premiumize API key..." />
                                </div>
                                <div style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                                    <button class="api-btn" id="pmSaveApiKey" style="background:#0d6efd; color:#fff;"><i class="fas fa-key"></i> Save API Key</button>
                                    <button class="api-btn api-btn-secondary" id="pmClearApiKey"><i class="fas fa-sign-out-alt"></i> Logout</button>
                                </div>
                                <div style="margin-top:0.25rem; color:#ffc107; font-size:0.9rem;">
                                    Get your API key from <a href="https://www.premiumize.me/account" target="_blank" style="color:#0d6efd; text-decoration:underline;">premiumize.me/account</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- User Interface Section -->
                <div id="uiContent" class="settings-section">
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-desktop"></i> Display Settings</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="checkbox-group">
                                <input type="checkbox" id="fullscreenToggle" />
                                <label for="fullscreenToggle">
                                    <i class="fas fa-expand-arrows-alt" style="margin-right:0.25rem; color:var(--vlc-orange);"></i>
                                    <strong>Fullscreen Mode</strong>
                                </label>
                            </div>
                            <div style="margin-top:0.25rem; color:var(--secondary); font-size:0.85rem; margin-left:1.85rem;">
                                <i class="fas fa-info-circle"></i> Toggle between fullscreen and windowed mode
                            </div>
                            
                            <div class="radio-group" style="margin-top:1.5rem; padding-top:1rem; border-top:1px solid rgba(255,255,255,0.1);">
                                <label style="display:block; margin-bottom:0.75rem; color:var(--light); font-weight:600;">
                                    UI Mode
                                </label>
                                <div class="radio-option">
                                    <input type="radio" name="uiMode" value="new" id="uiModeNew" checked />
                                    <label for="uiModeNew"><strong>NEW UI</strong> - Modern app-like interface</label>
                                </div>
                                <div class="radio-option">
                                    <input type="radio" name="uiMode" value="old" id="uiModeOld" />
                                    <label for="uiModeOld"><strong>OLD UI</strong> - Classic website layout</label>
                                </div>
                                <div style="margin-top:0.5rem; color:var(--secondary); font-size:0.9rem;">
                                    <i class="fas fa-info-circle"></i> Changes will apply immediately after saving
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-palette"></i> Theme</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="form-group">
                                <label for="themeSelector" style="display:block; margin-bottom:0.75rem; color:var(--light); font-weight:600; font-size:1rem;">
                                    <i class="fas fa-palette" style="margin-right:0.5rem; color:var(--vlc-orange);"></i>
                                    Color Theme
                                </label>
                                <select id="themeSelector" style="width:100%; max-width:350px; padding:0.75rem 1rem; background: rgba(255,255,255,0.08); border: 2px solid rgba(255,255,255,0.2); border-radius:10px; color:var(--light); font-size:0.95rem; font-weight:500; cursor:pointer; transition: all 0.3s ease; appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27rgba(255,255,255,0.6)%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.75rem center; background-size: 1.25rem; padding-right: 2.5rem;">
                                    <option value="default">Default (Purple Dream)</option>
                                    <option value="green-forest">Green Forest</option>
                                    <option value="cyberpunk-neon">Cyberpunk Neon</option>
                                    <option value="ocean-breeze">Ocean Breeze</option>
                                    <option value="cherry-blossom">Cherry Blossom</option>
                                    <option value="midnight-dark">Midnight Dark</option>
                                    <option value="sunset-orange">Sunset Orange</option>
                                </select>
                                <small style="margin-top:0.5rem; color:var(--secondary); font-size:0.85rem; display:block;">
                                    <i class="fas fa-info-circle"></i> Choose your preferred color scheme
                                </small>
                            </div>
                        </div>
                    </div>

                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-sync-alt"></i> AutoUpdater</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="checkbox-group">
                                <input type="checkbox" id="autoUpdateToggle" checked />
                                <label for="autoUpdateToggle">Automatically download and install updates</label>
                            </div>
                            <div style="margin-top:0.5rem; color:#9ca3af; font-size:0.9rem;">
                                When enabled, the app will check for updates on launch and install them when available.
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Trakt Integration Section -->
                <div id="traktContent" class="settings-section">
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-tv" style="color: #ed1c24;"></i> Trakt Connection</h3>
                        </div>
                        <div class="settings-card-body">
                            <div style="margin-bottom: 1rem; color: var(--secondary); font-size: 0.9rem;">
                                <i class="fas fa-info-circle"></i>
                                Sync your watch history, progress, and manage your watchlist with Trakt.tv
                            </div>
                            
                            <div id="traktNotConnected" style="display: block;">
                                <div style="margin-bottom: 1rem;">
                                    <span id="traktStatus" style="color: #dc3545; font-weight: 500;">
                                        <i class="fas fa-times-circle"></i> Not connected
                                    </span>
                                </div>
                                <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                                    <button class="api-btn" id="traktLogin" style="background: #ed1c24; color: #fff;">
                                        <i class="fas fa-sign-in-alt"></i> Connect to Trakt
                                    </button>
                                    <small style="opacity: 0.85;">Authenticate with your Trakt.tv account using a secure device code</small>
                                </div>
                            </div>

                            <div id="traktConnected" style="display: none;">
                                <div style="margin-bottom: 1rem;">
                                    <span id="traktConnectedStatus" style="color: #198754; font-weight: 500;">
                                        <i class="fas fa-check-circle"></i> Connected as <span id="traktUsername">User</span>
                                    </span>
                                </div>
                                <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; margin-bottom: 1rem;">
                                    <button class="api-btn" id="traktViewWatchlist" style="background: #0d6efd; color: #fff;">
                                        <i class="fas fa-list"></i> View Watchlist
                                    </button>
                                    <button class="api-btn" id="traktViewHistory" style="background: #6f42c1; color: #fff;">
                                        <i class="fas fa-history"></i> View History
                                    </button>
                                    <button class="api-btn" id="traktViewStats" style="background: #17a2b8; color: #fff;">
                                        <i class="fas fa-chart-bar"></i> View Stats
                                    </button>
                                </div>
                                <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                                    <button class="api-btn api-btn-secondary" id="traktDisconnect">
                                        <i class="fas fa-sign-out-alt"></i> Disconnect
                                    </button>
                                </div>
                            </div>

                            <!-- Trakt Device Code Panel -->
                            <div id="traktCodePanel" style="display: none; margin-top: 1rem; padding: 0.75rem; background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
                                    <div>Device Code:</div>
                                    <div id="traktUserCode" style="font-family: monospace; font-weight: 800; background: rgba(255,255,255,0.1); padding: 0.25rem 0.5rem; border-radius: 6px;">----</div>
                                    <button class="api-btn" id="traktCopyCode" style="padding: 0.4rem 0.6rem; background: #0d6efd; color: #fff;">
                                        <i class="fas fa-copy"></i> Copy
                                    </button>
                                </div>
                                <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                                    <div>Authorize at:</div>
                                    <a id="traktVerifyUrl" href="#" target="_blank" style="color: #0d6efd; text-decoration: underline;">https://trakt.tv/activate</a>
                                    <button class="api-btn" id="traktOpenVerify" style="padding: 0.4rem 0.6rem; background: #0d6efd; color: #fff;">
                                        <i class="fas fa-external-link-alt"></i> Open
                                    </button>
                                    <span id="traktLoginStatus" style="margin-left: auto; font-size: 0.9rem; opacity: 0.9;">Waiting for authorization</span>
                                    <button class="api-btn api-btn-secondary" id="traktCancelLogin">
                                        <i class="fas fa-times"></i> Cancel
                                    </button>
                                </div>
                            </div>

                            <!-- Trakt Settings -->
                            <div id="traktSettings" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                <h4 style="margin-bottom: 0.75rem; color: var(--text-primary);">Scrobbling Settings</h4>
                                <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                    <label style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer;">
                                        <input type="checkbox" id="traktAutoScrobble" checked />
                                        <span>Automatically track what I watch</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer;">
                                        <input type="checkbox" id="traktScrobbleProgress" checked />
                                        <span>Sync watch progress</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer;">
                                        <input type="checkbox" id="traktSyncWatchlist" checked />
                                        <span>Show Trakt watchlist items in search</span>
                                    </label>
                                </div>
                                <div style="margin-top: 0.5rem; color: var(--secondary); font-size: 0.85rem;">
                                    <i class="fas fa-info-circle"></i> Your viewing activity will be automatically synchronized with Trakt.tv
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Save Button -->
            <div style="margin-top: 2rem; padding-top: 2rem; border-top: 2px solid rgba(168, 85, 247, 0.2); display: flex; gap: 1rem; justify-content: flex-end;">
                <button class="api-btn api-btn-secondary" id="cancelSettingsPage">
                    <i class="fas fa-times"></i> Cancel
                </button>
                <button class="api-btn api-btn-primary" id="saveSettingsPage">
                    <i class="fas fa-save"></i> Save Changes
                </button>
            </div>
        </div>
    </div>

    <!-- Live TV Page -->
    <div id="livetv-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-broadcast-tower" style="color: #10b981;"></i> <span>Live TV</span>
                </h2>
                <p class="page-subtitle">Watch live sports from around the world</p>
            </div>
        </div>

        <div class="trakt-container">
            <!-- Category Selector -->
            <div class="trakt-card">
                <div class="trakt-card-body">
                    <div class="livetv-category-section">
                        <label for="livetv-category-select" class="livetv-category-label">
                            <i class="fas fa-filter"></i> Category
                        </label>
                        <select id="livetv-category-select" class="livetv-category-dropdown">
                            <option value="football"> Football</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Matches Grid -->
            <div class="trakt-card">
                <div class="trakt-card-body">
                    <div id="livetv-grid" class="livetv-matches-grid"></div>
                    <div id="livetv-empty" class="livetv-empty" style="display: none;">
                        <i class="fas fa-tv" style="font-size: 3em; opacity: 0.3;"></i>
                        <p>No matches available for this category</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Streams List Modal -->
        <div id="livetv-streams-modal" class="livetv-streams-modal" style="display: none;">
            <div class="livetv-streams-content">
                <div class="livetv-streams-header">
                    <h3 id="livetv-streams-title"></h3>
                    <button id="livetv-streams-close" class="livetv-close-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div id="livetv-streams-list" class="livetv-streams-list"></div>
            </div>
        </div>
    </div>

    <!-- IPTV Page -->
    <div id="iptv-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-tv" style="color: #3b82f6;"></i> <span>IPTV</span>
                </h2>
                <p class="page-subtitle">Watch live TV channels from around the world</p>
            </div>
        </div>

        <div class="page-content" style="padding: 0; height: calc(100vh - 140px);">
            <iframe 
                id="iptv-iframe" 
                src="https://taupe-florentine-9c4193.netlify.app/routes/countries.html" 
                style="width: 100%; height: 100%; border: none; border-radius: 8px;"
                allowfullscreen>
            </iframe>
        </div>
    </div>

    <!-- Games Downloader Page -->
    <div id="games-downloader-page" class="page-wrapper" style="display: none;">
        <div class="page-header">
            <h2><i class="fas fa-download" style="color:#8b5cf6"></i> Games Downloader</h2>
        </div>

        <div class="page-content">
            <!-- Search Section -->
            <div class="search-section" style="max-width: 800px; margin: 2rem auto; text-align: center;">
                <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                    <input 
                        type="text" 
                        id="games-search-input" 
                        placeholder="Search for PC games (e.g., Call of Duty, GTA, Cyberpunk)..." 
                        style="flex: 1; padding: 0.75rem 1rem; border: 2px solid rgba(139,92,246,0.3); border-radius: 8px; background: rgba(139,92,246,0.05); color: var(--light); font-size: 1rem;"
                    >
                    <button 
                        id="games-search-btn" 
                        style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #8b5cf6, #7c3aed); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; transition: transform 0.2s;"
                        onmouseover="this.style.transform='scale(1.05)'" 
                        onmouseout="this.style.transform='scale(1)'"
                    >
                        <i class="fas fa-search"></i> Search
                    </button>
                </div>
                <div id="games-search-status" style="color: var(--secondary); font-size: 0.9rem; min-height: 1.5rem;"></div>
            </div>

            <!-- Results Section -->
            <div id="games-results-section" style="display: none;">
                <div class="books-results-header" style="align-items:center; gap:1rem; margin-bottom: 1rem;">
                    <h3><i class="fas fa-list" style="color:#8b5cf6"></i> Search Results</h3>
                    <div id="games-results-count" class="books-results-count"></div>
                </div>
                <div id="games-results-grid" class="books-results-grid"></div>
            </div>

            <!-- Empty State -->
            <div id="games-empty-state" class="books-empty">
                <div class="books-empty-icon"><i class="fas fa-search"></i></div>
                <h3>Search for PC Games</h3>
                <p>Enter a game name above to find downloadable PC games, Scrape SteamUnderground for games</p>
            </div>
        </div>
    </div>

    <!-- PlayTorrio MiniGames Page -->
    <div id="minigames-page" style="display: none;">
        <div class="page-content" style="padding: 0; height: 100vh; overflow: hidden;">
            <iframe 
                id="minigames-iframe" 
                src="https://playtorriogames.pages.dev/" 
                style="width: 100%; height: 100%; border: none;"
                allowfullscreen>
            </iframe>
        </div>
    </div>

    <!-- Books Page -->
    <div id="books-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-book" style="color: #f59e0b;"></i> <span>Books</span>
                </h2>
                <p class="page-subtitle">Search and read books from Z-Library</p>
            </div>
        </div>

        <div class="page-content">
            <!-- Search Section -->
            <div class="books-search-section">
                <div class="books-search-container">
                    <div class="books-search-bar">
                        <i class="fas fa-search books-search-icon"></i>
                        <input 
                            type="text" 
                            id="books-search-input" 
                            placeholder="Search for books, authors, or titles..."
                            autocomplete="off"
                        />
                        <button id="books-search-btn" class="books-search-button">
                            <i class="fas fa-search"></i>
                            Search
                        </button>
                    </div>
                </div>
            </div>

            <!-- Loading State -->
            <div id="books-loading" class="books-loading" style="display: none;">
                <div class="books-loading-spinner">
                    <i class="fas fa-spinner fa-spin"></i>
                </div>
                <p>Searching Z-Library...</p>
            </div>

            <!-- Empty State -->
            <div id="books-empty" class="books-empty">
                <div class="books-empty-icon">
                    <i class="fas fa-book-open"></i>
                </div>
                <h3>Welcome to Z-Library Search</h3>
                <p>Search for any book, author, or topic to get started.</p>
            </div>

            <!-- Results Section -->
            <div id="books-results" class="books-results" style="display: none;">
                <div class="books-results-header">
                    <h3 id="books-results-title">Search Results</h3>
                    <div id="books-results-count" class="books-results-count"></div>
                </div>
                <div id="books-results-grid" class="books-results-grid">
                    <!-- Results will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Books Reader Modal -->
    <div id="books-reader-modal" class="books-reader-modal" style="display: none;">
        <div class="books-reader-content">
            <div class="books-reader-header">
                <button id="books-reader-back" class="books-reader-back-btn">
                    <i class="fas fa-arrow-left"></i>
                    Back
                </button>
                <h3 id="books-reader-title">Reading...</h3>
            </div>
            <div class="books-reader-frame-container">
                <iframe id="books-reader-frame" class="books-reader-frame"></iframe>
            </div>
        </div>
    </div>

    <!-- Server Selection Modal -->
    <div id="server-selection-modal" class="server-selection-modal" style="display: none;">
        <div class="server-selection-content">
            <div class="server-selection-header">
                <button id="server-selection-back" class="server-selection-back-btn">
                    <i class="fas fa-arrow-left"></i>
                    Back
                </button>
                <h3 id="server-selection-title">Select Streaming Server</h3>
            </div>
            <div class="server-selection-body">
                <div class="server-selection-info">
                    <div class="media-info">
                        <img id="server-media-poster" class="media-poster" src="" alt="Media Poster">
                        <div class="media-details">
                            <h4 id="server-media-title">Movie/Show Title</h4>
                            <p id="server-media-subtitle">Episode details</p>
                            <div class="media-meta">
                                <span id="server-media-year" class="media-year"></span>
                                <span id="server-media-rating" class="media-rating"></span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="server-dropdown-section">
                    <label for="server-dropdown" class="server-dropdown-label">
                        <i class="fas fa-server"></i>
                        Choose Streaming Server:
                    </label>
                    <div class="server-dropdown-container">
                        <select id="server-dropdown" class="server-dropdown">
                            <!-- Options will be populated by JavaScript -->
                        </select>
                        <i class="fas fa-chevron-down server-dropdown-arrow"></i>
                    </div>
                </div>
                <div class="server-actions">
                    <button id="server-watch-btn" class="server-watch-btn">
                        <i class="fas fa-play"></i>
                        Start Watching
                    </button>
                    <button id="server-torrent-btn" class="server-torrent-btn">
                        <i class="fas fa-download"></i>
                        Use Torrent Instead
                    </button>
                </div>
                
                <!-- Embedded Video Player Section -->
                <div id="server-video-section" class="server-video-section" style="display: none;">
                    <div class="server-video-header">
                        <h4 id="server-video-title">Now Playing</h4>
                        <button id="server-video-close" class="server-video-close">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="server-video-container">
                        <iframe id="server-video-frame" class="server-video-iframe" 
                                src="" 
                                allowfullscreen>
                        </iframe>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Chromecast Device Selection Modal -->
    <div id="chromecast-device-modal" class="modal" style="display: none; z-index: 6000;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="chromecast-modal-header">
                <h3><i class="fas fa-tv"></i> Select Chromecast Device</h3>
                <button class="close-modal" id="close-chromecast-modal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div id="chromecast-device-list" class="chromecast-device-list">
                    <div class="loading-spinner">
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Discovering devices...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Video Player Modal -->
    <div id="video-player-modal" class="video-player-modal" style="display: none;">
        <div class="video-player-content">
            <div class="video-player-header">
                <button id="video-player-back" class="video-player-back-btn">
                    <i class="fas fa-arrow-left"></i>
                    Back to Servers
                </button>
                <h3 id="video-player-title">Now Playing</h3>
                <div class="video-player-controls">
                    <button id="video-player-fullscreen" class="video-player-control-btn">
                        <i class="fas fa-expand"></i>
                    </button>
                </div>
            </div>
            <div class="video-player-frame-container">
                <iframe id="video-player-frame" class="video-player-frame"></iframe>
            </div>
        </div>
    </div>

    <!-- BookTorrio Page -->
    <div id="booktorrio-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-book-open" style="color: #06b6d4;"></i> <span>BookTorrio</span>
                </h2>
                <p class="page-subtitle">Search and download EPUB books</p>
            </div>
        </div>

        <div class="page-content">
            <!-- Navigation Buttons -->
            <div class="booktorrio-nav" style="margin-bottom: 2rem;">
                <button id="searchTabBtn" class="booktorrio-tab-btn active">
                    <i class="fas fa-search"></i> Search
                </button>
                <button id="libraryTabBtn" class="booktorrio-tab-btn">
                    <i class="fas fa-bookmark"></i> Library
                </button>
            </div>

            <!-- Search Tab -->
            <div id="searchTab" class="booktorrio-tab">
                <div class="search-section" style="margin-bottom: 2rem;">
                    <div class="search-container-books">
                        <input type="text" id="bookSearchInput" placeholder="Search for books..." class="search-input-books">
                        <button id="searchBooksBtn" class="search-btn-books">
                            <i class="fas fa-search"></i> Search
                        </button>
                    </div>
                </div>

                <div id="bookSearchResults" class="books-grid">
                    <div class="search-placeholder">
                        <i class="fas fa-book-open" style="font-size: 3rem; color: #06b6d4; margin-bottom: 1rem;"></i>
                        <h3>Search for Books</h3>
                        <p>Enter a book title above to find EPUB books</p>
                    </div>
                </div>

                <div id="bookSearchLoading" style="display: none; text-align: center; padding: 2rem;">
                    <div class="spinner"></div>
                    <p>Searching for books...</p>
                </div>
            </div>

            <!-- Library Tab (Empty for now) -->
            <div id="libraryTab" class="booktorrio-tab" style="display: none;">
                <div class="search-placeholder">
                    <i class="fas fa-bookmark" style="font-size: 3rem; color: #06b6d4; margin-bottom: 1rem;"></i>
                    <h3>Library</h3>
                    <p>Your saved books will appear here</p>
                </div>
            </div>
        </div>
    </div>

    <!-- EPUB Reader Overlay -->
    <div id="epubReaderOverlay" style="display:none;">
        <div class="reader-header">
            <div class="reader-esc-hint">Press ESC to exit</div>
            <div class="reader-title" id="readerTitle"></div>
            <div style="width: 120px;"></div> <!-- Spacer for symmetry -->
        </div>
        <div id="readerContainer"></div>
        <div class="reader-footer">
            <button id="readerBackBtn" class="reader-back-btn" title="Exit reader">
                <i class="fas fa-arrow-left"></i>
                <span>Back</span>
            </button>
            <div class="reader-nav-controls">
                <button id="readerPrevBtn" class="reader-nav-btn" title="Previous page"><i class="fas fa-chevron-left"></i></button>
                <button id="readerNextBtn" class="reader-nav-btn" title="Next page"><i class="fas fa-chevron-right"></i></button>
            </div>
            <div id="readerChapterControls" class="reader-chapter-controls" style="display:none;">
                <span class="chapter-count-label">Chapters: <strong id="readerChapterCount">0</strong></span>
                <input id="readerChapterInput" type="number" min="1" step="1" placeholder="1" title="Enter chapter number" />
                <button id="readerChapterGo" class="reader-nav-btn" title="Go to chapter"><i class="fas fa-arrow-right"></i></button>
            </div>
            <button id="readerSettingsBtn" class="reader-gear" aria-label="Settings"><i class="fas fa-cog"></i></button>
        </div>
        <div id="readerSettingsPanel" class="reader-settings hidden">
            <div class="settings-section">
                <label>Theme</label>
                <div class="settings-row">
                    <button class="theme-btn" data-theme="light">Light</button>
                    <button class="theme-btn" data-theme="dark">Dark</button>
                    <button class="theme-btn" data-theme="night">Night</button>
                </div>
            </div>
            <div class="settings-section">
                <label>Font</label>
                <select id="readerFont">
                    <option value="-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif">System Default</option>
                    <option value="Georgia, Cambria, 'Times New Roman', Times, serif">Serif</option>
                    <option value="Arial, Helvetica, sans-serif">Sans-Serif</option>
                    <option value="'Courier New', Courier, monospace">Monospace</option>
                </select>
            </div>
            <div class="settings-section">
                <label>Text size</label>
                <input id="readerFontSize" type="range" min="12" max="28" step="1" value="16"/>
            </div>
        </div>
    </div>

    <!-- Anime Page -->
    <div id="anime-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-dragon" style="color: #3b82f6;"></i> <span>Anime</span>
                </h2>
                <p class="page-subtitle">Discover and watch anime with torrents</p>
            </div>
        </div>

        <!-- Search Section -->
        <div style="max-width: 900px; margin: 0 auto 2rem;">
            <div style="background: rgba(255,255,255,0.1); border-radius: 12px; padding: 1rem; box-shadow: 0 4px 12px rgba(0,0,0,0.3); position: relative;">
                <i class="fas fa-search" style="position: absolute; left: 1.5rem; top: 50%; transform: translateY(-50%); color: #3b82f6; font-size: 1.2rem; pointer-events: none;"></i>
                <input id="animeSearchInput" placeholder="Search for anime..." type="text" style="width: 100%; padding: 1rem 1rem 1rem 3rem; background: rgba(0,0,0,0.4); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 10px; color: var(--light); font-size: 1.1rem; transition: all 0.3s ease; box-sizing: border-box;" />
            </div>
        </div>

        <!-- Anime Grid -->
        <div id="animeGrid" class="movies-grid" style="margin-top: 2rem;">
            <!-- Anime cards will be loaded here -->
        </div>
        <div class="loading" id="animeLoadingIndicator" style="display: none;">
            <div class="spinner"></div>
            <p>Loading anime...</p>
        </div>
    </div>

    <!-- Manga Page -->
    <div id="manga-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-book-reader" style="color: #ec4899;"></i> <span>Manga</span>
                </h2>
                <p class="page-subtitle">Read manga from MangaDex</p>
            </div>
        </div>

        <!-- Search Section -->
        <div style="max-width: 900px; margin: 0 auto 2rem;">
            <div style="background: rgba(255,255,255,0.1); border-radius: 12px; padding: 1rem; box-shadow: 0 4px 12px rgba(0,0,0,0.3); position: relative;">
                <i class="fas fa-search" style="position: absolute; left: 1.5rem; top: 50%; transform: translateY(-50%); color: #ec4899; font-size: 1.2rem; pointer-events: none;"></i>
                <input id="mangaSearchInput" placeholder="Search for manga..." type="text" style="width: 100%; padding: 1rem 1rem 1rem 3rem; background: rgba(0,0,0,0.4); border: 2px solid rgba(236, 72, 153, 0.3); border-radius: 10px; color: var(--light); font-size: 1.1rem; transition: all 0.3s ease; box-sizing: border-box;" />
            </div>
        </div>

        <!-- Manga Grid -->
        <div id="mangaGrid" class="movies-grid" style="margin-top: 2rem;">
            <!-- Manga cards will be loaded here -->
        </div>
        <div class="loading" id="mangaLoadingIndicator" style="display: none;">
            <i class="fas fa-spinner"></i> Loading manga...
        </div>
    </div>

    <!-- Manga Reader Page -->
    <div id="manga-reader-page" style="display: none; background: #000; min-height: 100vh; position: relative;">
        <!-- Floating Back Button -->
        <button id="mangaReaderBack" style="position: sticky; top: 1rem; left: 1rem; z-index: 1000; background: var(--secondary); border: none; padding: 0.75rem 1.5rem; border-radius: 8px; color: white; font-size: 1rem; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(0,0,0,0.5); width: fit-content; margin-bottom: 1rem;">
            <i class="fas fa-arrow-left"></i> Back
        </button>
        
        <!-- Keyboard Navigation Hint -->
        <div style="position: fixed; right: 1.5rem; top: 50%; transform: translateY(-50%); z-index: 900; background: rgba(0,0,0,0.7); padding: 1rem; border-radius: 8px; color: white; font-size: 0.9rem; text-align: center; backdrop-filter: blur(10px); box-shadow: 0 4px 12px rgba(0,0,0,0.5); max-width: 120px;">
            <i class="fas fa-keyboard" style="font-size: 1.5rem; margin-bottom: 0.5rem; display: block;"></i>
            <p style="margin: 0; line-height: 1.4;">Use arrow keys to scroll</p>
            <div style="margin-top: 0.5rem; font-size: 1.2rem;">
                <div><i class="fas fa-arrow-up"></i></div>
                <div><i class="fas fa-arrow-down"></i></div>
            </div>
        </div>

        <div id="mangaReaderTitle" style="text-align: center; padding: 1rem; color: white; font-size: 1.5rem; font-weight: 600;">
            <!-- Chapter title will be here -->
        </div>
        <div id="mangaReaderPages" style="max-width: 1200px; margin: 0 auto; padding: 1rem;">
            <!-- Manga pages will be loaded here -->
        </div>
        <div id="mangaReaderLoading" style="text-align: center; padding: 3rem; color: white;">
            <i class="fas fa-spinner fa-spin" style="font-size: 3rem; margin-bottom: 1rem;"></i>
            <p style="font-size: 1.2rem;">Loading chapter...</p>
        </div>
    </div>

    <!-- Manga Details Modal -->
    <div id="mangaDetailsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); z-index: 10000; overflow-y: auto;">
        <div style="max-width: 1200px; margin: 2rem auto; padding: 2rem; position: relative;">
            <button id="mangaDetailsClose" style="position: absolute; top: 1rem; right: 1rem; background: rgba(255,255,255,0.1); border: none; width: 40px; height: 40px; border-radius: 50%; color: white; font-size: 1.5rem; cursor: pointer; transition: all 0.3s ease;">
                <i class="fas fa-times"></i>
            </button>
            
            <div style="display: flex; gap: 2rem; margin-bottom: 2rem;">
                <img id="mangaDetailsCover" src="" alt="Manga Cover" style="width: 300px; height: 450px; object-fit: cover; border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.5);">
                <div style="flex: 1; color: white;">
                    <h2 id="mangaDetailsTitle" style="font-size: 2.5rem; margin-bottom: 1rem; color: #ec4899;"></h2>
                    <p id="mangaDetailsAuthor" style="font-size: 1.1rem; margin-bottom: 0.5rem; color: #9ca3af;"></p>
                    <p id="mangaDetailsStatus" style="font-size: 1rem; margin-bottom: 1rem; color: #9ca3af;"></p>
                    <div id="mangaDetailsTags" style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1.5rem;">
                        <!-- Tags will be here -->
                    </div>
                    <p id="mangaDetailsDescription" style="line-height: 1.6; color: #d1d5db; font-size: 1rem;">
                        <!-- Description will be here -->
                    </p>
                </div>
            </div>
            
            <div>
                <h3 style="color: white; font-size: 1.5rem; margin-bottom: 1rem;">
                    <i class="fas fa-list"></i> Chapters
                </h3>
                <div id="mangaChaptersList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem; max-height: 500px; overflow-y: auto;">
                    <!-- Chapters will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Downloader Page -->
    <div id="downloader-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-download" style="color: #a855f7;"></i> <span>Downloader</span>
                </h2>
                <p class="page-subtitle">Download and manage your media files</p>
            </div>
        </div>

        <div class="trakt-container">
            <div class="trakt-card">
                <div class="trakt-card-body">
                    <div class="downloader-search">
                        <input id="downloaderQuery" type="text" placeholder="Search movies or shows (e.g., Superman)" />
                        <button id="downloaderSearchBtn"><i class="fas fa-search"></i></button>
                        <div class="downloader-type-toggle">
                            <button id="downloaderFilterMovies" class="filter-btn active">Movies</button>
                            <button id="downloaderFilterTV" class="filter-btn">TV Shows</button>
                        </div>
                    </div>
                    <div id="downloaderResults" class="downloader-results"></div>
                    <div id="downloaderEmpty" class="downloader-empty" style="display:none;">Type a search above to see results.</div>
                </div>
            </div>
        </div>
    </div>
</main>
    </div> <!-- End app-main -->
</div> <!-- End app-container -->

<!-- Anime Details Modal -->
<div class="modal" id="animeDetailsModal">
<div class="modal-content">
<button class="modal-close" id="animeModalClose">
<i class="fas fa-times"></i>
</button>
<div class="modal-header">
<img alt="Backdrop" class="modal-backdrop" id="animeModalBackdrop" src=""/>
<div class="modal-header-content">
<img alt="Poster" class="modal-poster" id="animeModalPoster" src=""/>
<div>
<h1 class="modal-title" id="animeModalTitle">Anime Title</h1>
<div class="modal-info">
<div class="modal-rating">
<i class="fas fa-star"></i> <span id="animeModalRating">0.0</span>
</div>
<div class="modal-year" id="animeModalYear">2023</div>
<div class="modal-runtime" id="animeModalEpisodes">24 Episodes</div>
</div>
<p class="modal-tagline" id="animeModalGenres">Action, Adventure</p>
<div style="display: flex; gap: 0.75rem; flex-wrap: wrap; align-items: flex-start;">
    <button class="btn btn-primary" id="animeFindTorrentsBtn">
        <i class="fas fa-magnet"></i> Find Torrents
    </button>
</div>
</div>
</div>
</div>
<div class="modal-body">
<h3 class="modal-section-title">
<i class="fas fa-book-open"></i> Synopsis
</h3>
<p class="modal-overview" id="animeModalOverview">Synopsis goes here...</p>

<!-- Season/Episode Selector (only for series, not movies) -->
<div id="animeSeasonEpisodeContainer" style="display: none; margin: 1.5rem 0;">
<h3 class="modal-section-title">
<i class="fas fa-film"></i> Select Season & Episode
</h3>
<div style="display: flex; gap: 1rem; flex-wrap: wrap;">
    <div style="flex: 1; min-width: 200px;">
        <label style="display: block; margin-bottom: 0.5rem; color: var(--light); font-weight: 500; font-size: 0.95rem;">
            <i class="fas fa-layer-group"></i> Season
        </label>
        <select id="animeSeasonSelector" style="width: 100%; padding: 0.75rem; background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(37, 99, 235, 0.15)); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; color: var(--light); font-size: 1rem; cursor: pointer; font-weight: 500; transition: all 0.3s ease;">
            <option value="" style="background: #1a1a2e; color: var(--light);">All Seasons</option>
        </select>
    </div>
    <div style="flex: 1; min-width: 200px;">
        <label style="display: block; margin-bottom: 0.5rem; color: var(--light); font-weight: 500; font-size: 0.95rem;">
            <i class="fas fa-play-circle"></i> Episode
        </label>
        <select id="animeEpisodeSelector" style="width: 100%; padding: 0.75rem; background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(37, 99, 235, 0.15)); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; color: var(--light); font-size: 1rem; cursor: pointer; font-weight: 500; transition: all 0.3s ease;">
            <option value="" style="background: #1a1a2e; color: var(--light);">All Episodes</option>
        </select>
    </div>
</div>
<div style="background: rgba(59, 130, 246, 0.1); border-left: 3px solid #3b82f6; padding: 0.75rem 1rem; margin-top: 1rem; border-radius: 6px; font-size: 0.9rem; color: var(--light);">
<i class="fas fa-info-circle" style="color: #3b82f6; margin-right: 0.5rem;"></i>
<strong>Tip:</strong> Select "All Seasons" or "All Episodes" to find complete packs, or choose a specific season/episode for targeted results.
</div>
</div>

<!-- Torrents section -->
<div class="torrents-container" id="animeTorrentsContainer" style="display: none;">
<div class="torrents-header">
<h3 class="modal-section-title">
<i class="fas fa-magnet"></i> Available Torrents from Nyaa
</h3>
<div class="torrent-actions">
<button class="btn btn-outline" id="animeRefreshTorrents">
<i class="fas fa-sync"></i> Refresh
</button>
</div>
</div>

<!-- Custom Search Section -->
<div style="margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
<h4 style="color: var(--light); font-size: 0.95rem; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
<i class="fas fa-search" style="color: #3b82f6;"></i>
Can't find what you're looking for? Try a custom search
</h4>
<div style="display: flex; gap: 0.5rem; align-items: stretch;">
<input type="text" id="animeCustomSearchInput" placeholder="Enter your own search query (e.g., 'Dragon Ball S02E01 1080p')" style="flex: 1; padding: 0.75rem 1rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; color: var(--light); font-size: 0.95rem;">
<button id="animeCustomSearchBtn" style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #3b82f6, #2563eb); border: none; border-radius: 8px; color: white; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; transition: all 0.3s ease;">
<i class="fas fa-search"></i> Search
</button>
</div>
</div>

<div style="margin-bottom: 1rem;">
<input type="text" id="animeTorrentKeywordFilter" placeholder="Filter torrents by keyword (e.g., 1080p, BluRay, SubsPlease)..." style="width: 100%; padding: 0.6rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: var(--light); font-size: 0.95rem;">
</div>
<div class="torrents-list" id="animeTorrentsList">
<!-- Torrents will be loaded here -->
</div>
</div>
</div>
</div>
</div>

<!-- Movie/Show Details Modal -->
<div class="modal" id="detailsModal">
<div class="modal-content">
<button class="modal-close" id="modalClose">
<i class="fas fa-times"></i>
</button>
<div class="modal-header">
<img alt="Backdrop" class="modal-backdrop" id="modalBackdrop" src=""/>
<div class="modal-header-content">
<img alt="Poster" class="modal-poster" id="modalPoster" src=""/>
<div>
<h1 class="modal-title" id="modalTitle">Movie Title</h1>
<div class="modal-info">
<div class="modal-rating">
<i class="fas fa-star"></i> <span id="modalRating">0.0</span>
</div>
<div class="modal-year" id="modalYear">2023</div>
<div class="modal-runtime" id="modalRuntime">120 min</div>
</div>
<p class="modal-tagline" id="modalTagline">Tagline goes here</p>
<div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
    <div style="display:flex; flex-direction:column; gap:0.5rem; align-items:flex-start;">
        <button class="btn btn-primary btn-pill btn-accent" id="watchNowBtn">
            <i class="fas fa-play"></i> Find Media
        </button>
        <button class="btn btn-ghost btn-pill" id="useStreamsBtn">
            <i class="fas fa-broadcast-tower"></i> Use Streams instead
        </button>
        <div id="watchNowNote" style="display:none; color: var(--light); opacity: 0.85; font-size: 0.9rem; padding-left: 0.1rem;">
            <i class="fas fa-info-circle" style="color:#a78bfa;"></i>
            Please select an episode
        </div>
    </div>
    <button class="btn btn-ghost btn-pill" id="traktWatchlistBtn" style="display: none;">
        <i class="fas fa-plus"></i> Add to Watchlist
    </button>
</div>
</div>
</div>
</div>
<div class="modal-body">
<h3 class="modal-section-title">
<i class="fas fa-book-open"></i> Overview
                </h3>
<p class="modal-overview" id="modalOverview">Overview goes here...</p>

<!-- Seasons selector for TV shows -->
<div class="seasons-container" id="seasonsContainer" style="display: none;">
<h3 class="modal-section-title">
<i class="fas fa-tv"></i> Seasons
                    </h3>
<div style="background: rgba(139, 92, 246, 0.1); border-left: 3px solid var(--secondary); padding: 0.75rem 1rem; margin-bottom: 1rem; border-radius: 6px; font-size: 0.9rem; color: var(--light);">
<i class="fas fa-info-circle" style="color: var(--secondary); margin-right: 0.5rem;"></i>
<strong>Tip:</strong> Click a <strong>Season</strong> button to find torrents for the entire season, or click a specific <strong>Episode</strong> to find torrents for just that episode.
</div>
<div class="season-selector" id="seasonSelector">
<!-- Seasons buttons will be loaded here -->
</div>
<h3 class="modal-section-title">
<i class="fas fa-list"></i> Episodes
                    </h3>
<div class="episodes-grid" id="episodesGrid">
<!-- Episodes will be loaded here -->
</div>
</div>

<h3 class="modal-section-title">
<i class="fas fa-users"></i> Cast
                </h3>
<div class="cast-grid" id="castGrid">
<!-- Cast members will be loaded here -->
</div>

<h3 class="modal-section-title">
<i class="fas fa-thumbs-up"></i> Similar Content
                </h3>
<div class="similar-grid" id="similarGrid">
<!-- Similar movies/shows will be loaded here -->
</div>

<!-- Torrents section -->
<div class="torrents-container" id="torrentsContainer">
<div class="torrents-header">
<h3 class="modal-section-title">
<i class="fas fa-magnet"></i> Available Torrents
                        </h3>
<div class="torrent-actions">
    <label for="torrentSortSelect" style="margin-right: 0.5rem; font-size:0.9rem; opacity:0.85;">Sort:</label>
    <select id="torrentSortSelect" class="modal-select" style="margin-right: 0.5rem;">
        <option value="seeders">Seeds (default)</option>
        <option value="size-desc">Size: High  Low</option>
        <option value="size-asc">Size: Low  High</option>
    </select>
    <label for="torrentSizeFilterSelect" style="margin: 0 0.5rem 0 0.25rem; font-size:0.9rem; opacity:0.85;">Size:</label>
    <select id="torrentSizeFilterSelect" class="modal-select" style="margin-right: 0.5rem;">
        <option value="all">All sizes</option>
        <option value="gte-1g"> 1 GB</option>
        <option value="gte-2g"> 2 GB</option>
        <option value="2-4g">24 GB</option>
        <option value="4-8g">48 GB</option>
        <option value="gte-8g"> 8 GB</option>
    </select>
<button class="btn btn-outline" id="refreshTorrents">
<i class="fas fa-sync"></i> Refresh
                            </button>
</div>
</div>
<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-left: 4px solid #ffd700; padding: 1rem; margin-bottom: 1.5rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);">
<div style="display: flex; align-items: center; gap: 0.75rem;">
<i class="fas fa-volume-up" style="color: #ffd700; font-size: 1.5rem;"></i>
<div>
<strong style="color: #fff; font-size: 1.05rem;">Audio Issues?</strong>
<p style="margin: 0.25rem 0 0 0; color: rgba(255, 255, 255, 0.9); font-size: 0.95rem;">
If you experience audio problems or no audio at all, click <strong>"Open in MPV"</strong> for the best playback experience.
                        </p>
</div>
</div>
</div>
<div class="provider-buttons">
<button class="provider-btn active" data-provider="jackett">
<i class="fas fa-link"></i> Jackett
</button>
<button class="provider-btn" data-provider="torrentio">
<i class="fas fa-rocket"></i> Torrentio
</button>
<button class="provider-btn" data-provider="torrentless">
<i class="fas fa-tools"></i> PlayTorrio
</button>
<button class="provider-btn" data-provider="nuvio">
<i class="fas fa-stream"></i> Nuvio <span style="font-size: 0.8em; opacity: 0.8;">(ShowBox)</span>
</button>
<button class="provider-btn" data-provider="comet">
<i class="fas fa-meteor"></i> Comet
</button>
<button class="provider-btn" data-provider="111477">
<i class="fas fa-play-circle"></i> 111477
</button>
<button class="provider-btn" data-provider="moviebox">
<i class="fas fa-film"></i> MovieBox
</button>
</div>
<div style="margin-bottom: 1rem;">
<input type="text" id="torrentKeywordFilter" placeholder="Filter torrents by keyword..." style="width: 100%; padding: 0.6rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: var(--light); font-size: 0.95rem;">
</div>
<div class="torrents-list" id="torrentsList">
<!-- Torrents will be loaded here -->
</div>
</div>
</div>
</div>
</div>

<!-- MPV Player -->
<div class="vlc-player-container" id="mpvPlayerContainer">
<div class="vlc-player-header">
<div class="vlc-player-title" id="mpvPlayerTitle">Player <span class="source-badge webtorrent" id="streamSourceBadge" title="Streaming source">by ayman</span></div>
</div>
<div class="vlc-player-content">
<div class="file-selector" id="fileSelector">
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
    <h3 style="margin: 0;"><i class="fas fa-folder-open"></i> Select File to Play</h3>
    <button class="close-player-btn" id="closePlayerBtn" title="Close Player (Esc)" style="padding: 0.5rem 1rem; background: var(--vlc-orange); border: none; color: white; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 0.95rem;">
        <i class="fas fa-times"></i> Close
    </button>
</div>
<div class="file-list" id="fileList">
<!-- Files will be loaded here -->
</div>
</div>

<div class="subtitle-controls" id="subtitleControls" style="display: none;">
<h4><i class="fas fa-closed-captioning"></i> Available Subtitles:</h4>
<div id="subtitleList">
<!-- Subtitle files will be loaded here -->
</div>
</div>

<div class="vlc-player-area" id="mpvPlayerArea">
<div class="vlc-loading" id="mpvLoading">
<i class="fas fa-spinner"></i>
<span>Loading</span>
</div>
</div>

<div class="vlc-controls" id="mpvControls" style="display: none;">
    <button class="vlc-btn secondary" id="copyStreamBtn">
        <i class="fas fa-copy"></i> Copy Link
    </button>
    <button class="vlc-btn" id="playNowBtn">
        <i class="fas fa-play"></i> Play Now
    </button>
    <button class="vlc-btn" id="openMPVBtn">
        <i class="fas fa-external-link-alt"></i> Open in MPV
    </button>
    <button class="vlc-btn" id="openVLCBtn">
        <i class="fas fa-external-link-alt"></i> Open in VLC
    </button>
</div>
</div>
</div>

<!-- Custom Video Player -->
<div class="custom-player-container" id="customPlayerContainer">
<div class="player-header">
<div class="player-title" id="customPlayerTitle">
<i class="fas fa-play-circle"></i>
<span>Custom Player</span> <span class="source-badge webtorrent" id="customSourceBadge" title="Streaming source">WebTorrent</span>
</div>
<button class="close-player-btn" id="closeCustomPlayer" title="Close Player (Esc)">
    <i class="fas fa-times"></i> Close
</button>
</div>


<div class="video-container" id="videoContainer">
<video class="custom-video video-js" id="customVideo" preload="metadata">
<source id="videoSource" src="" type="video/mp4">
Your browser does not support the video tag.
</video>

<div class="loading-overlay" id="loadingOverlay">
<i class="fas fa-spinner"></i>
<span>Loading video...</span>
</div>

<div class="subtitle-display" id="subtitleDisplay"></div>

<div class="video-controls" id="videoControls">
<div class="progress-container">
<div class="progress-bar" id="progressBar">
<div class="progress-filled" id="progressFilled"></div>
</div>
<div class="progress-time">
<span id="currentTime">0:00</span>
<span id="totalTime">0:00</span>
</div>
</div>

<div class="control-bar">
    <div class="control-left">
        <button class="control-btn" id="rewindBtn" title="Rewind 10s"><i class="fas fa-backward"></i></button>
        <button class="control-btn play-pause" id="playPauseBtn" title="Play/Pause"><i class="fas fa-play"></i></button>
        <button class="control-btn" id="forwardBtn" title="Forward 10s"><i class="fas fa-forward"></i></button>
    </div>
    <div class="control-right">
        <div class="volume-group">
                <button class="control-btn" id="htmlMuteBtn" title="Mute/Unmute"><i class="fas fa-volume-up"></i></button>
                <input type="range" id="htmlVolume" class="volume-slider" min="0" max="100" value="80" />
        </div>
        <button class="control-btn" id="htmlSubsBtn" title="Subtitles"><i class="fas fa-closed-captioning"></i></button>
        
        <button class="control-btn" id="fullscreenBtn" title="Fullscreen"><i class="fas fa-expand"></i></button>
    </div>
</div>
</div>
</div>
<div class="subs-panel" id="htmlSubsPanel" style="right: 1rem; bottom: 6rem;">
    <div class="subs-header">
        <div>Subtitles</div>
        <div class="menu-actions">
            <button class="menu-refresh" id="htmlSubsClose">Close</button>
        </div>
    </div>
    
    <!-- Upload Section -->
    <div class="subs-upload">
        <input type="file" id="subtitleFile" accept=".srt,.vtt,.ass,.ssa" style="display:none;" />
        <button class="subs-upload-btn" id="htmlSubsUploadBtn">
            <i class="fas fa-upload"></i> Upload Subtitle File
        </button>
    </div>
    
    <!-- Customization Section -->
    <div class="subs-divider"></div>
    <div class="subs-settings">
        <div class="subs-setting-row">
            <label for="subsSize">Size</label>
            <input type="range" id="subsSize" min="12" max="48" value="22">
            <span class="subs-setting-value" id="subsSizeValue">22px</span>
        </div>
        <div class="subs-setting-row">
            <label for="subsColor">Color</label>
            <input type="color" id="subsColor" value="#ffffff">
        </div>
        <div class="subs-setting-row">
            <label for="subsBackground">Background</label>
            <input type="color" id="subsBackground" value="#000000">
        </div>
        <div class="subs-setting-row">
            <label for="subsBackgroundOpacity">BG Opacity</label>
            <input type="range" id="subsBackgroundOpacity" min="0" max="100" value="75">
            <span class="subs-setting-value" id="subsOpacityValue">75%</span>
        </div>
        <div class="subs-setting-row">
            <label for="subsFont">Font</label>
            <select id="subsFont">
                <option value="Arial, sans-serif">Arial</option>
                <option value="'Courier New', monospace">Courier New</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="'Times New Roman', serif">Times New Roman</option>
                <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
                <option value="Verdana, sans-serif">Verdana</option>
                <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
                <option value="Impact, fantasy">Impact</option>
            </select>
        </div>
    </div>
    
    <div class="subs-divider"></div>
    <div class="subs-help">Choose a subtitle. Sources: OpenSubtitles, Wyzie</div>
    <div id="htmlSubsList"></div>
</div>
</div>

<!-- WCJS (WebChimera) Player -->
<div class="wcjs-player-container" id="wcjsPlayerContainer" style="opacity:0;pointer-events:none;">
    <div class="player-header">
        <div class="player-title" id="wcjsPlayerTitle">
            <i class="fas fa-vial"></i>
            <span>WebChimera Player</span>
        </div>
        <div class="player-actions">
            <div class="subtitle-upload">
                <input type="file" id="wcjsSubtitleFile" accept=".srt,.vtt,.ass,.ssa" />
                <label for="wcjsSubtitleFile" class="upload-btn">
                    <i class="fas fa-upload"></i> Upload Subtitles
                </label>
            </div>
            <button class="close-player-btn" id="closeWcjsPlayer">
                <i class="fas fa-times"></i> Close
            </button>
        </div>
    </div>

    <style>
        .wcjs-player-container { position: fixed; inset: 0; background:#000; z-index: 3500; display:flex; flex-direction:column; overflow: hidden; }
        .wcjs-canvas-container { flex: 1; position: relative; background:#000; display:flex; align-items:center; justify-content:center; min-height: 0; min-width: 0; overflow: hidden; }
        #wcjsCanvas { width: 100%; height: 100%; display:block; }
        .wcjs-loading { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; color: var(--vlc-orange); background: rgba(0,0,0,0.8); font-size:1.2rem; }
        .volume-group { display:flex; align-items:center; gap:0.5rem; margin-left: 1rem; }
        .volume-slider { width: 120px; }
    </style>

    <div class="wcjs-canvas-container">
        <canvas id="wcjsCanvas"></canvas>
        <div class="wcjs-loading" id="wcjsLoading" style="display:none;">
            <i class="fas fa-spinner" style="animation: spin 1s linear infinite;"></i>
            <span style="margin-left:0.75rem;">Loading stream...</span>
        </div>
        <div class="video-controls" id="wcjsControls" style="display:block;">
            <div class="progress-container">
                <div class="progress-bar" id="wcjsProgressBar">
                    <div class="progress-filled" id="wcjsProgressFilled"></div>
                </div>
                <div class="progress-time">
                    <span id="wcjsCurrentTime">0:00</span>
                    <span id="wcjsTotalTime">0:00</span>
                </div>
            </div>

            <div class="control-buttons">
                <button class="control-btn" id="wcjsRewindBtn" title="Rewind 10s"><i class="fas fa-backward"></i></button>
                <button class="control-btn play-pause" id="wcjsPlayPauseBtn" title="Play/Pause"><i class="fas fa-play"></i></button>
                <button class="control-btn" id="wcjsForwardBtn" title="Forward 10s"><i class="fas fa-forward"></i></button>
                <div class="volume-group">
                    <button class="control-btn" id="wcjsMuteBtn" title="Mute/Unmute"><i class="fas fa-volume-up"></i></button>
                    <input type="range" id="wcjsVolume" class="volume-slider" min="0" max="100" value="80" />
                </div>
                <button class="control-btn" id="wcjsSubsBtn" title="Subtitles"><i class="fas fa-closed-captioning"></i></button>
                <button class="control-btn" id="wcjsAudioBtn" title="Audio Tracks"><i class="fas fa-headphones"></i></button>
                <button class="control-btn fullscreen-btn" id="wcjsFullscreenBtn" title="Fullscreen"><i class="fas fa-expand"></i></button>
            </div>
        </div>
    </div>
    <div class="subs-panel" id="wcjsSubsPanel">
        <div class="subs-header">
            <div>Subtitles</div>
            <div class="menu-actions">
                <button class="menu-refresh" id="wcjsSubsRefresh">Refresh</button>
                <button class="menu-refresh" id="wcjsSubsClose">Close</button>
            </div>
        </div>
        <div class="subs-help">Choose a subtitle. Sources: OpenSubtitles, Wyzie</div>
        <div id="wcjsSubsList"></div>
    </div>
    <div class="subs-panel" id="wcjsAudioPanel" style="right: 360px;">
        <div class="subs-header">
            <div>Audio Tracks</div>
            <div class="menu-actions">
                <button class="menu-refresh" id="wcjsAudioClose">Close</button>
            </div>
        </div>
        <div id="wcjsAudioList"></div>
    </div>
</div>

<!-- Notification -->
<div class="notification" id="notification">Action completed!</div>

<!-- EPUB Download Modal -->
<div id="epubDownloadModal" class="epub-download-modal" style="display: none;">
    <div class="epub-modal-content">
        <div class="epub-modal-header">
            <h3><i class="fas fa-download"></i> Download EPUB Book</h3>
            <button class="epub-modal-close" onclick="closeEpubDownloadModal()">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="epub-modal-body">
            <div class="epub-download-instruction">
                <p><strong>Please download the EPUB file to this exact location:</strong></p>
                <div class="epub-path-container">
                    <code id="epubDownloadPath"></code>
                    <button class="copy-path-btn" onclick="copyEpubPath()">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
                <p class="epub-note">After downloading, the book will automatically appear in your Library tab.</p>
            </div>
            <div class="epub-modal-actions">
                <button class="epub-download-btn" onclick="openDownloadLink()">
                    <i class="fas fa-external-link-alt"></i>
                    Download from Browser
                </button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<!-- Video.js JavaScript -->
<script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>
<script>
        // UI Mode Management
        let currentUIMode = localStorage.getItem('uiMode') || 'new';
        
        // Apply UI mode on page load
        function applyUIMode(mode) {
            currentUIMode = mode;
            document.body.classList.remove('ui-old', 'ui-new');
            document.body.classList.add(`ui-${mode}`);
            localStorage.setItem('uiMode', mode);
        }
        
        // Initialize UI mode immediately (before DOM loads)
        applyUIMode(currentUIMode);
        
        // Theme Management
        const themes = {
            'default': {
                primary: '#2a1847',
                secondary: '#8b5cf6',
                tertiary: '#c084fc',
                dark: '#120a1f',
                light: '#f8f9fa',
                gray: '#6c757d',
                accent: '#a855f7',
                cardBg: '#2a1847',
                modalBg: 'linear-gradient(135deg, #2a1847, #120a1f)',
                headerBg: '#2a1847',
                inputBg: 'rgba(255, 255, 255, 0.1)',
                hoverBg: 'rgba(168, 85, 247, 0.2)'
            },
            'green-forest': {
                primary: '#1a3a2e',
                secondary: '#4caf50',
                tertiary: '#81c784',
                dark: '#0f1e17',
                light: '#f1f8f4',
                gray: '#6c8073',
                accent: '#66bb6a',
                cardBg: '#1e4d3a',
                modalBg: 'linear-gradient(135deg, #1a3a2e, #0f1e17)',
                headerBg: '#1a3a2e',
                inputBg: 'rgba(76, 175, 80, 0.15)',
                hoverBg: 'rgba(76, 175, 80, 0.25)'
            },
            'cyberpunk-neon': {
                primary: '#1a1a2e',
                secondary: '#ff00ff',
                tertiary: '#00ffff',
                dark: '#0f0f1e',
                light: '#f0f0ff',
                gray: '#7070a0',
                accent: '#ff00aa',
                cardBg: '#252540',
                modalBg: 'linear-gradient(135deg, #1a1a2e, #0f0f1e)',
                headerBg: '#1a1a2e',
                inputBg: 'rgba(255, 0, 255, 0.15)',
                hoverBg: 'rgba(255, 0, 255, 0.3)'
            },
            'ocean-breeze': {
                primary: '#1e3a5f',
                secondary: '#2196f3',
                tertiary: '#64b5f6',
                dark: '#0d1f36',
                light: '#e3f2fd',
                gray: '#607d8b',
                accent: '#42a5f5',
                cardBg: '#2a4a6f',
                modalBg: 'linear-gradient(135deg, #1e3a5f, #0d1f36)',
                headerBg: '#1e3a5f',
                inputBg: 'rgba(33, 150, 243, 0.15)',
                hoverBg: 'rgba(33, 150, 243, 0.25)'
            },
            'cherry-blossom': {
                primary: '#4a2545',
                secondary: '#ff4081',
                tertiary: '#ff80ab',
                dark: '#1a0e1a',
                light: '#fff0f5',
                gray: '#8e7a8b',
                accent: '#f48fb1',
                cardBg: '#5a3555',
                modalBg: 'linear-gradient(135deg, #4a2545, #1a0e1a)',
                headerBg: '#4a2545',
                inputBg: 'rgba(255, 64, 129, 0.15)',
                hoverBg: 'rgba(255, 64, 129, 0.25)'
            },
            'midnight-dark': {
                primary: '#1c1c2e',
                secondary: '#6366f1',
                tertiary: '#818cf8',
                dark: '#0a0a14',
                light: '#e0e7ff',
                gray: '#64748b',
                accent: '#7c3aed',
                cardBg: '#2a2a40',
                modalBg: 'linear-gradient(135deg, #1c1c2e, #0a0a14)',
                headerBg: '#1c1c2e',
                inputBg: 'rgba(99, 102, 241, 0.15)',
                hoverBg: 'rgba(99, 102, 241, 0.25)'
            },
            'sunset-orange': {
                primary: '#3d2a1f',
                secondary: '#ff9800',
                tertiary: '#ffb74d',
                dark: '#1a0f0a',
                light: '#fff3e0',
                gray: '#8d6e63',
                accent: '#fb8c00',
                cardBg: '#4d3a2f',
                modalBg: 'linear-gradient(135deg, #3d2a1f, #1a0f0a)',
                headerBg: '#3d2a1f',
                inputBg: 'rgba(255, 152, 0, 0.15)',
                hoverBg: 'rgba(255, 152, 0, 0.25)'
            }
        };
        
        let currentTheme = localStorage.getItem('appTheme') || 'default';
        
        function applyTheme(themeName) {
            const theme = themes[themeName] || themes['default'];
            const root = document.documentElement;
            
            // Base colors
            root.style.setProperty('--primary', theme.primary);
            root.style.setProperty('--secondary', theme.secondary);
            root.style.setProperty('--tertiary', theme.tertiary);
            root.style.setProperty('--dark', theme.dark);
            root.style.setProperty('--light', theme.light);
            root.style.setProperty('--gray', theme.gray);
            root.style.setProperty('--vlc-orange', theme.accent);
            
            // Extended colors for comprehensive theming
            root.style.setProperty('--card-bg', theme.cardBg);
            root.style.setProperty('--modal-bg', theme.modalBg);
            root.style.setProperty('--header-bg', theme.headerBg);
            root.style.setProperty('--input-bg', theme.inputBg);
            root.style.setProperty('--hover-bg', theme.hoverBg);
            
            currentTheme = themeName;
            localStorage.setItem('appTheme', themeName);
        }
        
        // Initialize theme immediately
        applyTheme(currentTheme);
        
        // API configuration
        const TMDB_API_KEY = 'b3556f3b206e16f82df4d1f6fd4545e6';
        const API_BASE_URL = 'http://localhost:3000/api';
        
        // Streaming Settings (Global)
        let useStreamingServers = localStorage.getItem('useStreamingServers') === 'true';
        let selectedServer = localStorage.getItem('selectedServer') || 'Videasy';
        
        console.log('[DEBUG] JavaScript loaded, useStreamingServers:', useStreamingServers);
        
        // DOM elements - Home
        const moviesGrid = document.getElementById('moviesGrid');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const homePageEl = document.getElementById('homePage');

        // DOM elements - Genres
        const genresBtn = document.getElementById('genresBtn');
        const genresPageEl = document.getElementById('genresPage');
        const genresGrid = document.getElementById('genresGrid');
        const genresLoading = document.getElementById('genresLoading');

        // DOM elements - Genre Details
        const genreDetailsPageEl = document.getElementById('genreDetailsPage');
        const genreTitleEl = document.getElementById('genreTitle');
        const toggleMoviesBtn = document.getElementById('toggleMovies');
        const toggleTVBtn = document.getElementById('toggleTV');
        const genreResultsGrid = document.getElementById('genreResultsGrid');
        const genreLoadingIndicator = document.getElementById('genreLoadingIndicator');
        const genreEmptyMessage = document.getElementById('genreEmptyMessage');

        // DOM elements - Modal and others
        const detailsModal = document.getElementById('detailsModal');
        const modalClose = document.getElementById('modalClose');
        const modalBackdrop = document.getElementById('modalBackdrop');
        const modalPoster = document.getElementById('modalPoster');
        const modalTitle = document.getElementById('modalTitle');
        const modalRating = document.getElementById('modalRating');
        const modalYear = document.getElementById('modalYear');
        const modalRuntime = document.getElementById('modalRuntime');
        const modalTagline = document.getElementById('modalTagline');
        const modalOverview = document.getElementById('modalOverview');
        const castGrid = document.getElementById('castGrid');
        const similarGrid = document.getElementById('similarGrid');
        const torrentsList = document.getElementById('torrentsList');
        const notification = document.getElementById('notification');
        const watchNowBtn = document.getElementById('watchNowBtn');
        const traktWatchlistBtn = document.getElementById('traktWatchlistBtn');
        const seasonsContainer = document.getElementById('seasonsContainer');
        const seasonSelector = document.getElementById('seasonSelector');
        const episodesGrid = document.getElementById('episodesGrid');
        const refreshTorrents = document.getElementById('refreshTorrents');
        const torrentsContainer = document.getElementById('torrentsContainer');
        const torrentKeywordFilter = document.getElementById('torrentKeywordFilter');
        
        // API Setup Modal elements
        const apiSetupModal = document.getElementById('apiSetupModal');
        const firstTimeApiKey = document.getElementById('firstTimeApiKey');
        const saveFirstTimeApiKey = document.getElementById('saveFirstTimeApiKey');
    const openJackettLinkBtn = document.getElementById('openJackettLink');
        
    // Donate modal removed - no DOM elements
        
        // Discord Modal elements
    const discordModal = document.getElementById('discordModal');
    const discordClose = document.getElementById('discordClose');
    const discordJoinBtn = document.getElementById('discordJoinBtn');
    const discordDontShowBtn = document.getElementById('discordDontShowBtn');
        const discordBtn = document.getElementById('discordBtn');
        
        // Settings Modal elements
        const settingsModal = document.getElementById('settingsModal');
    const clearCacheBtn = document.getElementById('clearCacheBtn');
        const settingsClose = document.getElementById('settingsClose');
        const currentApiKey = document.getElementById('currentApiKey');
        const newApiKey = document.getElementById('newApiKey');
        const saveSettings = document.getElementById('saveSettings');
        const cancelSettings = document.getElementById('cancelSettings');
        const useTorrentlessToggle = document.getElementById('useTorrentlessToggle');
    const jackettUrlInput = document.getElementById('jackettUrl');
    const cacheLocationInput = document.getElementById('cacheLocation');
    const selectCacheBtn = document.getElementById('selectCacheBtn');
    // Debrid controls
    const useDebridToggle = document.getElementById('useDebridToggle');
    const debridProviderSel = document.getElementById('debridProvider');
    const debridStatus = document.getElementById('debridStatus');
    const debridTokenInput = document.getElementById('debridToken');
    const saveDebridTokenBtn = document.getElementById('saveDebridToken');
    const clearDebridTokenBtn = document.getElementById('clearDebridToken');
    const rdClientIdInput = document.getElementById('rdClientId');
    const rdDeviceLoginBtn = document.getElementById('rdDeviceLogin');
    const rdClientIdGroup = document.getElementById('rdClientIdGroup');
    const rdButtons = document.getElementById('rdButtons');
    const rdTokenGroup = document.getElementById('rdTokenGroup');
    const rdTokenButtons = document.getElementById('rdTokenButtons');
    const rdCodePanel = document.getElementById('rdCodePanel');
    const rdUserCodeEl = document.getElementById('rdUserCode');
    const rdVerifyUrlEl = document.getElementById('rdVerifyUrl');
    const rdOpenVerifyBtn = document.getElementById('rdOpenVerify');
    const rdCopyCodeBtn = document.getElementById('rdCopyCode');
    const rdCancelLoginBtn = document.getElementById('rdCancelLogin');
    const rdLoginStatusEl = document.getElementById('rdLoginStatus');
    // AllDebrid controls
    const adSection = document.getElementById('adSection');
    const adStartPinBtn = document.getElementById('adStartPin');
    const adPinPanel = document.getElementById('adPinPanel');
    const adPinCodeEl = document.getElementById('adPinCode');
    const adUserUrlEl = document.getElementById('adUserUrl');
    const adOpenUserUrlBtn = document.getElementById('adOpenUserUrl');
    const adCopyPinBtn = document.getElementById('adCopyPin');
    const adCancelPinBtn = document.getElementById('adCancelPin');
    const adLoginStatusEl = document.getElementById('adLoginStatus');
    const adApiKeyInput = document.getElementById('adApiKey');
    const adSaveApiKeyBtn = document.getElementById('adSaveApiKey');
    const adClearApiKeyBtn = document.getElementById('adClearApiKey');
    // TorBox controls
    const tbSection = document.getElementById('tbSection');
    const tbTokenInput = document.getElementById('tbToken');
    const tbSaveTokenBtn = document.getElementById('tbSaveToken');
    const tbClearTokenBtn = document.getElementById('tbClearToken');
    // Premiumize controls
    const pmSection = document.getElementById('pmSection');
    const pmApiKeyInput = document.getElementById('pmApiKey');
    const pmSaveApiKeyBtn = document.getElementById('pmSaveApiKey');
    const pmClearApiKeyBtn = document.getElementById('pmClearApiKey');
        
    // Trakt controls
    const traktNotConnected = document.getElementById('traktNotConnected');
    const traktConnected = document.getElementById('traktConnected');
    const traktStatus = document.getElementById('traktStatus');
    const traktConnectedStatus = document.getElementById('traktConnectedStatus');
    const traktUsername = document.getElementById('traktUsername');
    const traktLoginBtn = document.getElementById('traktLogin');
    const traktViewWatchlistBtn = document.getElementById('traktViewWatchlist');
    const traktViewHistoryBtn = document.getElementById('traktViewHistory');
    const traktViewStatsBtn = document.getElementById('traktViewStats');
    const traktDisconnectBtn = document.getElementById('traktDisconnect');
    const traktCodePanel = document.getElementById('traktCodePanel');
    const traktUserCodeEl = document.getElementById('traktUserCode');
    const traktVerifyUrlEl = document.getElementById('traktVerifyUrl');
    const traktOpenVerifyBtn = document.getElementById('traktOpenVerify');
    const traktCopyCodeBtn = document.getElementById('traktCopyCode');
    const traktCancelLoginBtn = document.getElementById('traktCancelLogin');
    const traktLoginStatusEl = document.getElementById('traktLoginStatus');
    const traktAutoScrobbleToggle = document.getElementById('traktAutoScrobble');
    const traktScrobbleProgressToggle = document.getElementById('traktScrobbleProgress');
    const traktSyncWatchlistToggle = document.getElementById('traktSyncWatchlist');

        // MPV Player elements
        const mpvPlayerContainer = document.getElementById('mpvPlayerContainer');
        const playerTitle = document.getElementById('mpvPlayerTitle');
        const closePlayerBtn = document.getElementById('closePlayerBtn');
        const fileSelector = document.getElementById('fileSelector');
        const fileList = document.getElementById('fileList');
        const subtitleControls = document.getElementById('subtitleControls');
        const subtitleList = document.getElementById('subtitleList');
        const mpvPlayerArea = document.getElementById('mpvPlayerArea');
        const mpvLoading = document.getElementById('mpvLoading');
    const mpvControls = document.getElementById('mpvControls');
        // Helper: get base filename from a path
        function baseName(p) {
            try { return String(p || '').split(/[\\\/]/).pop(); } catch(_) { return p || ''; }
        }
        const openMPVBtn = document.getElementById('openMPVBtn');
        const openVLCBtn = document.getElementById('openVLCBtn');
        const copyStreamBtn = document.getElementById('copyStreamBtn');
    const playNowBtn = document.getElementById('playNowBtn');
    const streamSourceBadge = document.getElementById('streamSourceBadge');

        // Custom Player elements
        const customPlayerContainer = document.getElementById('customPlayerContainer');
        const customPlayerTitle = document.getElementById('customPlayerTitle');
    const customSourceBadge = document.getElementById('customSourceBadge');
        const closeCustomPlayer = document.getElementById('closeCustomPlayer');
        const customVideo = document.getElementById('customVideo');
        const videoSource = document.getElementById('videoSource');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const subtitleDisplay = document.getElementById('subtitleDisplay');
        const videoControls = document.getElementById('videoControls');
        const progressBar = document.getElementById('progressBar');
        const progressFilled = document.getElementById('progressFilled');
        const currentTime = document.getElementById('currentTime');
        const totalTime = document.getElementById('totalTime');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const rewindBtn = document.getElementById('rewindBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const subtitleFile = document.getElementById('subtitleFile');
    const htmlMuteBtn = document.getElementById('htmlMuteBtn');
    const htmlVolume = document.getElementById('htmlVolume');
    const htmlSubsBtn = document.getElementById('htmlSubsBtn');
    const htmlSubsPanel = document.getElementById('htmlSubsPanel');
    const htmlSubsList = document.getElementById('htmlSubsList');
    const htmlSubsClose = document.getElementById('htmlSubsClose');
    
    // Subtitle customization elements
    const htmlSubsUploadBtn = document.getElementById('htmlSubsUploadBtn');
    const subsSizeInput = document.getElementById('subsSize');
    const subsSizeValue = document.getElementById('subsSizeValue');
    const subsColorInput = document.getElementById('subsColor');
    const subsBackgroundInput = document.getElementById('subsBackground');
    const subsBackgroundOpacityInput = document.getElementById('subsBackgroundOpacity');
    const subsOpacityValue = document.getElementById('subsOpacityValue');
    const subsFontSelect = document.getElementById('subsFont');
    
    // Subtitle settings
    let subtitleSettings = {
        size: 22,
        color: '#ffffff',
        background: '#000000',
        backgroundOpacity: 75,
        font: 'Arial, sans-serif'
    };

    // WCJS Player elements
    const wcjsPlayerContainer = document.getElementById('wcjsPlayerContainer');
    const wcjsPlayerTitle = document.getElementById('wcjsPlayerTitle');
    const wcjsCanvas = document.getElementById('wcjsCanvas');
    const wcjsLoading = document.getElementById('wcjsLoading');
    const closeWcjsPlayer = document.getElementById('closeWcjsPlayer');
    const wcjsControls = document.getElementById('wcjsControls');
    const wcjsProgressBar = document.getElementById('wcjsProgressBar');
    const wcjsProgressFilled = document.getElementById('wcjsProgressFilled');
    const wcjsCurrentTime = document.getElementById('wcjsCurrentTime');
    const wcjsTotalTime = document.getElementById('wcjsTotalTime');
    const wcjsPlayPauseBtn = document.getElementById('wcjsPlayPauseBtn');
    const wcjsRewindBtn = document.getElementById('wcjsRewindBtn');
    const wcjsForwardBtn = document.getElementById('wcjsForwardBtn');
    const wcjsFullscreenBtn = document.getElementById('wcjsFullscreenBtn');
    const wcjsMuteBtn = document.getElementById('wcjsMuteBtn');
    const wcjsVolume = document.getElementById('wcjsVolume');
    const wcjsSubtitleFile = document.getElementById('wcjsSubtitleFile');
    const wcjsSubsBtn = document.getElementById('wcjsSubsBtn');
    const wcjsAudioBtn = document.getElementById('wcjsAudioBtn');
    const wcjsSubsPanel = document.getElementById('wcjsSubsPanel');
    const wcjsAudioPanel = document.getElementById('wcjsAudioPanel');
    const wcjsSubsList = document.getElementById('wcjsSubsList');
    const wcjsAudioList = document.getElementById('wcjsAudioList');
    const wcjsSubsRefresh = document.getElementById('wcjsSubsRefresh');
    const wcjsSubsClose = document.getElementById('wcjsSubsClose');
    const wcjsAudioClose = document.getElementById('wcjsAudioClose');
        
        // Global variables
    let currentPage = 1; // home page pagination
        let isLoading = false; // route-scoped loading flag
        let currentContent = null;
        let currentMediaType = 'movie';
        let currentMovie = null; // Store current movie/show data for Trakt
        let currentSeason = 1;
        let torrentsLoaded = false;
        let currentTorrentData = null;
        let currentStreamUrl = null;
    let currentSelectedVideoName = null; // track selected torrent file name
        let currentSubtitleUrl = null;
        let currentSubtitles = [];
    let subtitleTrack = null;
    let currentSubtitleFile = null; // filename served under /subtitles to delete on switch
    let selectedProvider = 'jackett'; // Default provider: jackett, torrentio, torrentless, nuvio, comet, 111477, moviebox
    let lastSearchedSeason = null; // Track last searched season for provider switching
    let lastSearchedEpisode = null; // Track last searched episode for provider switching
    
    // Sort and Filter state
    let currentSort = 'popularity'; // popularity, rating, date
    let currentFilter = 'all'; // all, hd, 4k
    let allMoviesCache = []; // Cache for sorting/filtering
    
    // Resume state
    let resumeKey = null; // stable key per item (provider/hash/file or direct link)
    let resumeInfo = null; // { position, duration, updatedAt }
    let resumeTimer = null;
    let lastResumeSend = 0;
    let hasApiKey = false;
    let useTorrentless = false; // global toggle for Torrentless mode
    let useDebrid = false; // global toggle for Debrid
    let debridAuth = false; // token presence depending on provider
    let debridProvider = 'realdebrid';
        let currentCategory = 'all';
        let allTorrents = [];
        let torrentsPage = 1;
        const torrentsPerPage = 20;
        let torrentSortMode = 'seeders'; // 'seeders' | 'size-asc' | 'size-desc'
        let torrentSizeFilter = 'all'; // 'all' | 'gte-1g' | 'gte-2g' | '2-4g' | '4-8g' | 'gte-8g'
        let allNuvioStreams = []; // Cache for Nuvio streams to enable sorting

        // Discord Rich Presence tracking
        let discordStreamingActive = false;
        let discordMusicActive = false;

        // Update Discord presence for streaming
        async function updateDiscordForStreaming(contentTitle, provider = 'PlayTorrio', season = null) {
            if (!window.electronAPI?.updateDiscordPresence) return;
            
            try {
                discordStreamingActive = true;
                
                // For TV shows, append season info (no episode number)
                let displayTitle = contentTitle;
                if (season !== null && season !== undefined) {
                    displayTitle = `${contentTitle} - Season ${season}`;
                }
                
                const details = `Watching: ${displayTitle}`;
                const state = `via ${provider}`;
                
                await window.electronAPI.updateDiscordPresence({
                    details,
                    state,
                    startTimestamp: new Date(),
                    largeImageKey: 'icon',
                    largeImageText: 'PlayTorrio App',
                    smallImageKey: 'play',
                    smallImageText: 'Streaming',
                    buttons: [
                        { label: 'Download App', url: 'https://github.com/ayman707-ux/PlayTorrio' }
                    ]
                });
            } catch (e) {
                console.error('[Discord] Failed to update streaming presence:', e);
            }
        }

        // Update Discord presence for music
        async function updateDiscordForMusic(songTitle, artist, album) {
            if (!window.electronAPI?.updateDiscordPresence) return;
            
            try {
                discordMusicActive = true;
                const details = ` ${songTitle}`;
                const state = artist ? `by ${artist}${album ? ` - ${album}` : ''}` : (album || 'Music');
                
                await window.electronAPI.updateDiscordPresence({
                    details,
                    state,
                    startTimestamp: new Date(),
                    largeImageKey: 'icon',
                    largeImageText: 'PlayTorrio App',
                    smallImageKey: 'music',
                    smallImageText: 'Listening',
                    buttons: [
                        { label: 'Download App', url: 'https://github.com/ayman707-ux/PlayTorrio' }
                    ]
                });
            } catch (e) {
                console.error('[Discord] Failed to update music presence:', e);
            }
        }

        // Clear Discord presence
        async function clearDiscordPresence() {
            if (!window.electronAPI?.clearDiscordPresence) return;
            
            try {
                discordStreamingActive = false;
                discordMusicActive = false;
                await window.electronAPI.clearDiscordPresence();
            } catch (e) {
                console.error('[Discord] Failed to clear presence:', e);
            }
        }

        // Cache for filename -> TMDB lookup
        const filenameTmdbCache = new Map();

        // Parse title/season/episode from a torrent filename
        function parseFromFilename(name = '') {
            try {
                const base = String(name).replace(/\.[^.]+$/,'');
                const cleaned = base
                    .replace(/[\[\(].*?[\)\]]/g, ' ')
                    .replace(/[_]+/g,' ')
                    .replace(/\s{2,}/g,' ')
                    .trim();
                const patterns = [
                    { re: /(s)(\d{1,2})[ ._-]*e(\d{1,3})/i, season: 2, episode: 3 },
                    { re: /\b(\d{1,2})[xX](\d{1,3})\b/, season: 1, episode: 2 },
                    { re: /\b(\d{1,2})[ ._-]+(\d{1,2})\b/, season: 1, episode: 2 },
                ];
                let season = null, episode = null, title = cleaned, m = null, idx = -1;
                for (const p of patterns) {
                    const mm = cleaned.match(p.re);
                    if (mm) {
                        const sVal = parseInt(mm[p.season], 10);
                        const eVal = parseInt(mm[p.episode], 10);
                        if (!isNaN(sVal) && !isNaN(eVal) && sVal <= 99 && eVal <= 999) {
                            season = sVal; episode = eVal; m = mm; idx = mm.index; break;
                        }
                    }
                }
                if (m && idx >= 0) title = cleaned.slice(0, idx).replace(/[-_.]+$/,'').trim();
                title = title
                    .replace(/\b(\d{3,4}p|4k|bluray|web[- ]?dl|webrip|bdrip|hdr|dv|x264|x265|hevc|h264)\b/ig, '')
                    .replace(/\s{2,}/g,' ')
                    .trim();
                const type = season && episode ? 'tv' : 'movie';
                return { title, season, episode, type };
            } catch { return { title: '', season: null, episode: null, type: 'movie' }; }
        }

        async function getTmdbFromFilename(filename) {
            if (!filename) return null;
            if (filenameTmdbCache.has(filename)) return filenameTmdbCache.get(filename);
            const parsed = parseFromFilename(filename);
            const result = { id: null, type: parsed.type, season: parsed.season, episode: parsed.episode, title: parsed.title };
            if (!parsed.title) { filenameTmdbCache.set(filename, result); return result; }
            try {
                const endpoint = parsed.type === 'tv' ? 'search/tv' : 'search/movie';
                const url = `https://api.themoviedb.org/3/${endpoint}?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(parsed.title)}`;
                const resp = await fetch(url);
                if (resp.ok) {
                    const data = await resp.json();
                    const items = Array.isArray(data.results) ? data.results : [];
                    if (items.length) {
                        result.id = items[0].id;
                    }
                }
            } catch {}
            filenameTmdbCache.set(filename, result);
            return result;
        }

        // Routing and genres state
        let activeRoute = 'home';
        let genresMap = new Map(); // nameLower -> { name, movieId?, tvId? }
        let genresLoaded = false;
        let currentGenre = null; // {name, movieId?, tvId?}
        let currentGenreType = 'movie'; // 'movie' | 'tv'
        let genreCurrentPage = 1;

        // Initialize the app
        function initializeCast() {
            // Wait for Cast SDK to load
            window['__onGCastApiAvailable'] = function(isAvailable) {
                if (isAvailable) {
                    try {
                        const castContext = window.cast.framework.CastContext.getInstance();
                        castContext.setOptions({
                            receiverApplicationId: window.chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
                            autoJoinPolicy: window.chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
                        });
                        console.log('Google Cast initialized successfully');
                    } catch (error) {
                        console.error('Error initializing Cast:', error);
                    }
                }
            };
        }

        async function init() {
            await checkApiKeyStatus();
            await ensureDebridState();
            setupEventListeners();
            initIptvSourceSelector(); // Initialize IPTV dropdown
            initializeBookTorrio(); // Initialize BookTorrio functionality
            initializeAnime(); // Initialize Anime functionality
            initializeManga(); // Initialize Manga functionality
            initializeSettingsTabs(); // Initialize settings page tab switching
            setWindowsUsername(); // Set Windows username in sidebar
            handleRoute(); // route-aware initial load
            checkUpdateAnnouncement(); // Show update modal on first launch
            checkDiscordPrompt(); // Show Discord modal if user hasn't joined
            initializeCast(); // Initialize Google Cast SDK
        }
        
        // Set Windows username from temp directory path
        function setWindowsUsername() {
            const usernameEl = document.getElementById('windowsUsername');
            if (usernameEl) {
                try {
                    // Try to get username from electron API first
                    if (window.electronAPI && window.electronAPI.getUsername) {
                        window.electronAPI.getUsername().then(result => {
                            if (result.success && result.username) {
                                usernameEl.textContent = result.username;
                            }
                        }).catch(() => {
                            // Fallback to extracting from temp path
                            fallbackUsernameExtraction(usernameEl);
                        });
                    } else {
                        // Fallback to extracting from temp path
                        fallbackUsernameExtraction(usernameEl);
                    }
                } catch (error) {
                    console.error('Error getting username:', error);
                }
            }
        }
        
        // Fallback method to extract username from localStorage or other sources
        function fallbackUsernameExtraction(usernameEl) {
            // Try to extract from previously stored cache location or temp directory
            const cacheLocation = localStorage.getItem('cacheLocation');
            if (cacheLocation && cacheLocation.includes('Users\\')) {
                const match = cacheLocation.match(/Users\\([^\\]+)/);
                if (match && match[1]) {
                    usernameEl.textContent = match[1];
                    return;
                }
            }
            // If no cache location, try to get it from API
            fetch(`${API_BASE_URL}/settings`).then(res => res.json()).then(settings => {
                if (settings.cacheLocation && settings.cacheLocation.includes('Users\\')) {
                    const match = settings.cacheLocation.match(/Users\\([^\\]+)/);
                    if (match && match[1]) {
                        usernameEl.textContent = match[1];
                    }
                }
            }).catch(() => {});
        }
        
        // Check if user has joined Discord and show modal if not
        function checkDiscordPrompt() {
            const hasJoinedDiscord = localStorage.getItem('hasJoinedDiscord');
            if (!hasJoinedDiscord) {
                // Wait a bit for the page to fully load before showing the discord modal
                setTimeout(() => {
                    showDiscordModal();
                }, 1000);
            }
        }

        // Show Discord modal
        function showDiscordModal() {
            if (discordModal) {
                discordModal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }
        
        // Hide Discord modal
        function hideDiscordModal() {
            if (discordModal) {
                discordModal.classList.remove('active');
                document.body.style.overflow = 'auto';
            }
        }
        
        // Show Update modal
        function showUpdateModal() {
            const updateModal = document.getElementById('updateModal');
            if (updateModal) {
                updateModal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }
        
        // Hide Update modal
        function hideUpdateModal() {
            const updateModal = document.getElementById('updateModal');
            if (updateModal) {
                updateModal.classList.remove('active');
                document.body.style.overflow = 'auto';
            }
        }
        
        // Check if user has seen the update announcement
        function checkUpdateAnnouncement() {
            // Update key for v1.5.3 so existing users see the new notes
            const hasSeenUpdate = localStorage.getItem('hasSeenUpdate_v153');
            if (!hasSeenUpdate) {
                // Wait a bit for the page to fully load before showing the update modal
                setTimeout(() => {
                    showUpdateModal();
                    localStorage.setItem('hasSeenUpdate_v153', 'true');
                }, 1500);
            }
        }
        
        // Check if this is the first launch and show donate modal
        function checkFirstLaunch() {
            const hasSeenDonateModal = localStorage.getItem('hasSeenDonateModal');
            if (!hasSeenDonateModal) {
                // Wait a bit for the page to fully load before showing the donate modal
                setTimeout(() => {
                    showDonateModal();
                    localStorage.setItem('hasSeenDonateModal', 'true');
                }, 500);
            }
        }

        // v1.6.3 modal controls
        function showVersion163Modal() {
            const modal = document.getElementById('version163Modal');
            if (modal) {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }
        function hideVersion163Modal() {
            const modal = document.getElementById('version163Modal');
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = 'auto';
            }
        }

        // Get provider display name for notifications and UI
        function getProviderDisplayName(provider) {
            switch(provider) {
                case 'alldebrid': return 'AllDebrid';
                case 'torbox': return 'TorBox';
                case 'premiumize': return 'Premiumize';
                case 'realdebrid':
                default: return 'RealDebrid';
            }
        }

        // Ensure debrid flags are loaded at startup and before streaming
        async function ensureDebridState() {
            try {
                const r = await fetch(`${API_BASE_URL}/settings`);
                if (r.ok) {
                    const s = await r.json();
                    useDebrid = !!s.useDebrid;
                    debridAuth = !!s.debridAuth;
                    debridProvider = s.debridProvider || 'realdebrid';
                    console.log('[UI][Debrid] state', { useDebrid, debridAuth, debridProvider });
                }
            } catch (e) { console.warn('[UI][Debrid] state load failed', e?.message); }
        }
        
        // Check API key status
        async function checkApiKeyStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/check-api-key`);
                const data = await response.json();
                hasApiKey = data.hasApiKey;
                useTorrentless = !!data.useTorrentless;
                if (!hasApiKey && !useTorrentless) {
                    showApiSetupModal();
                } else {
                    await loadCurrentApiKey();
                    hideApiSetupModal();
                }
            } catch (error) {
                console.error('Error checking API key status:', error);
                // If server is not up yet, still prompt the user to install Jackett / set API key
                showApiSetupModal();
                showNotification('Local server not ready. Enter Jackett key or choose Watch without Jackett.');
            }
        }
        
        // Load current API key for display
        async function loadCurrentApiKey() {
            try {
                const response = await fetch(`${API_BASE_URL}/get-api-key`);
                const data = await response.json();
                
                const text = data.hasApiKey ? `Current: ${data.apiKey}` : 'No API key configured';
                // Update ALL elements with id currentApiKey (there are duplicates)
                document.querySelectorAll('#currentApiKey').forEach(el => {
                    el.textContent = text;
                });
            } catch (error) {
                console.error('Error loading current API key:', error);
                // Also fetch debrid settings for global flags
                try {
                    const sres = await fetch(`${API_BASE_URL}/settings`);
                    if (sres.ok) {
                        const s = await sres.json();
                        useDebrid = !!s.useDebrid;
                        debridAuth = !!s.debridAuth;
                    }
                } catch(_) {}
                document.querySelectorAll('#currentApiKey').forEach(el => {
                    el.textContent = 'Error loading API key';
                });
            }
        }
        
        // Show API setup modal
        function showApiSetupModal() {
            apiSetupModal.classList.add('active');
            document.body.style.overflow = 'hidden';
            // Notify user to install Jackett and provide API key, or use Torrentless
            showNotification('Enter Jackett API key or choose Watch without Jackett (fewer sources, slower buffering).');
        }
        
        // Hide API setup modal
        function hideApiSetupModal() {
            apiSetupModal.classList.remove('active');
            document.body.style.overflow = 'auto';
        }
        
        // Donate modal functionality removed
        
        // Show settings modal
        async function showSettingsModal() {
            // Navigate to settings page instead of showing modal
            window.location.hash = '#/settings';
        }
        
        // Load all settings data
        async function loadSettingsData() {
            await loadCurrentApiKey();
            
            // Clear API key input for ALL instances
            const newApiKeyElements = document.querySelectorAll('#newApiKey');
            newApiKeyElements.forEach(input => {
                input.value = '';
            });
            
            // Load UI mode setting for ALL instances
            const uiModeNewElements = document.querySelectorAll('#uiModeNew');
            const uiModeOldElements = document.querySelectorAll('#uiModeOld');
            
            uiModeNewElements.forEach(el => {
                if (currentUIMode === 'new') {
                    el.checked = true;
                }
            });
            uiModeOldElements.forEach(el => {
                if (currentUIMode === 'old') {
                    el.checked = true;
                }
            });
            
            // Load theme setting for ALL instances
            const themeSelectors = document.querySelectorAll('#themeSelector');
            themeSelectors.forEach(themeSelector => {
                if (themeSelector) {
                    themeSelector.value = currentTheme;
                }
            });
            
            // Load fullscreen setting for ALL instances
            const fullscreenToggles = document.querySelectorAll('#fullscreenToggle');
            
            // Check Trakt authentication status
            await checkTraktStatus();
            if (fullscreenToggles.length > 0 && window.electronAPI && window.electronAPI.getFullscreen) {
                try {
                    const result = await window.electronAPI.getFullscreen();
                    if (result.success) {
                        fullscreenToggles.forEach(toggle => {
                            toggle.checked = result.isFullscreen;
                        });
                    }
                } catch (error) {
                    console.error('Error loading fullscreen state:', error);
                }
            }
            
                    // Load useTorrentless setting state for ALL instances
            try {
                const res = await fetch(`${API_BASE_URL}/settings`);
                if (res.ok) {
                    const s = await res.json();
                    console.log('[Settings] Loaded settings:', s);
                    useTorrentless = !!s.useTorrentless;
                            // AutoUpdater toggle (default ON if missing)
                            const autoUpdate = s.autoUpdate !== false; // treat undefined as true
                            const autoUpdateToggles = document.querySelectorAll('#autoUpdateToggle');
                            autoUpdateToggles.forEach(t => { t.checked = !!autoUpdate; });
                    
                    const useTorrentlessToggles = document.querySelectorAll('#useTorrentlessToggle');
                    useTorrentlessToggles.forEach(toggle => {
                        toggle.checked = useTorrentless;
                    });
                    // Load torrent source preference (default to 'torrentio')
                    const currentSource = s.torrentSource || 'torrentio';
                    console.log('[Settings] Set torrent source to:', currentSource);
                    
                    // Update button states for ALL instances
                    const torrentioBtns = document.querySelectorAll('#torrentioBtn');
                    const inAppScraperBtns = document.querySelectorAll('#inAppScraperBtn');
                    if (torrentioBtns.length > 0 && inAppScraperBtns.length > 0) {
                        if (currentSource === 'torrentio') {
                            torrentioBtns.forEach(btn => btn.classList.add('active'));
                            inAppScraperBtns.forEach(btn => btn.classList.remove('active'));
                        } else {
                            torrentioBtns.forEach(btn => btn.classList.remove('active'));
                            inAppScraperBtns.forEach(btn => btn.classList.add('active'));
                        }
                    }
                    // Load Jackett URL for ALL instances
                    const jackettUrlElements = document.querySelectorAll('#jackettUrl');
                    if (jackettUrlElements.length > 0 && s.jackettUrl) {
                        jackettUrlElements.forEach(input => {
                            input.value = s.jackettUrl;
                        });
                    }
                    // Load cache location for ALL instances
                    const cacheLocationElements = document.querySelectorAll('#cacheLocation');
                    if (cacheLocationElements.length > 0 && s.cacheLocation) {
                        cacheLocationElements.forEach(input => {
                            input.value = s.cacheLocation;
                        });
                    }
                    // Debrid: populate form for ALL instances
                    const useDebridToggles = document.querySelectorAll('#useDebridToggle');
                    if (useDebridToggles.length > 0 && s.useDebrid !== undefined) {
                        useDebridToggles.forEach(toggle => {
                            toggle.checked = !!s.useDebrid;
                        });
                    }
                    
                    const prov = s.debridProvider || 'realdebrid';
                    const debridProviders = document.querySelectorAll('#debridProvider');
                    debridProviders.forEach(select => {
                        select.value = prov;
                    });
                    
                    const debridStatuses = document.querySelectorAll('#debridStatus');
                    debridStatuses.forEach(status => {
                        status.textContent = s.debridAuth ? 'Logged in' : 'Not logged in';
                    });
                    
                    // Load rdClientId for ALL instances
                    const rdClientIdInputs = document.querySelectorAll('#rdClientId');
                    if (rdClientIdInputs.length > 0 && s.rdClientId) {
                        rdClientIdInputs.forEach(input => {
                            input.value = s.rdClientId;
                        });
                    }
                    
                    useDebrid = !!s.useDebrid; debridAuth = !!s.debridAuth;
                    // Toggle provider-specific UI for ALL instances
                    const isRD = prov === 'realdebrid';
                    const isAD = prov === 'alldebrid';
                    const isTB = prov === 'torbox';
                    const isPM = prov === 'premiumize';
                    
                    document.querySelectorAll('#rdClientIdGroup').forEach(el => el.style.display = isRD ? '' : 'none');
                    document.querySelectorAll('#rdButtons').forEach(el => el.style.display = isRD ? '' : 'none');
                    document.querySelectorAll('#rdTokenGroup').forEach(el => el.style.display = isRD ? '' : 'none');
                    document.querySelectorAll('#rdTokenButtons').forEach(el => el.style.display = isRD ? '' : 'none');
                    document.querySelectorAll('#rdCodePanel').forEach(el => el.style.display = 'none');
                    document.querySelectorAll('#adSection').forEach(el => el.style.display = isAD ? '' : 'none');
                    document.querySelectorAll('#tbSection').forEach(el => el.style.display = isTB ? '' : 'none');
                    document.querySelectorAll('#pmSection').forEach(el => el.style.display = isPM ? '' : 'none');
                }
            } catch(_) {}
        }
        
        // Hide settings modal
        function hideSettingsModal() {
            settingsModal.classList.remove('active');
            document.body.style.overflow = 'auto';
        }
        
        // Settings Page Tab Switching
        function initializeSettingsTabs() {
            const settingsTabs = document.querySelectorAll('.settings-tab');
            const settingsSections = document.querySelectorAll('.settings-section');
            
            settingsTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetSection = tab.getAttribute('data-section');
                    
                    // Remove active class from all tabs and sections
                    settingsTabs.forEach(t => t.classList.remove('active'));
                    settingsSections.forEach(s => s.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding section
                    tab.classList.add('active');
                    const targetElement = document.getElementById(`${targetSection}Content`);
                    if (targetElement) {
                        targetElement.classList.add('active');
                    }
                });
            });
        }
        
        // Save API key (first time setup)
        async function saveFirstTimeApiKey_() {
            const apiKey = firstTimeApiKey.value.trim();
            
            if (!apiKey) {
                showNotification('Please enter an API key');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE_URL}/set-api-key`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ apiKey })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    hasApiKey = true;
                    hideApiSetupModal();
                    showNotification('API key saved successfully!');
                    await loadCurrentApiKey();
                } else {
                    showNotification(data.error || 'Failed to save API key');
                }
            } catch (error) {
                console.error('Error saving API key:', error);
                showNotification('Error saving API key');
            }
        }

        // ===== TRAKT FUNCTIONS =====

        let traktPollingInterval = null;
        let traktCurrentScrobble = null;

        // Parse media title to extract info for Trakt
        function parseMediaTitle(title) {
            if (!title) return { title: 'Unknown', type: 'movie', year: null };

            // Clean up the title
            let cleanTitle = title
                .replace(/\.(mkv|mp4|avi|mov|wmv|flv|webm)$/i, '') // Remove file extensions
                .replace(/\.(720p|1080p|4k|2160p|480p|hdtv|bdrip|webrip|dvdrip|cam|ts|hdrip)/gi, '') // Remove quality tags
                .replace(/\.(x264|x265|h264|h265|xvid|divx)/gi, '') // Remove codec tags
                .replace(/\.(aac|ac3|dts|mp3|flac)/gi, '') // Remove audio tags
                .replace(/[\[\]()]/g, ' ') // Remove brackets
                .replace(/\b(repack|proper|real|retail|uncut|unrated|extended|directors?\.cut)\b/gi, '') // Remove release tags
                .trim();

            // Check if it's a TV show (contains S##E## or Season/Episode patterns)
            const tvPatterns = [
                /(.+?)[\s\.]S(\d{1,2})E(\d{1,2})/i, // Title S01E01
                /(.+?)[\s\.]Season[\s\.](\d{1,2})[\s\.]Episode[\s\.](\d{1,2})/i, // Title Season 1 Episode 1
                /(.+?)[\s\.](\d{1,2})x(\d{1,2})/i, // Title 1x01
            ];

            for (const pattern of tvPatterns) {
                const match = cleanTitle.match(pattern);
                if (match) {
                    const showTitle = match[1].trim().replace(/[.\-_]/g, ' ');
                    const season = parseInt(match[2]);
                    const episode = parseInt(match[3]);
                    
                    // Extract year if present
                    const yearMatch = showTitle.match(/\b(19\d{2}|20\d{2})\b/);
                    const year = yearMatch ? parseInt(yearMatch[1]) : null;
                    const titleWithoutYear = showTitle.replace(/\b(19\d{2}|20\d{2})\b/, '').trim();

                    return {
                        title: titleWithoutYear || showTitle,
                        type: 'show',
                        year: year,
                        season: season,
                        episode: episode
                    };
                }
            }

            // If not a TV show, treat as movie
            const yearMatch = cleanTitle.match(/\b(19\d{2}|20\d{2})\b/);
            const year = yearMatch ? parseInt(yearMatch[1]) : null;
            const titleWithoutYear = cleanTitle.replace(/\b(19\d{2}|20\d{2})\b/, '').trim();

            return {
                title: titleWithoutYear || cleanTitle,
                type: 'movie',
                year: year
            };
        }

        // Check Trakt authentication status
        async function checkTraktStatus() {
            try {
                const response = await fetch('/api/trakt/status');
                const data = await response.json();
                
                if (data.authenticated && data.user) {
                    showTraktConnected(data.user);
                } else {
                    showTraktDisconnected();
                }
            } catch (error) {
                console.error('[TRAKT] Status check failed:', error);
                showTraktDisconnected();
            }
        }

        function showTraktConnected(user) {
            // Update ALL instances of Trakt status elements
            const traktNotConnectedEls = document.querySelectorAll('#traktNotConnected');
            const traktConnectedEls = document.querySelectorAll('#traktConnected');
            const traktUsernameEls = document.querySelectorAll('#traktUsername');
            const traktStatusEls = document.querySelectorAll('#traktStatus');
            
            traktNotConnectedEls.forEach(el => el.style.display = 'none');
            traktConnectedEls.forEach(el => el.style.display = 'block');
            traktUsernameEls.forEach(el => el.textContent = user.username || user.name || 'User');
            traktStatusEls.forEach(el => {
                el.innerHTML = '<i class="fas fa-check-circle"></i> Connected';
                el.style.color = '#198754';
            });
        }

        function showTraktDisconnected() {
            // Update ALL instances of Trakt status elements
            const traktNotConnectedEls = document.querySelectorAll('#traktNotConnected');
            const traktConnectedEls = document.querySelectorAll('#traktConnected');
            const traktStatusEls = document.querySelectorAll('#traktStatus');
            
            traktNotConnectedEls.forEach(el => el.style.display = 'block');
            traktConnectedEls.forEach(el => el.style.display = 'none');
            traktStatusEls.forEach(el => {
                el.innerHTML = '<i class="fas fa-times-circle"></i> Not connected';
                el.style.color = '#dc3545';
            });
        }

        // Start Trakt authentication flow
        async function startTraktLogin() {
            try {
                // Update ALL login buttons
                const traktLoginBtns = document.querySelectorAll('#traktLogin');
                traktLoginBtns.forEach(btn => {
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Connecting...';
                });

                // Get device code
                const response = await fetch('/api/trakt/device-code');
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to get device code');
                }

                // Show the code panel on ALL instances
                const traktCodePanels = document.querySelectorAll('#traktCodePanel');
                const traktUserCodeEls = document.querySelectorAll('#traktUserCode');
                traktCodePanels.forEach(panel => panel.style.display = 'block');
                traktUserCodeEls.forEach(el => el.textContent = data.user_code);
                
                const traktVerifyUrlEls = document.querySelectorAll('#traktVerifyUrl');
                const traktLoginStatusEls = document.querySelectorAll('#traktLoginStatus');
                traktVerifyUrlEls.forEach(el => el.href = data.verification_url);
                traktLoginStatusEls.forEach(el => el.textContent = 'Waiting for authorization');

                // Start polling for token
                startTraktPolling(data.device_code, data.interval || 5);

            } catch (error) {
                console.error('[TRAKT] Login error:', error);
                showNotification('Failed to start Trakt login: ' + error.message, 'error');
                resetTraktLogin();
            }
        }

        function startTraktPolling(deviceCode, interval) {
            if (traktPollingInterval) {
                clearInterval(traktPollingInterval);
            }

            traktPollingInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/trakt/device-token', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ device_code: deviceCode })
                    });

                    const data = await response.json();

                    if (data.success) {
                        // Authentication successful
                        clearInterval(traktPollingInterval);
                        traktPollingInterval = null;
                        traktCodePanel.style.display = 'none';
                        showNotification('Successfully connected to Trakt!', 'success');
                        await checkTraktStatus();
                        resetTraktLogin();
                    } else if (response.status === 400) {
                        // Still waiting for user authorization
                        traktLoginStatusEl.textContent = 'Waiting for authorization';
                    } else if (response.status === 410) {
                        // Code expired
                        clearInterval(traktPollingInterval);
                        traktPollingInterval = null;
                        showNotification('Authorization code expired. Please try again.', 'error');
                        resetTraktLogin();
                    } else if (response.status === 418) {
                        // User denied
                        clearInterval(traktPollingInterval);
                        traktPollingInterval = null;
                        showNotification('Authorization denied by user.', 'error');
                        resetTraktLogin();
                    } else {
                        throw new Error(data.error || 'Unknown error');
                    }
                } catch (error) {
                    console.error('[TRAKT] Polling error:', error);
                    clearInterval(traktPollingInterval);
                    traktPollingInterval = null;
                    showNotification('Authentication failed: ' + error.message, 'error');
                    resetTraktLogin();
                }
            }, interval * 1000);
        }

        function resetTraktLogin() {
            const traktLoginBtns = document.querySelectorAll('#traktLogin');
            const traktCodePanels = document.querySelectorAll('#traktCodePanel');
            
            traktLoginBtns.forEach(btn => {
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-sign-in-alt"></i> Connect to Trakt';
            });
            traktCodePanels.forEach(panel => panel.style.display = 'none');
            
            if (traktPollingInterval) {
                clearInterval(traktPollingInterval);
                traktPollingInterval = null;
            }
        }

        function cancelTraktLogin() {
            resetTraktLogin();
            showNotification('Trakt login cancelled', 'info');
        }

        async function disconnectTrakt() {
            try {
                const response = await fetch('/api/trakt/logout', { method: 'POST' });
                const data = await response.json();

                if (data.success) {
                    showTraktDisconnected();
                    showNotification('Disconnected from Trakt', 'success');
                } else {
                    throw new Error(data.error || 'Failed to logout');
                }
            } catch (error) {
                console.error('[TRAKT] Logout error:', error);
                showNotification('Failed to disconnect: ' + error.message, 'error');
            }
        }

        // Scrobbling functions
        async function scrobbleStart(title, type, year, season, episode, progress = 0) {
            if (!traktAutoScrobbleToggle.checked) return;

            try {
                const response = await fetch('/api/trakt/scrobble/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, type, year, season, episode, progress })
                });

                const data = await response.json();
                if (data.success) {
                    traktCurrentScrobble = { title, type, year, season, episode };
                    console.log('[TRAKT] Started scrobbling:', title);
                } else {
                    console.error('[TRAKT] Scrobble start failed:', data.error);
                }
            } catch (error) {
                console.error('[TRAKT] Scrobble start error:', error);
            }
        }

        async function scrobblePause(progress) {
            if (!traktCurrentScrobble || !traktScrobbleProgressToggle.checked) return;

            try {
                const response = await fetch('/api/trakt/scrobble/pause', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ...traktCurrentScrobble, progress })
                });

                if (response.ok) {
                    console.log('[TRAKT] Paused scrobbling at', progress + '%');
                }
            } catch (error) {
                console.error('[TRAKT] Scrobble pause error:', error);
            }
        }

        async function scrobbleStop(progress) {
            if (!traktCurrentScrobble) return;

            try {
                const response = await fetch('/api/trakt/scrobble/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ...traktCurrentScrobble, progress })
                });

                if (response.ok) {
                    console.log('[TRAKT] Stopped scrobbling at', progress + '%');
                    traktCurrentScrobble = null;
                }
            } catch (error) {
                console.error('[TRAKT] Scrobble stop error:', error);
            }
        }

        // Utility functions
        function copyTraktCode() {
            const code = traktUserCodeEl.textContent;
            navigator.clipboard.writeText(code).then(() => {
                showNotification('Code copied to clipboard!', 'success');
            }).catch(() => {
                showNotification('Failed to copy code', 'error');
            });
        }

        function openTraktVerify() {
            const url = traktVerifyUrlEl.href;
            if (window.electronAPI && window.electronAPI.openExternal) {
                window.electronAPI.openExternal(url);
            } else {
                window.open(url, '_blank');
            }
        }

        // Watchlist management
        async function setupTraktWatchlistButton() {
            if (!traktWatchlistBtn || !currentMovie) return;

            // Check if user is authenticated with Trakt
            try {
                const statusResponse = await fetch('/api/trakt/status');
                const statusData = await statusResponse.json();
                
                if (!statusData.authenticated) {
                    traktWatchlistBtn.style.display = 'none';
                    return;
                }

                traktWatchlistBtn.style.display = 'block';
                
                // Check if item is already in watchlist
                const title = currentMovie.title || currentMovie.name;
                const year = parseInt((currentMovie.release_date || currentMovie.first_air_date || '').substring(0, 4));
                
                // For now, assume it's not in watchlist - could check against API in the future
                updateWatchlistButton(false);
                
            } catch (error) {
                console.error('[TRAKT] Error setting up watchlist button:', error);
                traktWatchlistBtn.style.display = 'none';
            }
        }

        function updateWatchlistButton(isInWatchlist) {
            if (!traktWatchlistBtn) return;

            if (isInWatchlist) {
                traktWatchlistBtn.innerHTML = '<i class="fas fa-check"></i> In Watchlist';
                traktWatchlistBtn.classList.remove('btn-secondary');
                traktWatchlistBtn.classList.add('btn-success');
                traktWatchlistBtn.onclick = removeFromTraktWatchlist;
            } else {
                traktWatchlistBtn.innerHTML = '<i class="fas fa-plus"></i> Add to Watchlist';
                traktWatchlistBtn.classList.remove('btn-success');
                traktWatchlistBtn.classList.add('btn-secondary');
                traktWatchlistBtn.onclick = addToTraktWatchlist;
            }
        }

        async function addToTraktWatchlist() {
            if (!currentMovie) return;

            try {
                traktWatchlistBtn.disabled = true;
                traktWatchlistBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';

                const title = currentMovie.title || currentMovie.name;
                const year = parseInt((currentMovie.release_date || currentMovie.first_air_date || '').substring(0, 4));
                const type = currentMediaType === 'tv' ? 'show' : 'movie';

                const response = await fetch('/api/trakt/watchlist/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, type, year })
                });

                const data = await response.json();
                
                if (data.success) {
                    updateWatchlistButton(true);
                    showNotification(`Added "${title}" to your Trakt watchlist!`, 'success');
                } else {
                    throw new Error(data.error || 'Failed to add to watchlist');
                }
                
            } catch (error) {
                console.error('[TRAKT] Add to watchlist error:', error);
                showNotification('Failed to add to watchlist: ' + error.message, 'error');
                updateWatchlistButton(false);
            } finally {
                traktWatchlistBtn.disabled = false;
            }
        }

        async function removeFromTraktWatchlist() {
            if (!currentMovie) return;

            try {
                traktWatchlistBtn.disabled = true;
                traktWatchlistBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Removing...';

                const title = currentMovie.title || currentMovie.name;
                const year = parseInt((currentMovie.release_date || currentMovie.first_air_date || '').substring(0, 4));
                const type = currentMediaType === 'tv' ? 'show' : 'movie';

                const response = await fetch('/api/trakt/watchlist/remove', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, type, year })
                });

                const data = await response.json();
                
                if (data.success) {
                    updateWatchlistButton(false);
                    showNotification(`Removed "${title}" from your Trakt watchlist`, 'success');
                } else {
                    throw new Error(data.error || 'Failed to remove from watchlist');
                }
                
            } catch (error) {
                console.error('[TRAKT] Remove from watchlist error:', error);
                showNotification('Failed to remove from watchlist: ' + error.message, 'error');
                updateWatchlistButton(true);
            } finally {
                traktWatchlistBtn.disabled = false;
            }
        }

        // ===== END TRAKT FUNCTIONS =====

        // ===== TRAKT PAGE FUNCTIONS =====
        
        // Global Trakt page state
        let traktPageInitialized = false;
        let traktDeviceCodeInterval = null;
        let traktStats = null;

        async function initializeTraktPage() {
            if (traktPageInitialized) return;
            
            try {
                await updateTraktPageStatus();
                setupTraktPageEventListeners();
                traktPageInitialized = true;
                console.log('[TRAKT PAGE] Initialized successfully');
            } catch (error) {
                console.error('[TRAKT PAGE] Initialization error:', error);
            }
        }

        function setupTraktPageEventListeners() {
            // Authenticate button
            const authBtn = document.getElementById('traktAuthenticateBtn');
            if (authBtn) {
                authBtn.addEventListener('click', startTraktPageAuth);
            }

            // Disconnect button
            const disconnectBtn = document.getElementById('traktDisconnectBtn');
            if (disconnectBtn) {
                disconnectBtn.addEventListener('click', disconnectTraktFromPage);
            }

            // Verify Device Code button
            const verifyBtn = document.getElementById('traktVerifyDeviceBtn');
            if (verifyBtn) {
                verifyBtn.addEventListener('click', verifyTraktDeviceCode);
            }

            // Open Trakt URL button
            const openUrlBtn = document.getElementById('traktOpenUrlBtn');
            if (openUrlBtn) {
                openUrlBtn.addEventListener('click', () => {
                    const url = document.getElementById('traktVerificationUrl')?.textContent;
                    if (url) {
                        window.electronAPI?.openExternal(url);
                    }
                });
            }

            // Copy device code button
            const copyCodeBtn = document.getElementById('traktCopyCodeBtn');
            if (copyCodeBtn) {
                copyCodeBtn.addEventListener('click', copyTraktDeviceCode);
            }

            // Action cards
            document.querySelectorAll('.trakt-action-card').forEach(card => {
                card.addEventListener('click', handleTraktActionClick);
            });

            // Settings toggles
            const autoScrobbleToggle = document.getElementById('traktPageAutoScrobble');
            const progressToggle = document.getElementById('traktPageScrobbleProgress');
            const watchlistToggle = document.getElementById('traktPageWatchlistSync');

            if (autoScrobbleToggle) {
                autoScrobbleToggle.addEventListener('change', () => {
                    if (traktAutoScrobbleToggle) {
                        traktAutoScrobbleToggle.checked = autoScrobbleToggle.checked;
                    }
                });
            }

            if (progressToggle) {
                progressToggle.addEventListener('change', () => {
                    if (traktScrobbleProgressToggle) {
                        traktScrobbleProgressToggle.checked = progressToggle.checked;
                    }
                });
            }

            if (watchlistToggle) {
                watchlistToggle.addEventListener('change', () => {
                    if (traktWatchlistSyncToggle) {
                        traktWatchlistSyncToggle.checked = watchlistToggle.checked;
                    }
                });
            }
        }

        async function updateTraktPageStatus() {
            try {
                const response = await fetch('/api/trakt/status');
                const data = await response.json();

                const statusIndicator = document.getElementById('traktStatusIndicator');
                const statusDescription = document.getElementById('traktStatusDescription');
                const statusActions = document.getElementById('traktStatusActions');
                const deviceCodePanel = document.getElementById('traktDeviceCodePanel');

                if (data.authenticated) {
                    // Connected state
                    if (statusIndicator) {
                        statusIndicator.className = 'trakt-status-indicator connected';
                        statusIndicator.innerHTML = '<i class="fas fa-check-circle"></i>Connected to Trakt';
                    }

                    if (statusDescription) {
                        statusDescription.textContent = 'Your account is connected and ready for automatic scrobbling, watchlist sync, and more!';
                    }

                    if (statusActions) {
                        statusActions.innerHTML = `
                            <button id="traktDisconnectBtn" class="trakt-btn trakt-btn-secondary">
                                <i class="fas fa-unlink"></i>Disconnect Account
                            </button>
                            <button onclick="showDetailedTraktStatistics()" class="trakt-btn trakt-btn-info">
                                <i class="fas fa-chart-bar"></i>View Statistics
                            </button>
                        `;
                    }

                    if (deviceCodePanel) {
                        deviceCodePanel.style.display = 'none';
                    }

                    // Update action grid with stats
                    await loadTraktStats();
                    // One-time import from Trakt into local caches
                    importTraktDataOnceIfNeeded();
                    
                } else {
                    // Disconnected state
                    if (statusIndicator) {
                        statusIndicator.className = 'trakt-status-indicator disconnected';
                        statusIndicator.innerHTML = '<i class="fas fa-times-circle"></i>Not Connected';
                    }

                    if (statusDescription) {
                        statusDescription.textContent = 'Connect your Trakt account to automatically track what you watch, sync your watchlist, and get personalized recommendations.';
                    }

                    if (statusActions) {
                        statusActions.innerHTML = `
                            <button id="traktAuthenticateBtn" class="trakt-btn trakt-btn-primary">
                                <i class="fas fa-link"></i>Connect to Trakt
                            </button>
                        `;
                    }

                    if (deviceCodePanel) {
                        deviceCodePanel.style.display = 'none';
                    }

                    // Clear action grid
                    clearTraktActionGrid();
                }

                // Sync settings toggles
                syncTraktPageSettings();
                
                // Re-setup event listeners after DOM update
                setupTraktPageEventListeners();

            } catch (error) {
                console.error('[TRAKT PAGE] Status update error:', error);
                // Only show error if we can't get basic status, not for stats loading
                if (error.message && !error.message.includes('stats')) {
                    showNotification('Trakt loading', 'warning');
                }
            }
        }

        async function startTraktPageAuth() {
            try {
                const response = await fetch('/api/trakt/device/code', { method: 'POST' });
                const data = await response.json();

                if (data.success) {
                    showTraktDeviceCode(data.device_code, data.user_code, data.verification_url, data.expires_in);
                    
                    // Start polling for verification
                    traktDeviceCodeInterval = setInterval(async () => {
                        await verifyTraktDeviceCode();
                    }, data.interval * 1000 || 5000);
                    
                } else {
                    throw new Error(data.error || 'Failed to get device code');
                }
            } catch (error) {
                console.error('[TRAKT PAGE] Auth start error:', error);
                showNotification('Failed to start authentication: ' + error.message, 'error');
            }
        }

        function showTraktDeviceCode(deviceCode, userCode, verificationUrl, expiresIn) {
            const deviceCodePanel = document.getElementById('traktDeviceCodePanel');
            const userCodeSpan = document.getElementById('traktUserCode');
            const verificationUrlSpan = document.getElementById('traktVerificationUrl');
            const statusMessage = document.getElementById('traktDeviceCodeStatus');

            if (deviceCodePanel) deviceCodePanel.style.display = 'block';
            if (userCodeSpan) userCodeSpan.textContent = userCode;
            if (verificationUrlSpan) verificationUrlSpan.textContent = verificationUrl;
            if (statusMessage) {
                statusMessage.innerHTML = '<span>Waiting for authorization... Please enter the code above on Trakt.tv</span>';
            }

            // Set timeout to hide panel after expiration
            setTimeout(() => {
                if (traktDeviceCodeInterval) {
                    clearInterval(traktDeviceCodeInterval);
                    traktDeviceCodeInterval = null;
                    if (deviceCodePanel) deviceCodePanel.style.display = 'none';
                    showNotification('Device code expired. Please try again.', 'error');
                }
            }, expiresIn * 1000);
        }

        async function verifyTraktDeviceCode() {
            try {
                const response = await fetch('/api/trakt/device/verify', { method: 'POST' });
                const data = await response.json();

                if (data.success) {
                    // Success! Clear interval and update page
                    if (traktDeviceCodeInterval) {
                        clearInterval(traktDeviceCodeInterval);
                        traktDeviceCodeInterval = null;
                    }
                    
                    const deviceCodePanel = document.getElementById('traktDeviceCodePanel');
                    if (deviceCodePanel) deviceCodePanel.style.display = 'none';
                    
                    showNotification('Successfully connected to Trakt!', 'success');
                    await updateTraktPageStatus();
                    
                } else if (data.error === 'pending') {
                    // Still waiting, update status
                    const statusMessage = document.getElementById('traktDeviceCodeStatus');
                    if (statusMessage) {
                        statusMessage.innerHTML = '<span>Waiting for authorization... Please enter the code above on Trakt.tv</span>';
                    }
                } else {
                    throw new Error(data.error || 'Verification failed');
                }
            } catch (error) {
                console.error('[TRAKT PAGE] Verify error:', error);
                if (error.message !== 'pending') {
                    showNotification('Verification failed: ' + error.message, 'error');
                }
            }
        }

        async function disconnectTraktFromPage() {
            try {
                const response = await fetch('/api/trakt/logout', { method: 'POST' });
                const data = await response.json();

                if (data.success) {
                    showNotification('Successfully disconnected from Trakt', 'success');
                    await updateTraktPageStatus();
                } else {
                    throw new Error(data.error || 'Failed to disconnect');
                }
            } catch (error) {
                console.error('[TRAKT PAGE] Disconnect error:', error);
                showNotification('Failed to disconnect: ' + error.message, 'error');
            }
        }

        function copyTraktDeviceCode() {
            const userCode = document.getElementById('traktUserCode')?.textContent;
            if (userCode && navigator.clipboard) {
                navigator.clipboard.writeText(userCode).then(() => {
                    showNotification('Device code copied to clipboard!', 'success');
                }).catch(() => {
                    showNotification('Failed to copy code', 'error');
                });
            }
        }

        async function showDetailedTraktStatistics() {
            try {
                showNotification('Loading your statistics...', 'info', 2000);
                
                const response = await fetch('/api/trakt/user/stats');
                const data = await response.json();
                
                if (data.success && data.stats) {
                    displayTraktStatisticsModal(data.stats);
                    showNotification('Statistics loaded successfully!', 'success', 2000);
                } else {
                    throw new Error(data.error || 'Failed to load statistics');
                }
            } catch (error) {
                console.error('[TRAKT] Detailed statistics error:', error);
                showNotification('Unable to load detailed statistics. Please ensure you\'re connected to Trakt and try again.', 'error', 4000);
            }
        }

        function displayTraktStatisticsModal(stats) {
            // Create statistics modal
            const modal = document.createElement('div');
            modal.id = 'traktStatisticsModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(8px);
                z-index: 20000;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 2rem;
                animation: fadeIn 0.3s ease;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: linear-gradient(135deg, rgba(30, 30, 30, 0.95) 0%, rgba(20, 20, 20, 0.95) 100%);
                border-radius: 16px;
                padding: 2rem;
                max-width: 800px;
                width: 100%;
                max-height: 80vh;
                overflow-y: auto;
                border: 1px solid rgba(255, 255, 255, 0.1);
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            `;

            // Calculate totals
            const movieStats = stats.movies || { watched: 0, collected: 0, ratings: 0, plays: 0, minutes: 0 };
            const showStats = stats.shows || { watched: 0, collected: 0, ratings: 0, plays: 0, minutes: 0 };
            const episodeStats = stats.episodes || { watched: 0, collected: 0, ratings: 0, plays: 0, minutes: 0 };
            
            const totalWatched = movieStats.watched + showStats.watched;
            const totalMinutes = movieStats.minutes + episodeStats.minutes;
            const totalHours = Math.round(totalMinutes / 60);
            const totalDays = Math.round(totalHours / 24);
            
            modalContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
                    <h2 style="margin: 0; color: #ed1c24; font-size: 1.8rem;">
                        <i class="fas fa-chart-bar"></i> Your Trakt Statistics
                    </h2>
                    <button onclick="closeTraktStatisticsModal()" style="
                        background: rgba(255, 255, 255, 0.1);
                        border: none;
                        color: white;
                        padding: 0.5rem;
                        border-radius: 50%;
                        cursor: pointer;
                        font-size: 1.2rem;
                        width: 40px;
                        height: 40px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    "></button>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; margin-bottom: 2rem;">
                    <div style="background: rgba(237, 28, 36, 0.1); padding: 1.5rem; border-radius: 12px; border-left: 4px solid #ed1c24;">
                        <div style="font-size: 2rem; font-weight: bold; color: #ed1c24;">${totalWatched}</div>
                        <div style="color: #ccc; margin-top: 0.5rem;">Total Content Watched</div>
                        <div style="font-size: 0.9rem; color: #999; margin-top: 0.25rem;">Movies + Shows</div>
                    </div>
                    
                    <div style="background: rgba(34, 197, 94, 0.1); padding: 1.5rem; border-radius: 12px; border-left: 4px solid #22c55e;">
                        <div style="font-size: 2rem; font-weight: bold; color: #22c55e;">${totalDays}</div>
                        <div style="color: #ccc; margin-top: 0.5rem;">Days Watched</div>
                        <div style="font-size: 0.9rem; color: #999; margin-top: 0.25rem;">${totalHours} hours total</div>
                    </div>
                    
                    <div style="background: rgba(59, 130, 246, 0.1); padding: 1.5rem; border-radius: 12px; border-left: 4px solid #3b82f6;">
                        <div style="font-size: 2rem; font-weight: bold; color: #3b82f6;">${stats.watchlist?.length || 0}</div>
                        <div style="color: #ccc; margin-top: 0.5rem;">Watchlist Items</div>
                        <div style="font-size: 0.9rem; color: #999; margin-top: 0.25rem;">Pending to watch</div>
                    </div>
                    
                    <div style="background: rgba(245, 158, 11, 0.1); padding: 1.5rem; border-radius: 12px; border-left: 4px solid #f59e0b;">
                        <div style="font-size: 2rem; font-weight: bold; color: #f59e0b;">${stats.ratings?.length || 0}</div>
                        <div style="color: #ccc; margin-top: 0.5rem;">Items Rated</div>
                        <div style="font-size: 0.9rem; color: #999; margin-top: 0.25rem;">Your taste profile</div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 12px;">
                        <h3 style="margin: 0 0 1rem 0; color: #ed1c24;">
                            <i class="fas fa-film"></i> Movies
                        </h3>
                        <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Watched:</span>
                                <span style="color: white; font-weight: bold;">${movieStats.watched || 0}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Collected:</span>
                                <span style="color: white; font-weight: bold;">${movieStats.collected || 0}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Rated:</span>
                                <span style="color: white; font-weight: bold;">${movieStats.ratings || 0}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Watch Time:</span>
                                <span style="color: white; font-weight: bold;">${Math.round((movieStats.minutes || 0) / 60)}h</span>
                            </div>
                        </div>
                    </div>

                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 12px;">
                        <h3 style="margin: 0 0 1rem 0; color: #ed1c24;">
                            <i class="fas fa-tv"></i> TV Shows
                        </h3>
                        <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Shows Watched:</span>
                                <span style="color: white; font-weight: bold;">${showStats.watched || 0}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Episodes:</span>
                                <span style="color: white; font-weight: bold;">${episodeStats.watched || 0}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Shows Rated:</span>
                                <span style="color: white; font-weight: bold;">${showStats.ratings || 0}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Watch Time:</span>
                                <span style="color: white; font-weight: bold;">${Math.round((episodeStats.minutes || 0) / 60)}h</span>
                            </div>
                        </div>
                    </div>
                </div>

                ${stats.network ? `
                <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 12px; margin-bottom: 1rem;">
                    <h3 style="margin: 0 0 1rem 0; color: #ed1c24;">
                        <i class="fas fa-users"></i> Social Network
                    </h3>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; text-align: center;">
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #3b82f6;">${stats.network.friends || 0}</div>
                            <div style="color: #ccc; font-size: 0.9rem;">Friends</div>
                        </div>
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #22c55e;">${stats.network.followers || 0}</div>
                            <div style="color: #ccc; font-size: 0.9rem;">Followers</div>
                        </div>
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #f59e0b;">${stats.network.following || 0}</div>
                            <div style="color: #ccc; font-size: 0.9rem;">Following</div>
                        </div>
                    </div>
                </div>
                ` : ''}

                <div style="text-align: center; margin-top: 2rem;">
                    <button onclick="window.electronAPI?.openExternal('https://trakt.tv/users/me')" style="
                        background: linear-gradient(135deg, #ed1c24 0%, #d41920 100%);
                        color: white;
                        border: none;
                        padding: 0.75rem 1.5rem;
                        border-radius: 8px;
                        font-weight: 600;
                        cursor: pointer;
                        margin-right: 1rem;
                    ">
                        <i class="fas fa-external-link-alt"></i> View Profile on Trakt
                    </button>
                    <button onclick="closeTraktStatisticsModal()" style="
                        background: rgba(255, 255, 255, 0.1);
                        color: white;
                        border: 1px solid rgba(255, 255, 255, 0.2);
                        padding: 0.75rem 1.5rem;
                        border-radius: 8px;
                        font-weight: 600;
                        cursor: pointer;
                    ">
                        Close
                    </button>
                </div>
            `;

            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Add click outside to close
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeTraktStatisticsModal();
                }
            });

            showNotification('Statistics loaded successfully!', 'success');
        }

        function closeTraktStatisticsModal() {
            const modal = document.getElementById('traktStatisticsModal');
            if (modal) {
                modal.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => {
                    modal.remove();
                }, 300);
            }
        }

        // Add fade animations
        const fadeStyle = document.createElement('style');
        fadeStyle.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: scale(0.9); }
                to { opacity: 1; transform: scale(1); }
            }
            @keyframes fadeOut {
                from { opacity: 1; transform: scale(1); }
                to { opacity: 0; transform: scale(0.9); }
            }
        `;
        document.head.appendChild(fadeStyle);

        async function loadTraktStats() {
            try {
                const response = await fetch('/api/trakt/user/stats');
                const data = await response.json();

                if (data.success) {
                    traktStats = data.stats;
                    updateTraktActionGrid(data.stats);
                    console.log('[TRAKT PAGE] Stats loaded successfully');
                } else {
                    // Silently use placeholder stats - don't show error notifications
                    console.log('[TRAKT PAGE] Using placeholder stats:', data.error);
                    const placeholderStats = {
                        watchlist: [],
                        collection: { movies: [], shows: [] },
                        ratings: [],
                        movies: { watched: 0, collected: 0, ratings: 0 },
                        shows: { watched: 0, collected: 0, ratings: 0 }
                    };
                    updateTraktActionGrid(placeholderStats);
                }
            } catch (error) {
                // Don't show error notifications for stats loading - just use placeholders
                console.log('[TRAKT PAGE] Stats loading failed, using placeholders:', error);
                const placeholderStats = {
                    watchlist: [],
                    collection: { movies: [], shows: [] },
                    ratings: [],
                    movies: { watched: 0, collected: 0, ratings: 0 },
                    shows: { watched: 0, collected: 0, ratings: 0 }
                };
                updateTraktActionGrid(placeholderStats);
            }
        }

        function updateTraktActionGrid(stats) {
            const actionCards = document.querySelectorAll('.trakt-action-card');
            
            actionCards.forEach(card => {
                const action = card.dataset.action;
                const countEl = card.querySelector('.trakt-action-count');
                
                switch (action) {
                    case 'watchlist':
                        if (countEl) {
                            const count = stats.watchlist?.length || 0;
                            countEl.textContent = count;
                            countEl.style.display = count > 0 ? 'inline-block' : 'none';
                        }
                        break;
                    case 'history':
                        if (countEl) {
                            const movieCount = stats.movies?.watched || 0;
                            const showCount = stats.shows?.watched || 0;
                            const totalCount = movieCount + showCount;
                            countEl.textContent = totalCount;
                            countEl.style.display = totalCount > 0 ? 'inline-block' : 'none';
                        }
                        break;
                    case 'collection':
                        if (countEl) {
                            const movieCount = stats.collection?.movies?.length || 0;
                            const showCount = stats.collection?.shows?.length || 0;
                            const totalCount = movieCount + showCount;
                            countEl.textContent = totalCount;
                            countEl.style.display = totalCount > 0 ? 'inline-block' : 'none';
                        }
                        break;
                    case 'ratings':
                        if (countEl) {
                            const count = stats.ratings?.length || 0;
                            countEl.textContent = count;
                            countEl.style.display = count > 0 ? 'inline-block' : 'none';
                        }
                        break;
                }
            });
            
            console.log('[TRAKT PAGE] Action grid updated with stats');
        }

        function clearTraktActionGrid() {
            const actionCards = document.querySelectorAll('.trakt-action-card');
            actionCards.forEach(card => {
                const countEl = card.querySelector('.trakt-action-count');
                if (countEl) countEl.textContent = '0';
            });
        }

        async function handleTraktActionClick(event) {
            const card = event.currentTarget;
            const action = card.dataset.action;
            
            // Show detailed information for each action
            switch (action) {
                case 'watchlist':
                    await showTraktWatchlistDetails();
                    break;
                case 'history':
                    await showTraktHistoryDetails();
                    break;
                case 'collection':
                    await showTraktCollectionDetails();
                    break;
                case 'ratings':
                    await showTraktRatingsDetails();
                    break;
                default:
                    showNotification('Feature coming soon!', 'info');
            }
        }

        async function showTraktWatchlistDetails() {
            try {
                const response = await fetch('/api/trakt/watchlist');
                const data = await response.json();
                
                if (data.success && data.watchlist) {
                    const count = data.watchlist.length;
                    if (count > 0) {
                        showNotification(`Your watchlist has ${count} items. They will appear automatically when browsing!`, 'success');
                    } else {
                        showNotification('Your watchlist is empty. Add items by clicking the + button on movies and shows!', 'info');
                    }
                } else {
                    showNotification('Could not load watchlist. Make sure you\'re connected to Trakt.', 'error');
                }
            } catch (error) {
                console.error('[TRAKT] Watchlist details error:', error);
                showNotification('Failed to load watchlist details', 'error');
            }
        }

        async function showTraktHistoryDetails() {
            try {
                const response = await fetch('/api/trakt/history');
                const data = await response.json();
                
                if (data.success && data.history) {
                    const count = data.history.length;
                    if (count > 0) {
                        showNotification(`You've watched ${count} items. Your watch history is automatically tracked!`, 'success');
                    } else {
                        showNotification('No watch history yet. Start watching content and it will be tracked automatically!', 'info');
                    }
                } else {
                    showNotification('Could not load watch history. Make sure you\'re connected to Trakt.', 'error');
                }
            } catch (error) {
                console.error('[TRAKT] History details error:', error);
                showNotification('Failed to load watch history', 'error');
            }
        }

        async function showTraktCollectionDetails() {
            try {
                const response = await fetch('/api/trakt/collection');
                const data = await response.json();
                
                if (data.success && data.collection) {
                    const movieCount = data.collection.movies?.length || 0;
                    const showCount = data.collection.shows?.length || 0;
                    const total = movieCount + showCount;
                    
                    if (total > 0) {
                        showNotification(`Your collection has ${movieCount} movies and ${showCount} shows (${total} total)`, 'success');
                    } else {
                        showNotification('Your collection is empty. Items are added automatically when you finish watching!', 'info');
                    }
                } else {
                    showNotification('Could not load collection. Make sure you\'re connected to Trakt.', 'error');
                }
            } catch (error) {
                console.error('[TRAKT] Collection details error:', error);
                showNotification('Failed to load collection details', 'error');
            }
        }

        async function showTraktRatingsDetails() {
            try {
                const response = await fetch('/api/trakt/ratings');
                const data = await response.json();
                
                if (data.success && data.ratings) {
                    const count = data.ratings.length;
                    if (count > 0) {
                        showNotification(`You've rated ${count} items on Trakt. Visit trakt.tv to rate more content!`, 'success');
                    } else {
                        showNotification('You haven\'t rated anything yet. Visit trakt.tv to start rating movies and shows!', 'info');
                    }
                } else {
                    showNotification('Could not load ratings. Make sure you\'re connected to Trakt.', 'error');
                }
            } catch (error) {
                console.error('[TRAKT] Ratings details error:', error);
                showNotification('Failed to load ratings details', 'error');
            }
        }

        function syncTraktPageSettings() {
            // Sync main settings with page settings
            const autoScrobbleToggle = document.getElementById('traktPageAutoScrobble');
            const progressToggle = document.getElementById('traktPageScrobbleProgress');
            const watchlistToggle = document.getElementById('traktPageWatchlistSync');

            if (autoScrobbleToggle && traktAutoScrobbleToggle) {
                autoScrobbleToggle.checked = traktAutoScrobbleToggle.checked;
            }

            if (progressToggle && traktScrobbleProgressToggle) {
                progressToggle.checked = traktScrobbleProgressToggle.checked;
            }

            if (watchlistToggle && traktWatchlistSyncToggle) {
                watchlistToggle.checked = traktWatchlistSyncToggle.checked;
            }
        }

        // ===== TRAKT IMPORT (My List + Done Watching) =====
        let traktImportedOnce = false;

        async function fetchTmdbDetailsById(type, tmdbId) {
            try {
                if (!tmdbId) return null;
                const base = 'https://api.themoviedb.org/3';
                const endpoint = type === 'tv' ? `/tv/${tmdbId}` : `/movie/${tmdbId}`;
                const url = `${base}${endpoint}?api_key=${TMDB_API_KEY}`;
                const resp = await fetch(url);
                if (!resp.ok) return null;
                const j = await resp.json();
                return j;
            } catch(_) { return null; }
        }

        function normalizeYear(from) {
            try { return (from || '').substring(0, 4) || ''; } catch { return ''; }
        }

        async function importTraktWatchlistToMyList() {
            try {
                const res = await fetch('/api/trakt/watchlist?type=mixed');
                const data = await res.json();
                if (!data.success || !Array.isArray(data.watchlist)) return 0;

                // Ensure current list loaded
                await loadMyList();

                let added = 0;
                for (const entry of data.watchlist) {
                    const isMovie = !!entry.movie;
                    const isShow = !!entry.show;
                    const type = isMovie ? 'movie' : (isShow ? 'tv' : null);
                    const ids = (entry.movie?.ids || entry.show?.ids || {});
                    const tmdbId = ids.tmdb || null;
                    if (!type || !tmdbId) continue;

                    // Skip if already present
                    if (myListCache.some(it => it.id === tmdbId && it.media_type === type)) continue;

                    // Fetch TMDB details to enrich poster/year/rating/title
                    const details = await fetchTmdbDetailsById(type, tmdbId);
                    const title = type === 'tv' ? (details?.name || entry.show?.title || '') : (details?.title || entry.movie?.title || '');
                    const poster_path = details?.poster_path || '';
                    const year = type === 'tv' ? normalizeYear(details?.first_air_date || entry.show?.year) : normalizeYear(details?.release_date || entry.movie?.year);
                    const vote_average = Number(details?.vote_average || 0);
                    const listItem = {
                        id: tmdbId,
                        media_type: type,
                        title,
                        poster_path,
                        year,
                        vote_average,
                        added_date: entry.listed_at || new Date().toISOString()
                    };
                    myListCache.unshift(listItem);
                    added++;
                }

                if (added > 0) {
                    await saveMyList();
                    // Refresh page if open
                    if (document.getElementById('myListPage')?.style.display !== 'none') {
                        await displayMyList();
                    }
                }
                return added;
            } catch (e) {
                console.log('[TRAKT IMPORT] My List failed:', e?.message);
                return 0;
            }
        }

        async function importTraktHistoryToDoneWatching(maxPages = 20, pageSize = 100) {
            try {
                await loadDoneWatching();
                let totalAdded = 0;
                for (let page = 1; page <= maxPages; page++) {
                    const res = await fetch(`/api/trakt/history?type=mixed&page=${page}&limit=${pageSize}`);
                    const data = await res.json();
                    if (!data.success || !Array.isArray(data.history) || data.history.length === 0) break;

                    for (const h of data.history) {
                        const watchedAt = h.watched_at || new Date().toISOString();
                        if (h.movie) {
                            const ids = h.movie.ids || {};
                            const tmdbId = ids.tmdb || null;
                            if (!tmdbId) continue;
                            // Skip if already have movie marked done (whole title)
                            if (doneWatchingCache.some(it => it.id === tmdbId && it.media_type === 'movie' && !it.season && !it.episode)) continue;
                            const details = await fetchTmdbDetailsById('movie', tmdbId);
                            const item = {
                                id: tmdbId,
                                media_type: 'movie',
                                title: details?.title || h.movie.title || '',
                                poster_path: details?.poster_path || '',
                                year: normalizeYear(details?.release_date || h.movie.year),
                                vote_average: Number(details?.vote_average || 0),
                                completed_date: watchedAt
                            };
                            doneWatchingCache.unshift(item);
                            totalAdded++;
                        } else if (h.episode && h.show) {
                            const ids = h.show.ids || {};
                            const tmdbId = ids.tmdb || null;
                            if (!tmdbId) continue;
                            const season = h.episode.season;
                            const episode = h.episode.number;
                            // Skip if this exact episode already present
                            if (doneWatchingCache.some(it => it.id === tmdbId && it.media_type === 'tv' && it.season === season && it.episode === episode)) continue;
                            const details = await fetchTmdbDetailsById('tv', tmdbId);
                            const item = {
                                id: tmdbId,
                                media_type: 'tv',
                                title: details?.name || h.show.title || '',
                                poster_path: details?.poster_path || '',
                                year: normalizeYear(details?.first_air_date || h.show.year),
                                vote_average: Number(details?.vote_average || 0),
                                completed_date: watchedAt,
                                season,
                                episode,
                                episode_title: h.episode.title || `S${season}E${episode}`
                            };
                            doneWatchingCache.unshift(item);
                            totalAdded++;
                        }
                    }

                    // If we received less than requested, we reached the end
                    if (data.history.length < pageSize) break;
                }

                if (totalAdded > 0) {
                    await saveDoneWatching();
                    if (document.getElementById('doneWatchingPage')?.style.display !== 'none') {
                        await displayDoneWatching();
                    }
                }
                return totalAdded;
            } catch (e) {
                console.log('[TRAKT IMPORT] Done Watching failed:', e?.message);
                return 0;
            }
        }

        async function importTraktDataOnceIfNeeded() {
            try {
                if (traktImportedOnce) return;
                if (localStorage.getItem('traktImportedOnce') === 'true') { traktImportedOnce = true; return; }
                showNotification('Importing your Trakt data (watchlist & history)...', 'info');
                const [addedList, addedDone] = await Promise.all([
                    importTraktWatchlistToMyList(),
                    importTraktHistoryToDoneWatching(),
                ]);
                traktImportedOnce = true;
                localStorage.setItem('traktImportedOnce', 'true');
                const msg = `Imported ${addedList} in My List and ${addedDone} in Done Watching from Trakt`;
                showNotification(msg, 'success');
                // Optionally update visible cards' buttons state
                try {
                    document.querySelectorAll('.movie-card').forEach(card => {
                        // Attempt to extract id/mediaType from onclick attributes
                        const addBtn = card.querySelector('.add-to-list-btn');
                        const doneBtn = card.querySelector('.done-watching-btn');
                        const attr = (addBtn?.getAttribute('onclick') || doneBtn?.getAttribute('onclick') || '') + '';
                        const idMatch = attr.match(/,(\s*)(\d+)(\s*),\s*'(movie|tv)'/);
                        if (idMatch) {
                            const id = parseInt(idMatch[2], 10);
                            const mediaType = idMatch[4];
                            updateCardListStatus(card, id, mediaType);
                            updateCardDoneStatus(card, id, mediaType);
                        }
                    });
                } catch(_) {}
            } catch (e) {
                console.log('[TRAKT IMPORT] unexpected error:', e?.message);
            }
        }

        // ===== END TRAKT PAGE FUNCTIONS =====

        // ===== TRAKT SYNC FUNCTIONS FOR IN-APP LISTS =====
        
        async function syncWithTraktWatchlist(action, title, mediaType, year) {
            try {
                // Check if user is authenticated
                const statusResponse = await fetch('/api/trakt/status');
                const statusData = await statusResponse.json();
                if (!statusData.authenticated) {
                    console.log('[TRAKT SYNC] User not authenticated, skipping watchlist sync');
                    return;
                }

                const endpoint = action === 'add' ? '/api/trakt/watchlist/add' : '/api/trakt/watchlist/remove';
                const type = mediaType === 'movie' ? 'movie' : 'show';
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, type, year: parseInt(year) })
                });

                const data = await response.json();
                
                if (data.success) {
                    const actionText = action === 'add' ? 'Added to' : 'Removed from';
                    showNotification(`${actionText} Trakt watchlist: "${title}"`, 'success');
                    console.log(`[TRAKT SYNC] ${actionText} watchlist:`, title);
                } else {
                    console.log(`[TRAKT SYNC] Watchlist ${action} failed:`, data.error);
                }
            } catch (error) {
                console.log('[TRAKT SYNC] Watchlist sync error:', error);
            }
        }

        async function syncWithTraktWatched(mediaType, title, year) {
            try {
                // Check if user is authenticated
                const statusResponse = await fetch('/api/trakt/status');
                const statusData = await statusResponse.json();
                if (!statusData.authenticated) {
                    console.log('[TRAKT SYNC] User not authenticated, skipping watched sync');
                    return;
                }

                // Use scrobble/stop to mark as watched (100% progress)
                const response = await fetch('/api/trakt/scrobble/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        title, 
                        type: mediaType, 
                        year: parseInt(year),
                        progress: 100 
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    showNotification(`Marked "${title}" as watched on Trakt`, 'success');
                    console.log('[TRAKT SYNC] Marked as watched:', title);
                } else {
                    console.log('[TRAKT SYNC] Watched sync failed:', data.error);
                }
            } catch (error) {
                console.log('[TRAKT SYNC] Watched sync error:', error);
            }
        }

        async function syncWithTraktWatchedEpisode(showTitle, year, season, episode) {
            try {
                // Check if user is authenticated
                const statusResponse = await fetch('/api/trakt/status');
                const statusData = await statusResponse.json();
                if (!statusData.authenticated) {
                    console.log('[TRAKT SYNC] User not authenticated, skipping episode sync');
                    return;
                }

                // Use scrobble/stop to mark episode as watched
                const response = await fetch('/api/trakt/scrobble/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        title: showTitle, 
                        type: 'show', 
                        year: parseInt(year),
                        season: parseInt(season),
                        episode: parseInt(episode),
                        progress: 100 
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    showNotification(`Marked S${season}E${episode} of "${showTitle}" as watched on Trakt`, 'success');
                    console.log('[TRAKT SYNC] Marked episode as watched:', showTitle, `S${season}E${episode}`);
                } else {
                    console.log('[TRAKT SYNC] Episode watched sync failed:', data.error);
                }
            } catch (error) {
                console.log('[TRAKT SYNC] Episode watched sync error:', error);
            }
        }

        async function syncWithTraktCollection(action, title, mediaType, year) {
            try {
                // Check if user is authenticated
                const statusResponse = await fetch('/api/trakt/status');
                const statusData = await statusResponse.json();
                if (!statusData.authenticated) {
                    console.log('[TRAKT SYNC] User not authenticated, skipping collection sync');
                    return;
                }

                const endpoint = action === 'add' ? '/api/trakt/collection/add' : '/api/trakt/collection/remove';
                const type = mediaType === 'movie' ? 'movie' : 'show';
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, type, year: parseInt(year) })
                });

                const data = await response.json();
                
                if (data.success) {
                    const actionText = action === 'add' ? 'Added to' : 'Removed from';
                    console.log(`[TRAKT SYNC] ${actionText} collection:`, title);
                } else {
                    console.log(`[TRAKT SYNC] Collection ${action} failed:`, data.error);
                }
            } catch (error) {
                console.log('[TRAKT SYNC] Collection sync error:', error);
            }
        }

        // Function to add episode-specific done watching
        function addEpisodeToDoneWatching(showId, showTitle, season, episode, episodeTitle, year, poster) {
            const episodeItem = {
                id: showId,
                media_type: 'tv',
                title: showTitle,
                episode_title: episodeTitle,
                season: season,
                episode: episode,
                poster_path: poster,
                year: year,
                vote_average: 0,
                completed_date: new Date().toISOString()
            };
            
            // Check if this episode is already in done watching
            const existingIndex = doneWatchingCache.findIndex(item => 
                item.id === showId && item.media_type === 'tv' && 
                item.season === season && item.episode === episode
            );
            
            if (existingIndex === -1) {
                doneWatchingCache.unshift(episodeItem);
                saveDoneWatching();
                
                // Sync with Trakt
                syncWithTraktWatchedEpisode(showTitle, year, season, episode);
                
                showNotification(`Added S${season}E${episode} "${episodeTitle}" to done watching`, 'success');
            } else {
                showNotification(`S${season}E${episode} is already in done watching`, 'info');
            }
        }

        // Toggle episode-specific done watching
        async function toggleEpisodeDoneWatching(event, showId, showTitle, season, episode, episodeTitle, year, poster) {
            event.preventDefault();
            event.stopPropagation();
            
            const button = event.target.closest('.episode-done-btn');
            if (!button) return;

            const existingIndex = doneWatchingCache.findIndex(item => 
                item.id === showId && item.media_type === 'tv' && 
                item.season === season && item.episode === episode
            );
            
            if (existingIndex >= 0) {
                // Remove episode from done watching
                doneWatchingCache.splice(existingIndex, 1);
                button.classList.remove('is-done');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Mark Episode as Done Watching';
                
                showNotification(`Removed S${season}E${episode} from done watching`, 'info');
            } else {
                // Add episode to done watching
                const episodeItem = {
                    id: showId,
                    media_type: 'tv',
                    title: showTitle,
                    episode_title: episodeTitle,
                    season: season,
                    episode: episode,
                    poster_path: poster,
                    year: year,
                    vote_average: 0,
                    completed_date: new Date().toISOString()
                };
                
                doneWatchingCache.unshift(episodeItem);
                button.classList.add('is-done');
                button.innerHTML = '<i class="fas fa-check-circle"></i>';
                button.title = 'Remove from Done Watching';
                
                // Sync with Trakt
                await syncWithTraktWatchedEpisode(showTitle, year, season, episode);
                
                showNotification(`Marked S${season}E${episode} "${episodeTitle}" as watched`, 'success');
            }

            await saveDoneWatching();
            
            // Refresh Done Watching page if it's currently open
            if (document.getElementById('doneWatchingPage').style.display !== 'none') {
                displayDoneWatching();
            }
            // Also update any other cards for the same show immediately
            updateAllDoneButtons(showId, 'tv');
        }

        // Update all .done-watching-btn in DOM for a given id/mediaType
        function updateAllDoneButtons(id, mediaType) {
            document.querySelectorAll('.done-watching-btn').forEach(btn => {
                const onClick = btn.getAttribute('onclick') || '';
                if (onClick.includes('toggleDoneWatching') && onClick.includes(`, ${id},`) && onClick.includes(`'${mediaType}'`)) {
                    const card = btn.closest('.movie-card');
                    if (card) updateCardDoneStatus(card, id, mediaType);
                }
            });
        }

        // ===== END TRAKT SYNC FUNCTIONS =====
        
        // Save Settings: persist useTorrentless and optionally API key, then close modal
        async function saveSettings_() {
            // Get API key from any instance (prefer visible, else any non-empty)
            const apiKeyElements = document.querySelectorAll('#newApiKey');
            let apiKey = '';
            for (const el of apiKeyElements) {
                const val = (el.value || '').trim();
                if (val) {
                    apiKey = val;
                    // Prefer the visible one but accept hidden if that's the only filled one
                    if (el.offsetParent !== null) break;
                }
            }
            
            // Get the toggle that is actually checked (either modal or settings page)
            const toggleElements = document.querySelectorAll('#useTorrentlessToggle');
            let toggleEl = null;
            for (const el of toggleElements) {
                if (el.offsetParent !== null) { // Check if element is visible
                    toggleEl = el;
                    break;
                }
            }
            const desiredTorrentless = toggleEl ? !!toggleEl.checked : useTorrentless;
            
            // Get Jackett URL (prefer visible, else any non-empty)
            const jackettUrlElements = document.querySelectorAll('#jackettUrl');
            let jackettUrl = '';
            for (const el of jackettUrlElements) {
                const val = (el.value || '').trim();
                if (val) {
                    jackettUrl = val;
                    if (el.offsetParent !== null) break;
                }
            }
            
            // Get cache location (prefer visible, else any non-empty)
            const cacheLocationElements = document.querySelectorAll('#cacheLocation');
            let cacheLocation = '';
            for (const el of cacheLocationElements) {
                const val = (el.value || '').trim();
                if (val) {
                    cacheLocation = val;
                    if (el.offsetParent !== null) break;
                }
            }

            // Get AutoUpdater setting (prefer visible)
            const autoUpdateToggles = document.querySelectorAll('#autoUpdateToggle');
            let autoUpdateEnabled = true; // default ON
            for (const el of autoUpdateToggles) {
                if (el.offsetParent !== null) {
                    autoUpdateEnabled = !!el.checked;
                    break;
                }
            }
            
            // Handle fullscreen toggle - get the visible one
            const fullscreenToggles = document.querySelectorAll('#fullscreenToggle');
            let fullscreenToggle = null;
            for (const el of fullscreenToggles) {
                if (el.offsetParent !== null) {
                    fullscreenToggle = el;
                    break;
                }
            }
            
            if (fullscreenToggle && window.electronAPI && window.electronAPI.setFullscreen) {
                try {
                    const result = await window.electronAPI.setFullscreen(fullscreenToggle.checked);
                    if (!result.success) {
                        console.error('Failed to set fullscreen:', result.message);
                        showNotification('Failed to change fullscreen mode');
                    }
                } catch (error) {
                    console.error('Error setting fullscreen:', error);
                    showNotification('Error changing fullscreen mode');
                }
            }
            
            // Handle UI mode change - get the visible radios
            const uiModeNewElements = document.querySelectorAll('#uiModeNew');
            const uiModeOldElements = document.querySelectorAll('#uiModeOld');
            let uiModeNew = null;
            let uiModeOld = null;
            
            for (const el of uiModeNewElements) {
                if (el.offsetParent !== null) {
                    uiModeNew = el;
                    break;
                }
            }
            for (const el of uiModeOldElements) {
                if (el.offsetParent !== null) {
                    uiModeOld = el;
                    break;
                }
            }
            
            let selectedUIMode = 'new';
            if (uiModeOld && uiModeOld.checked) {
                selectedUIMode = 'old';
            }
            
            // Apply UI mode change immediately
            if (selectedUIMode !== currentUIMode) {
                applyUIMode(selectedUIMode);
            }

            let apiResult = null;
            try {
                // Build settings object
                const settings = { useTorrentless: desiredTorrentless, autoUpdate: !!autoUpdateEnabled };
                if (jackettUrl) settings.jackettUrl = jackettUrl;
                if (cacheLocation) settings.cacheLocation = cacheLocation;
                
                // Persist all settings including Jackett URL and cache location
                await fetch(`${API_BASE_URL}/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
                useTorrentless = desiredTorrentless;

                // If an API key was provided, attempt to save it; otherwise skip quietly
                if (apiKey) {
                    const response = await fetch(`${API_BASE_URL}/set-api-key`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ apiKey })
                    });
                    let keyLoc = null;
                    try {
                        apiResult = await response.json();
                    } catch(_) { apiResult = null; }
                    if (response.ok) {
                        hasApiKey = true;
                        // Confirm and show where it was saved
                        try {
                            const locRes = await fetch(`${API_BASE_URL}/key-location`);
                            if (locRes.ok) keyLoc = await locRes.json();
                        } catch(_) {}
                        await loadCurrentApiKey();
                        if (keyLoc?.hasApiKey && keyLoc?.path) {
                            showNotification(`Settings saved. API key updated at ${keyLoc.path}`);
                        } else {
                            showNotification('Settings saved. API key updated.');
                        }
                        // Clear ALL API key inputs after success
                        document.querySelectorAll('#newApiKey').forEach(el => { el.value = ''; });
                    } else {
                        showNotification(apiResult?.error || 'Failed to update API key');
                    }
                } else {
                    showNotification('Settings saved.');
                }
            } catch (error) {
                console.error('Error saving settings:', error);
                // Even if API key call fails, close the modal when toggling Torrentless is desired
            } finally {
                // Check if we're on settings page or in modal
                if (window.location.hash === '#/settings') {
                    // Stay on settings page, just show notification
                    // Navigation will be handled by cancel button if needed
                } else {
                    hideSettingsModal();
                }
            }
        }
        
        // Helper functions for page navigation (used by sidebar)
        function showHomePage() {
            window.location.hash = '#/';
        }
        
        function showGenresPage() {
            window.location.hash = '#/genres';
        }
        
        function showMyListPage() {
            window.location.hash = '#/my-list';
        }
        
        function showDoneWatchingPage() {
            window.location.hash = '#/done-watching';
        }
        
        function showTraktPage() {
            window.location.hash = '#/trakt';
        }
        
        function showLiveTvPage() {
            window.location.hash = '#/livetv';
        }
        
        function showIptvPage() {
            window.location.hash = '#/iptv';
        }
        
        function reloadIptvPage() {
            const iptvIframe = document.getElementById('iptv-iframe');
            const iptvSelector = document.getElementById('iptv-source-select');
            if (iptvIframe) {
                // Get current selected source URL
                const currentSrc = iptvSelector ? iptvSelector.value : 'https://iptvplaytorrio.pages.dev/';
                // Clear the src first to force a complete reload
                iptvIframe.src = 'about:blank';
                // Use a timeout to ensure the blank page loads before setting the new src
                setTimeout(() => {
                    iptvIframe.src = currentSrc;
                    // Auto-scroll the IPTV page itself (not the iframe content) to show the iframe
                    setTimeout(() => {
                        const iptvPageEl = document.getElementById('iptv-page');
                        if (iptvPageEl) {
                            // Scroll the main page to focus on the iframe area
                            iptvIframe.scrollIntoView({ 
                                behavior: 'smooth',
                                block: 'start'
                            });
                            console.log('[IPTV] Auto-scrolled IPTV page to show iframe');
                        }
                    }, 300); // Quick scroll after iframe starts loading
                }, 100);
                console.log('[IPTV] Page reloaded fresh with source:', currentSrc);
            }
        }

        // IPTV source selector handler
        function initIptvSourceSelector() {
            const iptvSelector = document.getElementById('iptv-source-select');
            const iptvIframe = document.getElementById('iptv-iframe');
            
            if (iptvSelector && iptvIframe) {
                iptvSelector.addEventListener('change', (event) => {
                    const selectedUrl = event.target.value;
                    const selectedOption = event.target.selectedOptions[0];
                    const isExternal = selectedOption.hasAttribute('data-external');
                    
                    console.log('[IPTV] Switching to source:', selectedUrl, 'external:', isExternal);
                    
                    if (isExternal) {
                        // Open in external browser for sites that don't allow embedding
                        if (window.electronAPI?.openExternal) {
                            window.electronAPI.openExternal(selectedUrl);
                            showNotification('Opening IPTV Web App in browser...', 'info');
                            // Reset dropdown to previous working option
                            setTimeout(() => {
                                iptvSelector.value = 'https://taupe-florentine-9c4193.netlify.app/routes/countries.html';
                            }, 100);
                        }
                    } else {
                        // Show loading indication
                        iptvIframe.style.opacity = '0.5';
                        
                        // Clear and load new source
                        iptvIframe.src = 'about:blank';
                        setTimeout(() => {
                            iptvIframe.src = selectedUrl;
                            iptvIframe.style.opacity = '1';
                            showNotification('Loading IPTV source...', 'info');
                        }, 100);
                    }
                });

                // Add error handling for iframe loading
                iptvIframe.addEventListener('load', () => {
                    console.log('[IPTV] Iframe loaded successfully');
                    iptvIframe.style.opacity = '1';
                });

                iptvIframe.addEventListener('error', (e) => {
                    console.error('[IPTV] Iframe failed to load:', e);
                    showNotification('Failed to load IPTV source. Site may block embedding.', 'error');
                    iptvIframe.style.opacity = '1';
                });
                
                console.log('[IPTV] Source selector initialized');
            }
        }
        
        function clearIptvPage() {
            const iptvIframe = document.getElementById('iptv-iframe');
            if (iptvIframe) {
                // Clear the iframe to stop any ongoing streams
                iptvIframe.src = 'about:blank';
                console.log('[IPTV] Page cleared - stopping all streams');
            }
        }

        // Games Downloader page functions
        function showGamesDownloaderPage() {
            window.location.hash = '#/games-downloader';
        }

        async function searchGames(query) {
            const statusEl = document.getElementById('games-search-status');
            const resultsSection = document.getElementById('games-results-section');
            const emptyState = document.getElementById('games-empty-state');
            const resultsGrid = document.getElementById('games-results-grid');
            const resultsCount = document.getElementById('games-results-count');

            if (!query || !query.trim()) {
                statusEl.textContent = 'Please enter a game name';
                statusEl.style.color = '#ef4444';
                return;
            }

            try {
                statusEl.textContent = 'Searching...';
                statusEl.style.color = '#8b5cf6';
                resultsSection.style.display = 'none';
                emptyState.style.display = 'none';

                const response = await fetch(`http://localhost:3000/api/games/search/${encodeURIComponent(query)}`);
                if (!response.ok) throw new Error('Search failed');

                const data = await response.json();
                
                if (!data.games || data.games.length === 0) {
                    statusEl.textContent = 'No games found';
                    statusEl.style.color = '#ef4444';
                    emptyState.style.display = '';
                    return;
                }

                // Display results
                statusEl.textContent = `Found ${data.count} game${data.count !== 1 ? 's' : ''}`;
                statusEl.style.color = '#10b981';
                resultsCount.textContent = `${data.count} game${data.count !== 1 ? 's' : ''}`;
                
                resultsGrid.innerHTML = '';
                data.games.forEach(game => {
                    const card = document.createElement('div');
                    card.className = 'music-card';
                    card.style.cursor = 'default';
                    
                    const downloadLinksHtml = game.downloadLinks && game.downloadLinks.length > 0
                        ? game.downloadLinks.map(link => `
                            <button class="game-download-link" data-url="${link.url}" style="padding: 0.4rem 0.8rem; background: linear-gradient(135deg, #8b5cf6, #7c3aed); border: none; border-radius: 6px; color: white; font-size: 0.85rem; cursor: pointer; margin: 0.2rem; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                                <i class="fas fa-download"></i> ${link.name}
                            </button>
                        `).join('')
                        : '<span style="color: var(--secondary); font-size: 0.85rem;">No download links available</span>';

                    card.innerHTML = `
                        <div class="music-cover">
                            <img loading="lazy" src="${game.image || 'https://via.placeholder.com/300x400?text=No+Image'}" alt="${game.title}" onerror="this.src='https://via.placeholder.com/300x400?text=No+Image'">
                        </div>
                        <div class="music-info">
                            <div class="music-title">${game.title}</div>
                            <div class="music-artist" style="color: #8b5cf6;">${game.version || 'Latest'}</div>
                            ${game.date ? `<div style="color: var(--secondary); font-size: 0.85rem; margin: 0.3rem 0;"><i class="fas fa-calendar"></i> ${game.date}</div>` : ''}
                            ${game.excerpt ? `<div style="color: var(--secondary); font-size: 0.85rem; margin: 0.5rem 0; line-height: 1.4;">${game.excerpt}</div>` : ''}
                            <div class="music-actions" style="flex-wrap: wrap; margin-top: 0.5rem;">
                                ${downloadLinksHtml}
                            </div>
                        </div>
                    `;
                    resultsGrid.appendChild(card);
                });

                // Add click handlers to download links
                resultsGrid.querySelectorAll('.game-download-link').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const url = e.currentTarget.getAttribute('data-url');
                        if (url && window.electronAPI?.openExternal) {
                            await window.electronAPI.openExternal(url);
                            showNotification('Opening download link in browser...', 'info');
                        }
                    });
                });

                resultsSection.style.display = '';
                emptyState.style.display = 'none';

            } catch (error) {
                console.error('Games search error:', error);
                statusEl.textContent = 'Search failed. Please try again.';
                statusEl.style.color = '#ef4444';
                emptyState.style.display = '';
            }
        }

        // Initialize Games Downloader search
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // Enable performance mode by default (can be toggled later if needed)
                const pref = localStorage.getItem('perfMode');
                const enabled = pref == null ? true : (pref === 'true');
                if (enabled) document.body.classList.add('perf-mode');
            } catch(_) {}
            const searchInput = document.getElementById('games-search-input');
            const searchBtn = document.getElementById('games-search-btn');

            if (searchInput && searchBtn) {
                searchBtn.addEventListener('click', () => {
                    searchGames(searchInput.value);
                });

                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        searchGames(searchInput.value);
                    }
                });
            }
        });

        
        // MiniGames page functions
        function showMiniGamesPage() {
            window.location.hash = '#/minigames';
        }

        function reloadMiniGamesPage() {
            const miniGamesIframe = document.getElementById('minigames-iframe');
            if (miniGamesIframe) {
                // Reload the iframe
                miniGamesIframe.src = 'about:blank';
                setTimeout(() => {
                    miniGamesIframe.src = 'https://playtorriogames.pages.dev/';
                    // Auto-scroll the MiniGames page to show the iframe
                    setTimeout(() => {
                        const miniGamesPageEl = document.getElementById('minigames-page');
                        if (miniGamesPageEl) {
                            miniGamesIframe.scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'start' 
                            });
                            console.log('[MINIGAMES] Auto-scrolled MiniGames page to show iframe');
                        }
                    }, 50);
                }, 100);
                console.log('[MINIGAMES] Page reloaded fresh');
            }
        }

        function clearMiniGamesPage() {
            const miniGamesIframe = document.getElementById('minigames-iframe');
            if (miniGamesIframe) {
                // Clear MiniGames iframe
                miniGamesIframe.src = 'about:blank';
                console.log('[MINIGAMES] Page cleared');
            }
        }
        
        function showBooksPage() {
            window.location.hash = '#/books';
        }
        
        function showMusicPage() {
            window.location.hash = '#/music';
        }
        
        function showBookTorrioPage() {
            window.location.hash = '#/booktorrio';
        }
        
        function showAnimePage() {
            window.location.hash = '#/anime';
        }
        
        function showMangaPage() {
            window.location.hash = '#/manga';
        }
        
        function showDownloaderPage() {
            window.location.hash = '#/downloader';
        }
        
        // Live TV Functionality
        let liveTvMatches = [];
        let liveTvCategories = [];
        
        async function initLiveTv() {
            const categorySelect = document.getElementById('livetv-category-select');
            const grid = document.getElementById('livetv-grid');
            const empty = document.getElementById('livetv-empty');
            
            if (!categorySelect) return;
            
            try {
                // Show loading
                if (empty) {
                    empty.style.display = '';
                    empty.innerHTML = '<div class="livetv-loading"><i class="fas fa-spinner"></i><p>Loading matches...</p></div>';
                }
                if (grid) grid.innerHTML = '';
                
                // Fetch matches
                const response = await fetch('https://streamed.pk/api/matches/all');
                liveTvMatches = await response.json();
                
                // Extract unique categories
                const categoriesSet = new Set();
                liveTvMatches.forEach(match => {
                    if (match.category) categoriesSet.add(match.category.toLowerCase());
                });
                liveTvCategories = Array.from(categoriesSet).sort();
                
                // Populate dropdown
                categorySelect.innerHTML = '';
                liveTvCategories.forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat;
                    const icons = {
                        'football': '',
                        'tennis': '',
                        'basketball': '',
                        'hockey': '',
                        'baseball': '',
                        'rugby': '',
                        'cricket': '',
                        'other': ''
                    };
                    const icon = icons[cat] || '';
                    option.textContent = `${icon} ${cat.charAt(0).toUpperCase() + cat.slice(1)}`;
                    categorySelect.appendChild(option);
                });
                
                // Set default to football if available
                if (liveTvCategories.includes('football')) {
                    categorySelect.value = 'football';
                }
                
                // Load matches for default category
                loadLiveTvMatches(categorySelect.value);
            } catch (error) {
                console.error('Error loading Live TV:', error);
                if (empty) {
                    empty.style.display = '';
                    empty.innerHTML = '<i class="fas fa-exclamation-triangle" style="font-size: 3em; opacity: 0.3; color: #ef4444;"></i><p>Failed to load matches. Please try again.</p>';
                }
            }
        }
        
        function loadLiveTvMatches(category) {
            const grid = document.getElementById('livetv-grid');
            const empty = document.getElementById('livetv-empty');
            
            if (!grid || !empty) return;
            
            // Filter matches by category
            const filtered = liveTvMatches.filter(m => m.category && m.category.toLowerCase() === category.toLowerCase());
            
            if (filtered.length === 0) {
                grid.innerHTML = '';
                empty.style.display = '';
                empty.innerHTML = `<i class="fas fa-tv" style="font-size: 3em; opacity: 0.3;"></i><p>No matches available for ${category}</p>`;
                return;
            }
            
            empty.style.display = 'none';
            grid.innerHTML = '';
            
            // Render match cards
            filtered.forEach(match => {
                const card = document.createElement('div');
                card.className = 'livetv-match-card';
                
                const posterUrl = match.poster ? `https://streamed.pk${match.poster}` : '';
                const posterHTML = posterUrl 
                    ? `<img loading="lazy" src="${posterUrl}" alt="${match.title}" class="livetv-poster" onerror="this.parentElement.querySelector('.livetv-poster-placeholder').style.display='flex'; this.style.display='none';">
                       <div class="livetv-poster-placeholder" style="display:none;"><i class="fas fa-play-circle"></i></div>`
                    : `<div class="livetv-poster-placeholder"><i class="fas fa-play-circle"></i></div>`;
                
                card.innerHTML = `
                    ${posterHTML}
                    <div class="livetv-match-info">
                        <h4 class="livetv-match-title">${match.title}</h4>
                        <span class="livetv-match-category">${match.category}</span>
                        <button class="livetv-watch-btn">
                            <i class="fas fa-play"></i> Watch Now
                        </button>
                    </div>
                `;
                
                const watchBtn = card.querySelector('.livetv-watch-btn');
                watchBtn.addEventListener('click', () => openStreamsModal(match));
                
                grid.appendChild(card);
            });
        }
        
        async function openStreamsModal(match) {
            const modal = document.getElementById('livetv-streams-modal');
            const title = document.getElementById('livetv-streams-title');
            const list = document.getElementById('livetv-streams-list');
            
            if (!modal || !title || !list) return;
            
            title.textContent = match.title;
            list.innerHTML = '<div class="livetv-loading"><i class="fas fa-spinner"></i><p>Loading streams...</p></div>';
            modal.style.display = 'flex';
            
            try {
                const allStreams = [];
                
                // Fetch streams from all sources
                if (match.sources && Array.isArray(match.sources)) {
                    for (const source of match.sources) {
                        try {
                            const response = await fetch(`https://streamed.pk/api/stream/${source.source}/${source.id}`);
                            const streams = await response.json();
                            
                            if (Array.isArray(streams)) {
                                streams.forEach(stream => {
                                    allStreams.push({
                                        ...stream,
                                        sourceName: source.source
                                    });
                                });
                            }
                        } catch (err) {
                            console.warn(`Failed to fetch streams from ${source.source}:`, err);
                        }
                    }
                }
                
                if (allStreams.length === 0) {
                    list.innerHTML = '<div class="livetv-empty"><p>No streams available for this match</p></div>';
                    return;
                }
                
                // Render streams
                list.innerHTML = '';
                allStreams.forEach((stream, index) => {
                    const streamItem = document.createElement('div');
                    streamItem.className = 'livetv-stream-item';
                    
                    const language = stream.language || 'Unknown';
                    const viewers = stream.viewers || 0;
                    const hdBadge = stream.hd ? '<span class="livetv-stream-badge hd">HD</span>' : '';
                    
                    streamItem.innerHTML = `
                        <div class="livetv-stream-info">
                            <div class="livetv-stream-source">
                                <i class="fas fa-broadcast-tower"></i> ${stream.sourceName.toUpperCase()} - Stream ${stream.streamNo || index + 1}
                            </div>
                            <div class="livetv-stream-details">
                                ${hdBadge}
                                <span class="livetv-stream-badge language">
                                    <i class="fas fa-language"></i> ${language}
                                </span>
                                <span class="livetv-stream-badge viewers">
                                    <i class="fas fa-users"></i> ${viewers} viewers
                                </span>
                            </div>
                        </div>
                        <div class="livetv-stream-actions">
                            <button class="livetv-copy-link-btn">
                                <i class="fas fa-copy"></i> Copy Link
                            </button>
                            <button class="livetv-open-browser-btn">
                                <i class="fas fa-external-link-alt"></i> Open in Browser
                            </button>
                        </div>
                    `;
                    
                    const copyBtn = streamItem.querySelector('.livetv-copy-link-btn');
                    copyBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        try {
                            await navigator.clipboard.writeText(stream.embedUrl);
                            const originalHTML = copyBtn.innerHTML;
                            copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                            copyBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                            
                            setTimeout(() => {
                                copyBtn.innerHTML = originalHTML;
                                copyBtn.style.background = '';
                            }, 2000);
                        } catch (err) {
                            console.error('Failed to copy:', err);
                        }
                    });
                    
                    const openBtn = streamItem.querySelector('.livetv-open-browser-btn');
                    openBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        try {
                            // Use Electron's shell.openExternal to open in default browser
                            await window.electronAPI.openExternal(stream.embedUrl);
                        } catch (err) {
                            console.error('Failed to open in browser:', err);
                        }
                    });
                    
                    list.appendChild(streamItem);
                });
            } catch (error) {
                console.error('Error loading streams:', error);
                list.innerHTML = '<div class="livetv-empty"><p>Failed to load streams. Please try again.</p></div>';
            }
        }
        

        
    function setupEventListeners() {
            // Initialize Video.js player
            if (typeof videojs !== 'undefined') {
                try {
                    window.vjsPlayer = videojs('customVideo', {
                        controls: false,
                        preload: 'metadata',
                        fluid: false,
                        fill: true
                    });
                    console.log('Video.js initialized');
                } catch (e) {
                    console.warn('Video.js initialization failed:', e);
                }
            }
            
            // API Setup Modal
            saveFirstTimeApiKey.addEventListener('click', saveFirstTimeApiKey_);
            const useTorrentlessSetupBtn = document.getElementById('useTorrentlessSetup');
            if (useTorrentlessSetupBtn) {
                useTorrentlessSetupBtn.addEventListener('click', async () => {
                    try {
                        await fetch(`${API_BASE_URL}/settings`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ useTorrentless: true }) });
                        // Also update local state so searches work immediately without reopening Settings
                        useTorrentless = true;
                        hideApiSetupModal();
                        showNotification('Watch without Jackett enabled.');
                        // If user was in the middle of searching, retry now
                        try {
                            const qEl = document.getElementById('searchInput');
                            const q = qEl && qEl.value ? qEl.value.trim() : '';
                            if (q) await searchMovies(q);
                        } catch(_) {}
                    } catch { showNotification('Failed to enable Watch without Jackett'); }
                });
            }
            const videoTutorialFirstBtn = document.getElementById('videoTutorialFirst');
            if (videoTutorialFirstBtn) {
                videoTutorialFirstBtn.addEventListener('click', async () => {
                    const url = 'https://www.youtube.com/watch?v=3igLReZFFzg';
                    if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(url);
                });
            }
            
            // Donate modal removed
            
            // Discord Modal
            if (discordClose) {
                discordClose.addEventListener('click', hideDiscordModal);
            }
            if (discordJoinBtn) {
                discordJoinBtn.addEventListener('click', async () => {
                    const url = 'https://discord.gg/bbkVHRHnRk';
                    try {
                        if (window.electronAPI?.openExternal) {
                            await window.electronAPI.openExternal(url);
                        } else {
                            window.open(url, '_blank', 'noopener');
                        }
                        // Mark as joined so modal doesn't show again
                        localStorage.setItem('hasJoinedDiscord', 'true');
                        hideDiscordModal();
                        showNotification('Opening Discord invite...', 'success');
                    } catch(err) {
                        console.error('Failed to open Discord:', err);
                        showNotification('Failed to open Discord link', 'error');
                    }
                });
            }
            if (discordDontShowBtn) {
                discordDontShowBtn.addEventListener('click', () => {
                    // Persist user's preference to never show this modal again
                    localStorage.setItem('hasJoinedDiscord', 'true');
                    hideDiscordModal();
                    showNotification("We'll stop showing this.", 'success');
                });
            }
            
            // Update Modal
            const updateClose = document.getElementById('updateClose');
            const updateGotItBtn = document.getElementById('updateGotItBtn');
            if (updateClose) {
                updateClose.addEventListener('click', hideUpdateModal);
            }
            if (updateGotItBtn) {
                updateGotItBtn.addEventListener('click', hideUpdateModal);
            }
            // v1.6.3 Modal
            const version163Close = document.getElementById('version163Close');
            const version163DonateBtn = document.getElementById('version163DonateBtn');
            const version163GotItBtn = document.getElementById('version163GotItBtn');
            version163Close?.addEventListener('click', hideVersion163Modal);
            version163GotItBtn?.addEventListener('click', hideVersion163Modal);
            if (version163DonateBtn) {
                version163DonateBtn.addEventListener('click', async () => {
                    const url = 'https://ko-fi.com/ayman228x';
                    try {
                        if (window.electronAPI?.openExternal) {
                            await window.electronAPI.openExternal(url);
                        } else {
                            window.open(url, '_blank', 'noopener');
                        }
                        hideVersion163Modal();
                        showNotification('Opening Ko-fi...', 'success');
                    } catch(err) {
                        console.error('Failed to open Ko-fi link:', err);
                        showNotification('Failed to open Ko-fi link', 'error');
                    }
                });
            }
            
            if (discordBtn) {
                discordBtn.addEventListener('click', async () => {
                    const url = 'https://discord.gg/bbkVHRHnRk';
                    try {
                        if (window.electronAPI?.openExternal) {
                            await window.electronAPI.openExternal(url);
                        } else {
                            window.open(url, '_blank', 'noopener');
                        }
                        showNotification('Opening Discord...', 'success');
                    } catch(err) {
                        console.error('Failed to open Discord:', err);
                        showNotification('Failed to open Discord link', 'error');
                    }
                });
            }
            // Donate button (persistent)
            const donateBtn = document.getElementById('donateBtn');
            if (donateBtn) {
                donateBtn.addEventListener('click', async () => {
                    const url = 'https://ko-fi.com/ayman228x';
                    try {
                        if (window.electronAPI?.openExternal) {
                            await window.electronAPI.openExternal(url);
                        } else {
                            window.open(url, '_blank', 'noopener');
                        }
                        showNotification('Opening Ko-fi...', 'success');
                    } catch(err) {
                        console.error('Failed to open Ko-fi:', err);
                        showNotification('Failed to open Ko-fi link', 'error');
                    }
                });
            }
            
            // Chromecast Device Modal
            const closeChromecastModal = document.getElementById('close-chromecast-modal');
            if (closeChromecastModal) {
                closeChromecastModal.addEventListener('click', () => {
                    const modal = document.getElementById('chromecast-device-modal');
                    if (modal) {
                        modal.style.display = 'none';
                        modal.classList.remove('active');
                        modal.style.opacity = '0';
                        modal.style.pointerEvents = 'none';
                    }
                });
            }
            
            // Settings Modal
            clearCacheBtn.addEventListener('click', async () => {
                const result = await window.electronAPI.clearCache();
                showNotification(result.message, result.success ? 'success' : 'error');
            });
            // Cache folder browse buttons (attach to ALL instances)
            if (window.electronAPI && window.electronAPI.selectCacheFolder) {
                const selectCacheBtns = document.querySelectorAll('#selectCacheBtn');
                selectCacheBtns.forEach(btn => btn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    try {
                        const result = await window.electronAPI.selectCacheFolder();
                        if (result.success && result.path) {
                            // Prefer the cacheLocation input in the same card/section as the clicked button
                            const scope = btn.closest('.settings-card-body, .api-input-group, .form-group') || document;
                            const scopedInput = scope.querySelector('#cacheLocation');
                            if (scopedInput) {
                                scopedInput.value = result.path;
                            } else {
                                // Fallback: update the visible cacheLocation input
                                const allInputs = document.querySelectorAll('#cacheLocation');
                                let updated = false;
                                for (const input of allInputs) {
                                    if (input.offsetParent !== null) { input.value = result.path; updated = true; break; }
                                }
                                if (!updated && allInputs.length > 0) { allInputs[0].value = result.path; }
                            }
                        }
                    } catch (error) {
                        console.error('Error selecting cache folder:', error);
                        showNotification('Failed to select folder');
                    }
                }));
            }
            // MPV install helpers removed
            settingsClose.addEventListener('click', hideSettingsModal);
            saveSettings.addEventListener('click', saveSettings_);
            cancelSettings.addEventListener('click', hideSettingsModal);
            
            // Settings page buttons
            const saveSettingsPage = document.getElementById('saveSettingsPage');
            const cancelSettingsPage = document.getElementById('cancelSettingsPage');
            if (saveSettingsPage) {
                saveSettingsPage.addEventListener('click', saveSettings_);
            }
            if (cancelSettingsPage) {
                cancelSettingsPage.addEventListener('click', () => {
                    window.history.back();
                });
            }
            
            // Theme selector (attach to all instances - modal and settings page)
            const themeSelectors = document.querySelectorAll('#themeSelector');
            themeSelectors.forEach(themeSelector => {
                if (themeSelector) {
                    themeSelector.addEventListener('change', (e) => {
                        const selectedTheme = e.target.value;
                        applyTheme(selectedTheme);
                        showNotification(`Theme changed to ${e.target.options[e.target.selectedIndex].text}`, 'success');
                    });
                }
            });
            
            const videoTutorialBtns = document.querySelectorAll('#videoTutorialBtn');
            videoTutorialBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                    const url = 'https://www.youtube.com/watch?v=3igLReZFFzg';
                    if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(url);
                });
            });
            
            // Watch without Jackett toggle - attach to ALL instances
            const useTorrentlessToggles = document.querySelectorAll('#useTorrentlessToggle');
            useTorrentlessToggles.forEach(toggle => {
                toggle.addEventListener('change', async (e) => {
                    const enabled = !!e.target.checked;
                    try {
                        const res = await fetch(`${API_BASE_URL}/settings`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ useTorrentless: enabled })
                        });
                        if (res.ok) {
                            useTorrentless = enabled;
                            // Update all other toggles
                            useTorrentlessToggles.forEach(t => t.checked = enabled);
                            showNotification(enabled ? 'Watch without Jackett enabled.' : 'Watch without Jackett disabled.');
                        } else {
                            e.target.checked = !enabled;
                            showNotification('Failed to update setting.');
                        }
                    } catch {
                        e.target.checked = !enabled;
                        showNotification('Failed to update setting.');
                    }
                });
            });
            
            // Torrent source buttons - attach to ALL instances
            const torrentioBtns = document.querySelectorAll('#torrentioBtn');
            const inAppScraperBtns = document.querySelectorAll('#inAppScraperBtn');
            
            if (torrentioBtns.length > 0 && inAppScraperBtns.length > 0) {
                const handleSourceChange = async (source) => {
                    console.log('=================================');
                    console.log('[Settings] Button clicked! Changing source to:', source);
                    try {
                        const res = await fetch(`${API_BASE_URL}/settings`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ torrentSource: source })
                        });
                        const responseData = await res.json();
                        console.log('[Settings] Server response:', responseData);
                        
                        if (res.ok) {
                            // Update UI immediately for ALL button instances
                            if (source === 'torrentio') {
                                torrentioBtns.forEach(btn => btn.classList.add('active'));
                                inAppScraperBtns.forEach(btn => btn.classList.remove('active'));
                                console.log('[Settings] UI updated: Torrentio active');
                            } else {
                                torrentioBtns.forEach(btn => btn.classList.remove('active'));
                                inAppScraperBtns.forEach(btn => btn.classList.add('active'));
                                console.log('[Settings] UI updated: In-App Scraper active');
                            }
                            console.log('[Settings] SUCCESS! Setting saved:', source);
                            console.log('=================================');
                            showNotification(`Torrent source changed to ${source === 'torrentio' ? 'Torrentio' : 'In-App Scraper'}`);
                        } else {
                            console.error('[Settings] FAILED to save setting');
                            console.log('=================================');
                            showNotification('Failed to update torrent source.');
                        }
                    } catch (err) {
                        console.error('[Settings] ERROR:', err);
                        console.log('=================================');
                        showNotification('Failed to update torrent source.');
                    }
                };
                
                torrentioBtns.forEach(btn => {
                    btn.addEventListener('click', () => handleSourceChange('torrentio'));
                });
                inAppScraperBtns.forEach(btn => {
                    btn.addEventListener('click', () => handleSourceChange('in-app-scraper'));
                });
            }

            // Debrid settings
            if (useDebridToggle || debridProviderSel) {
                const onDebridChange = async () => {
                    // Get visible useDebridToggle
                    const useDebridToggles = document.querySelectorAll('#useDebridToggle');
                    let enabled = false;
                    for (const toggle of useDebridToggles) {
                        if (toggle.offsetParent !== null) {
                            enabled = !!toggle.checked;
                            break;
                        }
                    }
                    
                    // Get visible debridProvider
                    const debridProviders = document.querySelectorAll('#debridProvider');
                    let provider = 'realdebrid';
                    for (const select of debridProviders) {
                        if (select.offsetParent !== null) {
                            provider = select.value;
                            break;
                        }
                    }
                    
                    // Get visible rdClientId input
                    const rdClientIdInputs = document.querySelectorAll('#rdClientId');
                    let visibleRdClientId = '';
                    for (const input of rdClientIdInputs) {
                        if (input.offsetParent !== null) {
                            visibleRdClientId = (input.value || '').trim();
                            break;
                        }
                    }
                    const rdClientId = visibleRdClientId;
                    
                    try {
                        const res = await fetch(`${API_BASE_URL}/settings`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ useDebrid: enabled, debridProvider: provider, rdClientId })
                        });
                        if (!res.ok) throw new Error('save failed');

                    
                        await res.json();
                        useDebrid = enabled;
                        debridProvider = provider;
                        // Toggle provider-specific UI blocks for ALL instances
                        const isRD = provider === 'realdebrid';
                        const isAD = provider === 'alldebrid';
                        const isTB = provider === 'torbox';
                        const isPM = provider === 'premiumize';
                        
                        document.querySelectorAll('#rdClientIdGroup').forEach(el => el.style.display = isRD ? '' : 'none');
                        document.querySelectorAll('#rdButtons').forEach(el => el.style.display = isRD ? '' : 'none');
                        document.querySelectorAll('#rdTokenGroup').forEach(el => el.style.display = isRD ? '' : 'none');
                        document.querySelectorAll('#rdTokenButtons').forEach(el => el.style.display = isRD ? '' : 'none');
                        document.querySelectorAll('#rdCodePanel').forEach(el => el.style.display = 'none');
                        document.querySelectorAll('#adSection').forEach(el => el.style.display = isAD ? '' : 'none');
                        document.querySelectorAll('#tbSection').forEach(el => el.style.display = isTB ? '' : 'none');
                        document.querySelectorAll('#pmSection').forEach(el => el.style.display = isPM ? '' : 'none');
                        
                        showNotification('Debrid settings saved.');
                    } catch {
                        showNotification('Failed to save debrid settings');
                    }
                };
                
                // Add event listeners to ALL instances
                const useDebridToggles = document.querySelectorAll('#useDebridToggle');
                useDebridToggles.forEach(toggle => {
                    toggle.addEventListener('change', onDebridChange);
                });
                
                const debridProviders = document.querySelectorAll('#debridProvider');
                debridProviders.forEach(select => {
                    select.addEventListener('change', onDebridChange);
                });
                
                const rdClientIdInputs = document.querySelectorAll('#rdClientId');
                rdClientIdInputs.forEach(input => {
                    input.addEventListener('change', onDebridChange);
                });
            }

            // Attach to ALL duplicate "Save Token" buttons (new + old settings UI)
            {
                const saveDebridTokenBtns = document.querySelectorAll('#saveDebridToken');
                saveDebridTokenBtns.forEach(btn => btn.addEventListener('click', async () => {
                    // Get visible debridToken input
                    const debridTokenInputs = document.querySelectorAll('#debridToken');
                    let token = '';
                    let visibleInput = null;
                    for (const input of debridTokenInputs) {
                        if (input.offsetParent !== null) {
                            token = (input.value || '').trim();
                            visibleInput = input;
                            break;
                        }
                    }
                    
                    if (!token) { showNotification('Enter a token first'); return; }
                    try {
                        const res = await fetch(`${API_BASE_URL}/debrid/token`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token })
                        });
                        if (res.ok) {
                            // Update ALL debridStatus elements
                            document.querySelectorAll('#debridStatus').forEach(status => {
                                status.textContent = 'Logged in';
                            });
                            // Clear ALL debridToken inputs
                            debridTokenInputs.forEach(input => {
                                input.value = '';
                            });
                            showNotification('Debrid token saved.');
                        } else {
                            showNotification('Failed to save token');
                        }
                    } catch { showNotification('Failed to save token'); }
                }));
            }
            // Attach to ALL duplicate "Logout/clear RD token" buttons
            {
                const clearDebridTokenBtns = document.querySelectorAll('#clearDebridToken');
                clearDebridTokenBtns.forEach(btn => btn.addEventListener('click', async () => {
                    try {
                        const res = await fetch(`${API_BASE_URL}/debrid/token`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token: '' })
                        });
                        if (res.ok) {
                            // Update ALL debridStatus elements
                            document.querySelectorAll('#debridStatus').forEach(status => {
                                status.textContent = 'Not logged in';
                            });
                            showNotification('Logged out of Debrid.');
                        } else {
                            showNotification('Failed to logout');
                        }
                    } catch { showNotification('Failed to logout'); }
                }));
            }

            // RD Device-code login handlers
            let rdPollTimer = null;
            function stopRdPolling() { if (rdPollTimer) { clearInterval(rdPollTimer); rdPollTimer = null; } }
            async function beginRdDeviceLogin() {
                try {
                    const clientId = (rdClientIdInput?.value || '').trim();
                    // Allow starting without clientId; server will fall back to stored rdClientId
                    const url = `${API_BASE_URL}/debrid/rd/device-code${clientId ? `?client_id=${encodeURIComponent(clientId)}` : ''}`;
                    const r = await fetch(url);
                    if (!r.ok) {
                        let msg = 'RD device-code start failed';
                        try { const t = await r.json(); if (t?.error) msg = t.error; } catch { try { msg = await r.text(); } catch {} }
                        rdLoginStatusEl.textContent = 'Error starting login';
                        showNotification(msg);
                        return;
                    }
                    const j = await r.json();
                    rdCodePanel.style.display = 'block';
                    rdUserCodeEl.textContent = j.user_code || '----';
                    rdVerifyUrlEl.textContent = j.verification_url || 'https://real-debrid.com/device';
                    rdVerifyUrlEl.href = j.verification_url || 'https://real-debrid.com/device';
                    rdLoginStatusEl.textContent = 'Waiting for approval';
                    const intervalMs = Math.max(3, Number(j.interval || 5)) * 1000;
                    const deviceCode = j.device_code;
                    // Start polling
                    stopRdPolling();
                    rdPollTimer = setInterval(async () => {
                        try {
                            const pr = await fetch(`${API_BASE_URL}/debrid/rd/poll`, {
                                method: 'POST', headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ device_code: deviceCode, client_id: clientId || undefined })
                            });
                            if (pr.ok) {
                                stopRdPolling();
                                rdLoginStatusEl.textContent = 'Logged in!';
                                // Update ALL debridStatus elements
                                document.querySelectorAll('#debridStatus').forEach(status => {
                                    status.textContent = 'Logged in';
                                });
                                debridAuth = true;
                                showNotification('RealDebrid connected');
                                setTimeout(() => { rdCodePanel.style.display = 'none'; }, 800);
                            } else {
                                const txt = await pr.text();
                                if (/expired|invalid/i.test(txt)) {
                                    stopRdPolling();
                                    rdLoginStatusEl.textContent = 'Code expired. Try again.';
                                }
                            }
                        } catch (_) {}
                    }, intervalMs);
                } catch (_) {
                    showNotification('Failed to start device login');
                }
            }
            if (rdDeviceLoginBtn) rdDeviceLoginBtn.addEventListener('click', beginRdDeviceLogin);
            if (rdOpenVerifyBtn) rdOpenVerifyBtn.addEventListener('click', async () => {
                const href = rdVerifyUrlEl?.href || 'https://real-debrid.com/device';
                if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(href);
                else window.open(href, '_blank');
            });
            if (rdCopyCodeBtn) rdCopyCodeBtn.addEventListener('click', async () => {
                try { await navigator.clipboard.writeText(rdUserCodeEl?.textContent || ''); showNotification('Code copied'); } catch(_) {}
            });
            if (rdCancelLoginBtn) rdCancelLoginBtn.addEventListener('click', async () => {
                stopRdPolling(); rdCodePanel.style.display = 'none';
            });

            // AllDebrid PIN login handlers
            let adPollTimer = null, adPin = '', adCheck = '';
            function stopAdPolling() { if (adPollTimer) { clearInterval(adPollTimer); adPollTimer = null; } }
            async function beginAdPinLogin() {
                // If already authenticated with AllDebrid, avoid creating a new API key via PIN
                try {
                    await ensureDebridState();
                } catch {}
                if (useDebrid && debridProvider === 'alldebrid' && debridAuth) {
                    showNotification('Already logged in to AllDebrid');
                    return;
                }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/ad/pin`);
                    const j = await r.json();
                    if (r.ok && j.pin && j.check) {
                        adPin = j.pin; adCheck = j.check;
                        if (adPinPanel) adPinPanel.style.display = 'block';
                        if (adPinCodeEl) adPinCodeEl.textContent = adPin;
                        if (adUserUrlEl) adUserUrlEl.href = j.user_url || 'https://alldebrid.com/pin/';
                        if (adLoginStatusEl) adLoginStatusEl.textContent = 'Waiting';
                        stopAdPolling();
                        adPollTimer = setInterval(async () => {
                            try {
                                const pr = await fetch(`${API_BASE_URL}/debrid/ad/check`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pin: adPin, check: adCheck }) });
                                const pj = await pr.json();
                                if (pr.ok && pj.success) {
                                    stopAdPolling();
                                    // Update ALL debridStatus elements
                                    document.querySelectorAll('#debridStatus').forEach(status => {
                                        status.textContent = 'Logged in';
                                    });
                                    debridAuth = true;
                                    if (adLoginStatusEl) adLoginStatusEl.textContent = 'Logged in!';
                                    showNotification('AllDebrid connected');
                                    setTimeout(() => { if (adPinPanel) adPinPanel.style.display = 'none'; }, 800);
                                } else if (pr.ok) {
                                    // keep waiting
                                } else {
                                    stopAdPolling();
                                    if (adLoginStatusEl) adLoginStatusEl.textContent = pj?.error || 'PIN expired';
                                }
                            } catch (_) {}
                        }, 5000);
                    } else {
                        showNotification(j?.error || 'Failed to start AllDebrid PIN');
                    }
                } catch (_) {
                    showNotification('Failed to start AllDebrid PIN');
                }
            }
            if (adStartPinBtn) adStartPinBtn.addEventListener('click', beginAdPinLogin);
            if (adOpenUserUrlBtn) adOpenUserUrlBtn.addEventListener('click', async () => {
                const href = adUserUrlEl?.href || 'https://alldebrid.com/pin/';
                if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(href); else window.open(href, '_blank');
            });
            if (adCopyPinBtn) adCopyPinBtn.addEventListener('click', async () => { try { await navigator.clipboard.writeText(adPinCodeEl?.textContent || ''); showNotification('PIN copied'); } catch(_) {} });
            if (adCancelPinBtn) adCancelPinBtn.addEventListener('click', () => { stopAdPolling(); if (adPinPanel) adPinPanel.style.display = 'none'; });

            // --- Bind duplicated RD/AD login UIs (new settings panel) ---
            // Helper: find nearest container with a descendant matching a selector using attribute match to avoid global-ID issues
            function qIn(el, sel) { return el ? el.querySelector(sel) : null; }

            // Scoped RD device-code login
            async function beginRdDeviceLoginScoped(buttonEl) {
                const container = buttonEl.closest('#rdButtons')?.parentElement || buttonEl.parentElement;
                const rdClientInput = qIn(container, '[id="rdClientId"]');
                const codePanel = qIn(container, '[id="rdCodePanel"]');
                const userCodeEl = qIn(container, '[id="rdUserCode"]');
                const verifyUrlEl = qIn(container, '[id="rdVerifyUrl"]');
                const loginStatusEl = qIn(container, '[id="rdLoginStatus"]');
                const openVerifyBtn = qIn(container, '[id="rdOpenVerify"]');
                const copyCodeBtn = qIn(container, '[id="rdCopyCode"]');
                const cancelBtn = qIn(container, '[id="rdCancelLogin"]');

                const clientId = (rdClientInput?.value || '').trim();
                const url = `${API_BASE_URL}/debrid/rd/device-code${clientId ? `?client_id=${encodeURIComponent(clientId)}` : ''}`;
                try {
                    const r = await fetch(url);
                    if (!r.ok) {
                        let msg = 'RD device-code start failed';
                        try { const t = await r.json(); if (t?.error) msg = t.error; } catch { try { msg = await r.text(); } catch {} }
                        if (loginStatusEl) loginStatusEl.textContent = 'Error starting login';
                        showNotification(msg);
                        return;
                    }
                    const j = await r.json();
                    if (codePanel) codePanel.style.display = 'block';
                    if (userCodeEl) userCodeEl.textContent = j.user_code || '----';
                    if (verifyUrlEl) { verifyUrlEl.textContent = j.verification_url || 'https://real-debrid.com/device'; verifyUrlEl.href = j.verification_url || 'https://real-debrid.com/device'; }
                    if (loginStatusEl) loginStatusEl.textContent = 'Waiting for approval';
                    const intervalMs = Math.max(3, Number(j.interval || 5)) * 1000;
                    const deviceCode = j.device_code;

                    stopRdPolling();
                    rdPollTimer = setInterval(async () => {
                        try {
                            const pr = await fetch(`${API_BASE_URL}/debrid/rd/poll`, {
                                method: 'POST', headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ device_code: deviceCode, client_id: clientId || undefined })
                            });
                            if (pr.ok) {
                                stopRdPolling();
                                if (loginStatusEl) loginStatusEl.textContent = 'Logged in!';
                                document.querySelectorAll('#debridStatus').forEach(status => { status.textContent = 'Logged in'; });
                                debridAuth = true;
                                // Reflect provider/toggle in all duplicate controls
                                document.querySelectorAll('#useDebridToggle').forEach(cb => { try { cb.checked = true; } catch {} });
                                document.querySelectorAll('#debridProvider').forEach(sel => { try { sel.value = 'realdebrid'; } catch {} });
                                // Persist provider and enable Debrid so caching is used
                                try { await fetch(`${API_BASE_URL}/settings`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ useDebrid: true, debridProvider: 'realdebrid' }) }); } catch {}
                                showNotification('RealDebrid connected');
                                setTimeout(() => { if (codePanel) codePanel.style.display = 'none'; }, 800);
                            } else {
                                const txt = await pr.text();
                                if (/expired|invalid/i.test(txt)) { stopRdPolling(); if (loginStatusEl) loginStatusEl.textContent = 'Code expired. Try again.'; }
                            }
                        } catch (_) {}
                    }, intervalMs);

                    // Bind inline controls once
                    if (container && !container.dataset.rdBound) {
                        container.dataset.rdBound = '1';
                        if (openVerifyBtn) openVerifyBtn.addEventListener('click', async () => {
                            const href = verifyUrlEl?.href || 'https://real-debrid.com/device';
                            if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(href); else window.open(href, '_blank');
                        });
                        if (copyCodeBtn) copyCodeBtn.addEventListener('click', async () => { try { await navigator.clipboard.writeText(userCodeEl?.textContent || ''); showNotification('Code copied'); } catch(_) {} });
                        if (cancelBtn) cancelBtn.addEventListener('click', () => { stopRdPolling(); if (codePanel) codePanel.style.display = 'none'; });
                    }
                } catch (_) {
                    showNotification('Failed to start device login');
                }
            }

            // Scoped AllDebrid PIN login
            async function beginAdPinLoginScoped(buttonEl) {
                const container = buttonEl.closest('#adSection') || buttonEl.parentElement;
                const pinPanel = qIn(container, '[id="adPinPanel"]');
                const pinCodeEl = qIn(container, '[id="adPinCode"]');
                const userUrlEl = qIn(container, '[id="adUserUrl"]');
                const loginStatusEl = qIn(container, '[id="adLoginStatus"]');
                const openUserBtn = qIn(container, '[id="adOpenUserUrl"]');
                const copyPinBtn = qIn(container, '[id="adCopyPin"]');
                const cancelBtn = qIn(container, '[id="adCancelPin"]');

                try { await ensureDebridState(); } catch {}
                if (useDebrid && debridProvider === 'alldebrid' && debridAuth) { showNotification('Already logged in to AllDebrid'); return; }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/ad/pin`);
                    const j = await r.json();
                    if (r.ok && j.pin && j.check) {
                        adPin = j.pin; adCheck = j.check;
                        if (pinPanel) pinPanel.style.display = 'block';
                        if (pinCodeEl) pinCodeEl.textContent = adPin;
                        if (userUrlEl) userUrlEl.href = j.user_url || 'https://alldebrid.com/pin/';
                        if (loginStatusEl) loginStatusEl.textContent = 'Waiting';
                        stopAdPolling();
                        adPollTimer = setInterval(async () => {
                            try {
                                const pr = await fetch(`${API_BASE_URL}/debrid/ad/check`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pin: adPin, check: adCheck }) });
                                const pj = await pr.json();
                                if (pr.ok && pj.success) {
                                    stopAdPolling();
                                    document.querySelectorAll('#debridStatus').forEach(status => { status.textContent = 'Logged in'; });
                                    debridAuth = true;
                                    if (loginStatusEl) loginStatusEl.textContent = 'Logged in!';
                                    // Reflect provider/toggle in all duplicate controls
                                    document.querySelectorAll('#useDebridToggle').forEach(cb => { try { cb.checked = true; } catch {} });
                                    document.querySelectorAll('#debridProvider').forEach(sel => { try { sel.value = 'alldebrid'; } catch {} });
                                    // Persist provider and enable Debrid
                                    try { await fetch(`${API_BASE_URL}/settings`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ useDebrid: true, debridProvider: 'alldebrid' }) }); } catch {}
                                    showNotification('AllDebrid connected');
                                    setTimeout(() => { if (pinPanel) pinPanel.style.display = 'none'; }, 800);
                                } else if (!pr.ok) {
                                    stopAdPolling();
                                    if (loginStatusEl) loginStatusEl.textContent = pj?.error || 'PIN expired';
                                }
                            } catch (_) {}
                        }, 5000);

                        if (container && !container.dataset.adBound) {
                            container.dataset.adBound = '1';
                            if (openUserBtn) openUserBtn.addEventListener('click', async () => { const href = userUrlEl?.href || 'https://alldebrid.com/pin/'; if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(href); else window.open(href, '_blank'); });
                            if (copyPinBtn) copyPinBtn.addEventListener('click', async () => { try { await navigator.clipboard.writeText(pinCodeEl?.textContent || ''); showNotification('PIN copied'); } catch(_) {} });
                            if (cancelBtn) cancelBtn.addEventListener('click', () => { stopAdPolling(); if (pinPanel) pinPanel.style.display = 'none'; });
                        }
                    } else {
                        showNotification(j?.error || 'Failed to start AllDebrid PIN');
                    }
                } catch (_) {
                    showNotification('Failed to start AllDebrid PIN');
                }
            }

            // Attach scoped handlers to ALL duplicates
            document.querySelectorAll('#rdDeviceLogin').forEach(btn => {
                if (!btn.dataset.boundRd) { btn.dataset.boundRd = '1'; btn.addEventListener('click', () => beginRdDeviceLoginScoped(btn)); }
            });
            document.querySelectorAll('#adStartPin').forEach(btn => {
                if (!btn.dataset.boundAd) { btn.dataset.boundAd = '1'; btn.addEventListener('click', () => beginAdPinLoginScoped(btn)); }
            });
            // Attach to ALL duplicate AllDebrid Save buttons
            document.querySelectorAll('#adSaveApiKey').forEach(btn => btn.addEventListener('click', async () => {
                // Get visible adApiKey input
                const adApiKeyInputs = document.querySelectorAll('#adApiKey');
                let apikey = '';
                for (const input of adApiKeyInputs) {
                    if (input.offsetParent !== null) {
                        apikey = (input.value || '').trim();
                        break;
                    }
                }
                
                if (!apikey) { showNotification('Enter an AllDebrid API key'); return; }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/ad/apikey`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apikey }) });
                    if (r.ok) { 
                        // Update ALL debridStatus elements
                        document.querySelectorAll('#debridStatus').forEach(status => {
                            status.textContent = 'Logged in';
                        });
                        showNotification('AllDebrid API key saved');
                        // Clear ALL adApiKey inputs
                        adApiKeyInputs.forEach(input => { input.value = ''; });
                    }
                    else { const t = await r.text(); showNotification(t || 'Failed to save'); }
                } catch { showNotification('Failed to save'); }
            }));
            // Attach to ALL duplicate AllDebrid Logout buttons
            document.querySelectorAll('#adClearApiKey').forEach(btn => btn.addEventListener('click', async () => {
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/ad/apikey`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apikey: '' }) });
                    if (r.ok) { 
                        // Update ALL debridStatus elements
                        document.querySelectorAll('#debridStatus').forEach(status => {
                            status.textContent = 'Not logged in';
                        });
                        showNotification('Logged out of AllDebrid'); 
                    }
                } catch {}
            }));

            // TorBox: save/clear token
            // Attach to ALL duplicate TorBox Save buttons
            document.querySelectorAll('#tbSaveToken').forEach(btn => btn.addEventListener('click', async () => {
                // Get visible tbToken input
                const tbTokenInputs = document.querySelectorAll('#tbToken');
                let token = '';
                for (const input of tbTokenInputs) {
                    if (input.offsetParent !== null) {
                        token = (input.value || '').trim();
                        break;
                    }
                }
                
                if (!token) { showNotification('Enter a TorBox token'); return; }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/tb/token`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token }) });
                    if (r.ok) { 
                        // Update ALL debridStatus elements
                        document.querySelectorAll('#debridStatus').forEach(status => {
                            status.textContent = 'Logged in';
                        });
                        // Clear ALL tbToken inputs
                        tbTokenInputs.forEach(input => { input.value = ''; });
                        showNotification('TorBox token saved'); 
                    }
                    else { const t = await r.text(); showNotification(t || 'Failed to save'); }
                } catch { showNotification('Failed to save'); }
            }));
            // Attach to ALL duplicate TorBox Logout buttons
            document.querySelectorAll('#tbClearToken').forEach(btn => btn.addEventListener('click', async () => {
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/tb/token`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token: '' }) });
                    if (r.ok) { 
                        // Update ALL debridStatus elements
                        document.querySelectorAll('#debridStatus').forEach(status => {
                            status.textContent = 'Not logged in';
                        });
                        showNotification('Logged out of TorBox'); 
                    }
                } catch {}
            }));

            // Premiumize: save/clear API key
            // Attach to ALL duplicate Premiumize Save buttons
            document.querySelectorAll('#pmSaveApiKey').forEach(btn => btn.addEventListener('click', async () => {
                // Get visible pmApiKey input
                const pmApiKeyInputs = document.querySelectorAll('#pmApiKey');
                let apikey = '';
                for (const input of pmApiKeyInputs) {
                    if (input.offsetParent !== null) {
                        apikey = (input.value || '').trim();
                        break;
                    }
                }
                
                if (!apikey) { showNotification('Enter a Premiumize API key'); return; }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/pm/apikey`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apikey }) });
                    if (r.ok) { 
                        // Update ALL debridStatus elements
                        document.querySelectorAll('#debridStatus').forEach(status => {
                            status.textContent = 'Logged in';
                        });
                        // Clear ALL pmApiKey inputs
                        pmApiKeyInputs.forEach(input => { input.value = ''; });
                        showNotification('Premiumize API key saved'); 
                    }
                    else { const t = await r.text(); showNotification(t || 'Failed to save'); }
                } catch { showNotification('Failed to save'); }
            }));
            // Attach to ALL duplicate Premiumize Logout buttons
            document.querySelectorAll('#pmClearApiKey').forEach(btn => btn.addEventListener('click', async () => {
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/pm/apikey`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apikey: '' }) });
                    if (r.ok) { 
                        // Update ALL debridStatus elements
                        document.querySelectorAll('#debridStatus').forEach(status => {
                            status.textContent = 'Not logged in';
                        });
                        showNotification('Logged out of Premiumize'); 
                    }
                } catch {}
            }));

            // ===== FEBBOX TOKEN EVENT LISTENER =====
            
            // Febbox token (attach to ALL duplicate inputs/buttons)
            const febboxInputs = document.querySelectorAll('#febboxTokenInput');
            const savedFebboxToken = localStorage.getItem('febboxToken');
            if (savedFebboxToken) {
                febboxInputs.forEach(inp => { try { inp.value = savedFebboxToken; } catch(_){} });
            }
            const saveFebboxBtns = document.querySelectorAll('#saveFebboxToken');
            saveFebboxBtns.forEach(btn => btn.addEventListener('click', () => {
                // Prefer token from the input in the same card/section as the clicked button
                const scope = btn.closest('.settings-card-body, .api-input-group, .form-group') || document;
                let input = scope.querySelector('#febboxTokenInput');
                if (!input) {
                    // Fallback: use the visible input if any
                    for (const el of febboxInputs) { if (el.offsetParent !== null) { input = el; break; } }
                }
                const token = (input?.value || '').trim();
                if (token) {
                    localStorage.setItem('febboxToken', token);
                    // Reflect into all duplicate inputs for consistency
                    febboxInputs.forEach(inp => { try { inp.value = token; } catch(_){} });
                    showNotification('Febbox token saved successfully', 'success');
                } else {
                    localStorage.removeItem('febboxToken');
                    febboxInputs.forEach(inp => { try { inp.value = ''; } catch(_){} });
                    showNotification('Febbox token cleared, using default', 'success');
                }
            }));

            // ===== TRAKT EVENT LISTENERS - attach to ALL instances =====
            
            const traktLoginBtns = document.querySelectorAll('#traktLogin');
            const traktDisconnectBtns = document.querySelectorAll('#traktDisconnect');
            const traktCopyCodeBtns = document.querySelectorAll('#traktCopyCode');
            const traktOpenVerifyBtns = document.querySelectorAll('#traktOpenVerify');
            const traktCancelLoginBtns = document.querySelectorAll('#traktCancelLogin');
            
            traktLoginBtns.forEach(btn => btn.addEventListener('click', startTraktLogin));
            traktDisconnectBtns.forEach(btn => btn.addEventListener('click', disconnectTrakt));
            traktCopyCodeBtns.forEach(btn => btn.addEventListener('click', copyTraktCode));
            traktOpenVerifyBtns.forEach(btn => btn.addEventListener('click', openTraktVerify));
            traktCancelLoginBtns.forEach(btn => btn.addEventListener('click', cancelTraktLogin));
            
            const traktViewWatchlistBtns = document.querySelectorAll('#traktViewWatchlist');
            traktViewWatchlistBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                try {
                    const response = await fetch('/api/trakt/watchlist?type=mixed');
                    const data = await response.json();
                    
                    if (data.success && data.watchlist) {
                        showNotification(`Found ${data.watchlist.length} items in your watchlist`, 'info');
                        // TODO: Could open a modal to show watchlist items
                        console.log('[TRAKT] Watchlist:', data.watchlist);
                    } else {
                        showNotification('Failed to load watchlist', 'error');
                    }
                } catch (error) {
                    console.error('[TRAKT] Watchlist error:', error);
                    showNotification('Failed to load watchlist', 'error');
                }
                });
            });
            
            const traktViewHistoryBtns = document.querySelectorAll('#traktViewHistory');
            traktViewHistoryBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                try {
                    const response = await fetch('/api/trakt/history?type=mixed&limit=20');
                    const data = await response.json();
                    
                    if (data.success && data.history) {
                        showNotification(`Loaded ${data.history.length} recent items from your history`, 'info');
                        console.log('[TRAKT] History:', data.history);
                    } else {
                        showNotification('Failed to load history', 'error');
                    }
                } catch (error) {
                    console.error('[TRAKT] History error:', error);
                    showNotification('Failed to load history', 'error');
                }
                });
            });
            
            const traktViewStatsBtns = document.querySelectorAll('#traktViewStats');
            traktViewStatsBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                try {
                    const response = await fetch('/api/trakt/stats');
                    const data = await response.json();
                    
                    if (data.success && data.stats) {
                        const stats = data.stats;
                        const message = `Movies: ${stats.movies?.watched || 0} watched, Shows: ${stats.shows?.watched || 0} watched, Episodes: ${stats.episodes?.watched || 0} watched`;
                        showNotification(message, 'info', 5000);
                        console.log('[TRAKT] Stats:', stats);
                    } else {
                        showNotification('Failed to load stats', 'error');
                    }
                } catch (error) {
                    console.error('[TRAKT] Stats error:', error);
                    showNotification('Failed to load stats', 'error');
                }
                });
            });

            // ===== END TRAKT EVENT LISTENERS =====

            // Open Jackett installer link in default browser
            if (openJackettLinkBtn) {
                openJackettLinkBtn.addEventListener('click', async () => {
                    const url = 'https://github.com/Jackett/Jackett/releases/latest/download/Jackett.Installer.Windows.exe';
                    if (window.electronAPI?.openExternal) {
                        const res = await window.electronAPI.openExternal(url);
                        if (!res?.success) {
                            showNotification('Failed to open browser. Copying link to clipboard.');
                            try { await navigator.clipboard.writeText(url); } catch {}
                        }
                    } else {
                        // Fallback: copy link if preload is unavailable
                        showNotification('Copying link to clipboard. Open it in your browser.');
                        try { await navigator.clipboard.writeText(url); } catch {}
                    }
                });
            }
            
            // Close modals on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    // Check in priority order and stop after handling one
                    if (mpvPlayerContainer.classList.contains('active')) {
                        e.preventDefault();
                        e.stopPropagation();
                        closePlayer(false); // Don't show notification when using Escape
                    }
                    else if (settingsModal.classList.contains('active')) {
                        e.preventDefault();
                        e.stopPropagation();
                        hideSettingsModal();
                    }
                    else if (apiSetupModal.classList.contains('active') && hasApiKey) {
                        e.preventDefault();
                        e.stopPropagation();
                        hideApiSetupModal();
                    }
                }
            });
            
            // Enter key for API inputs
            firstTimeApiKey.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveFirstTimeApiKey_();
                }
            });
            
            newApiKey.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveSettings_();
                }
            });

            // Search input
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('keypress', async (e) => {
                if (e.key === 'Enter' && searchInput.value.trim() !== '') {
                    e.preventDefault();
                    const query = searchInput.value.trim();
                    // Navigate to home for search to display results clearly
                    if (activeRoute !== 'home') {
                        window.location.hash = '#/';
                    }
                    await searchMovies(query);
                }
            });

            // Genres navigation
            genresBtn.addEventListener('click', () => {
                window.location.hash = '#/genres';
            });

            // My List navigation
            const myListBtn = document.getElementById('myListBtn');
            if (myListBtn) {
                myListBtn.addEventListener('click', () => {
                    window.location.hash = '#/my-list';
                });
            }

            // Done Watching navigation
            const doneWatchingBtn = document.getElementById('doneWatchingBtn');
            if (doneWatchingBtn) {
                doneWatchingBtn.addEventListener('click', () => {
                    window.location.hash = '#/done-watching';
                });
            }

            // Router: hash change
            window.addEventListener('hashchange', handleRoute);

            // Infinite scroll - performant listeners with rAF throttle and passive mode
            let __scrollScheduled = false;
            function __handleScrollRaf(e) {
                if (__scrollScheduled) return;
                __scrollScheduled = true;
                requestAnimationFrame(() => {
                    try { handleScroll(e); } finally { __scrollScheduled = false; }
                });
            }
            // Attach based on current UI mode to avoid duplicate listeners
            if (document.body.classList.contains('ui-new')) {
                const appMainElement = document.querySelector('.app-main main');
                if (appMainElement) appMainElement.addEventListener('scroll', __handleScrollRaf, { passive: true });
            } else {
                window.addEventListener('scroll', __handleScrollRaf, { passive: true });
            }
            
            // Modal close
            modalClose.addEventListener('click', closeModal);
            
            // Player close
            closePlayerBtn.addEventListener('click', closePlayer);
            
            // Custom Player close
            closeCustomPlayer.addEventListener('click', closeCustomPlayer_);
            
            // Watch now button
            watchNowBtn.addEventListener('click', (e) => {
                console.log('[DEBUG] Watch button clicked!');
                try {
                    const streamingMode = localStorage.getItem('useStreamingServers') === 'true';
                    if (streamingMode && currentMediaType === 'movie') {
                        // Build mediaData for server selection
                        const mediaData = {
                            id: currentContent?.id,
                            type: 'movie',
                            title: currentContent?.title || currentContent?.name || 'Untitled',
                            subtitle: '',
                            year: (currentContent?.release_date || currentContent?.first_air_date || '').substring(0,4),
                            rating: Number(currentContent?.vote_average || 0).toFixed(1),
                            poster: currentContent?.poster_path ? `https://image.tmdb.org/t/p/w342${currentContent.poster_path}` : ''
                        };
                        showServerSelection(mediaData);
                    } else {
                        showTorrents(e);
                        // Auto-scroll to provider buttons for quick access
                        setTimeout(() => {
                            const pb = document.querySelector('.provider-buttons');
                            if (pb) pb.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }, 200);
                    }
                } catch (error) {
                    console.error('[DEBUG] Error in Watch Now handler:', error);
                }
            });

            // Toggle streaming mode from details modal
            const useStreamsBtn = document.getElementById('useStreamsBtn');
            if (useStreamsBtn) {
                useStreamsBtn.addEventListener('click', () => {
                    const current = localStorage.getItem('useStreamingServers') === 'true';
                    const next = !current;
                    localStorage.setItem('useStreamingServers', next ? 'true' : 'false');
                    // Sync settings toggles in the UI
                    const toggles = document.querySelectorAll('#useStreamingServersToggle');
                    toggles.forEach(t => t.checked = next);
                    // Update main button text and hint
                    updateWatchButtonText();
                    showNotification(`Streaming mode ${next ? 'enabled' : 'disabled'}`, next ? 'success' : 'info');
                });
            }
            
            // Refresh torrents
            refreshTorrents.addEventListener('click', () => {
                torrentsLoaded = false;
                fetchTorrents(lastSearchedSeason, lastSearchedEpisode);
            });
            
            // Sort selector for torrents
            const torrentSortSelect = document.getElementById('torrentSortSelect');
            function handleSortChange() {
                const newMode = torrentSortSelect ? torrentSortSelect.value : 'seeders';
                console.log('[SORT] Changing from', torrentSortMode, 'to', newMode);
                torrentSortMode = newMode;
                try { if (typeof torrentsPage === 'number') torrentsPage = 1; } catch(_) {}
                
                // Re-render based on active provider
                if (selectedProvider === 'nuvio' && allNuvioStreams.length > 0) {
                    console.log('[SORT] Re-rendering Nuvio streams with mode:', torrentSortMode);
                    try { displayNuvioStreams(allNuvioStreams); } catch(_) {}
                } else if (selectedProvider === 'moviebox') {
                    console.log('[SORT] Skipping re-render for provider:', selectedProvider, '(sorting not supported)');
                    return;
                } else if (selectedProvider === '111477' && window._last111477Files) {
                    console.log('[SORT] Re-rendering 111477 files with mode:', torrentSortMode);
                    try { render111477Files(window._last111477Files); } catch(_) {}
                } else {
                    // Comet, Jackett, Torrentio, PlayTorrio all use standard torrent rendering
                    console.log('[SORT] Re-rendering torrents page with mode:', torrentSortMode);
                    try { renderTorrentsPage(); } catch(_) {}
                }
            }
            if (torrentSortSelect) {
                torrentSortSelect.addEventListener('change', handleSortChange);
                // Fire during selection as well for more immediate updates in some environments
                torrentSortSelect.addEventListener('input', handleSortChange);
            }

            // Size filter selector for torrents
            const torrentSizeFilterSelect = document.getElementById('torrentSizeFilterSelect');
            function handleSizeFilterChange() {
                torrentSizeFilter = (torrentSizeFilterSelect && torrentSizeFilterSelect.value) ? torrentSizeFilterSelect.value : 'all';
                console.log('[FILTER] Size filter changed to:', torrentSizeFilter);
                try { if (typeof torrentsPage === 'number') torrentsPage = 1; } catch(_) {}
                
                // Re-render based on active provider
                if (selectedProvider === 'nuvio' && allNuvioStreams.length > 0) {
                    console.log('[FILTER] Re-rendering Nuvio streams with filter:', torrentSizeFilter);
                    try { displayNuvioStreams(allNuvioStreams); } catch(_) {}
                } else if (selectedProvider === 'moviebox') {
                    console.log('[FILTER] Skipping re-render for provider:', selectedProvider, '(filtering not supported)');
                    return;
                } else if (selectedProvider === '111477' && window._last111477Files) {
                    console.log('[FILTER] Re-rendering 111477 files with filter:', torrentSizeFilter);
                    try { render111477Files(window._last111477Files); } catch(_) {}
                } else {
                    // Comet, Jackett, Torrentio, PlayTorrio all use standard torrent rendering
                    console.log('[FILTER] Re-rendering torrents page with filter:', torrentSizeFilter);
                    try { renderTorrentsPage(); } catch(_) {}
                }
            }
            if (torrentSizeFilterSelect) {
                torrentSizeFilterSelect.addEventListener('change', handleSizeFilterChange);
                // Fire during selection as well for more immediate updates in some environments
                torrentSizeFilterSelect.addEventListener('input', handleSizeFilterChange);
            }
            
            // Provider buttons
            document.querySelectorAll('.provider-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Update active state
                    document.querySelectorAll('.provider-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Update selected provider
                    selectedProvider = btn.dataset.provider;
                    console.log('[Provider] Switched to:', selectedProvider);

                    // Always show a searching indicator immediately
                    try {
                        const tl = document.getElementById('torrentsList');
                        if (tl) {
                            const label = selectedProvider === 'moviebox' ? 'MovieBox' :
                                          selectedProvider === 'nuvio' ? 'Nuvio' :
                                          selectedProvider === 'comet' ? 'Comet' :
                                          selectedProvider === '111477' ? '111477' : 'torrents';
                            tl.innerHTML = `<div class="loading"><i class="fas fa-spinner"></i> Searching ${label}...</div>`;
                        }
                    } catch(_) {}

                    // Fetch with new provider using last searched parameters; call MovieBox directly to avoid any gating
                    torrentsLoaded = false;
                    if (selectedProvider === 'moviebox') {
                        fetchMovieBoxStreams(lastSearchedSeason, lastSearchedEpisode);
                    } else {
                        fetchTorrents(lastSearchedSeason, lastSearchedEpisode);
                    }
                });
            });
            
            // Keyword filter for torrents
            if (torrentKeywordFilter) {
                torrentKeywordFilter.addEventListener('input', () => {
                    torrentsPage = 1; // Reset to first page when filtering
                    renderTorrentsPage();
                });
            }
            
            // MPV Controls
            // Resume modal elements
            const resumeModal = document.getElementById('resumeModal');
            const resumeClose = document.getElementById('resumeClose');
            const resumeTimeEl = document.getElementById('resumeTime');
            const resumeContinue = document.getElementById('resumeContinue');
            const resumeStartOver = document.getElementById('resumeStartOver');

            function formatResumeSeconds(s) { try { return formatTime(Math.floor(Number(s||0))); } catch(_) { return '00:00'; } }
            function hideResumeModal(){ resumeModal?.classList.remove('active'); }
            function showResumeModal(){ resumeModal?.classList.add('active'); }

            // Dismiss on outside click
            if (resumeModal) {
                resumeModal.addEventListener('click', (e) => {
                    if (e.target === resumeModal) {
                        hideResumeModal();
                    }
                });
                // prevent bubbling from content
                const rc = resumeModal.querySelector('.modal-content');
                if (rc) rc.addEventListener('click', (e) => e.stopPropagation());
            }

            async function handlePlayNowClick() {
                // Ensure we have latest resume info; fetch if not present
                let res = resumeInfo;
                if ((!res || typeof res.position !== 'number') && resumeKey) {
                    try { res = await fetchResume(resumeKey); } catch(_) {}
                }
                if (res && typeof res.position === 'number' && res.position > 0) {
                    resumeInfo = res; // keep in sync
                    resumeTimeEl.textContent = formatResumeSeconds(res.position);
                    showResumeModal();
                    // Wire temp listeners
                    const onCont = async () => {
                        // Immediately persist current resume snapshot so a record exists right away
                        try {
                            if (resumeKey && resumeInfo && typeof resumeInfo.position === 'number') {
                                const title = currentSelectedVideoName || (currentContent?.title || currentContent?.name || '');
                                await fetch(`${API_BASE_URL}/resume`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: resumeKey, position: Math.floor(resumeInfo.position || 0), duration: Math.floor(resumeInfo.duration || 0), title }) });
                            }
                        } catch(_) {}
                        hideResumeModal();
                        openCustomPlayer();
                        cleanup();
                    };
                    const onOver = async () => {
                        try { if (resumeKey) await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(resumeKey)}`, { method: 'DELETE' }); } catch(_){ }
                        // Reset local resume so player starts at 0
                        resumeInfo = null;
                        hideResumeModal();
                        openCustomPlayer();
                        // As soon as playback begins, record fresh progress so quitting early is remembered
                        try {
                            const onFirst = () => { try { saveResumeThrottled(true); } catch(_) {} customVideo.removeEventListener('timeupdate', onFirst); };
                            customVideo.addEventListener('timeupdate', onFirst);
                        } catch(_) {}
                        cleanup();
                    };
                    const cleanup = () => {
                        resumeContinue.removeEventListener('click', onCont);
                        resumeStartOver.removeEventListener('click', onOver);
                        resumeClose.removeEventListener('click', onClose);
                        document.removeEventListener('keydown', onEsc);
                    };
                    const onClose = () => { hideResumeModal(); cleanup(); };
                    const onEsc = (e) => { if (e.key === 'Escape') { hideResumeModal(); cleanup(); } };
                    resumeContinue.addEventListener('click', onCont);
                    resumeStartOver.addEventListener('click', onOver);
                    resumeClose.addEventListener('click', onClose);
                    document.addEventListener('keydown', onEsc);
                    return;
                }
                openCustomPlayer();
            }

            async function handleOpenMPVClick() {
                // Ensure we have latest resume info; fetch if not present
                let res = resumeInfo;
                if ((!res || typeof res.position !== 'number') && resumeKey) {
                    try { res = await fetchResume(resumeKey); } catch(_) {}
                }
                if (res && typeof res.position === 'number' && res.position > 0) {
                    resumeInfo = res;
                    resumeTimeEl.textContent = formatResumeSeconds(res.position);
                    showResumeModal();
                    const onCont = async () => {
                        // Immediately persist current resume snapshot for MPV continue
                        try {
                            if (resumeKey && resumeInfo && typeof resumeInfo.position === 'number') {
                                const title = currentSelectedVideoName || (currentContent?.title || currentContent?.name || '');
                                await fetch(`${API_BASE_URL}/resume`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: resumeKey, position: Math.floor(resumeInfo.position || 0), duration: Math.floor(resumeInfo.duration || 0), title }) });
                            }
                        } catch(_) {}
                        hideResumeModal();
                        await openInMPV();
                        cleanup();
                    };
                    const onOver = async () => {
                        try { if (resumeKey) await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(resumeKey)}`, { method: 'DELETE' }); } catch(_){ }
                        resumeInfo = null; // start from 0
                        hideResumeModal();
                        await openInMPV();
                        cleanup();
                    };
                    const cleanup = () => {
                        resumeContinue.removeEventListener('click', onCont);
                        resumeStartOver.removeEventListener('click', onOver);
                        resumeClose.removeEventListener('click', onClose);
                        document.removeEventListener('keydown', onEsc);
                    };
                    const onClose = () => { hideResumeModal(); cleanup(); };
                    const onEsc = (e) => { if (e.key === 'Escape') { hideResumeModal(); cleanup(); } };
                    resumeContinue.addEventListener('click', onCont);
                    resumeStartOver.addEventListener('click', onOver);
                    resumeClose.addEventListener('click', onClose);
                    document.addEventListener('keydown', onEsc);
                    return;
                }
                await openInMPV();
            }

            openMPVBtn.addEventListener('click', handleOpenMPVClick);
            // Mirror resume prompt flow for VLC
            async function handleOpenVLCClick() {
                let res = resumeInfo;
                if ((!res || typeof res.position !== 'number') && resumeKey) {
                    try { res = await fetchResume(resumeKey); } catch(_) {}
                }
                if (res && typeof res.position === 'number' && res.position > 0) {
                    resumeInfo = res;
                    resumeTimeEl.textContent = formatResumeSeconds(res.position);
                    showResumeModal();
                    const onCont = async () => {
                        try {
                            if (resumeKey && resumeInfo && typeof resumeInfo.position === 'number') {
                                const title = currentSelectedVideoName || (currentContent?.title || currentContent?.name || '');
                                await fetch(`${API_BASE_URL}/resume`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: resumeKey, position: Math.floor(resumeInfo.position || 0), duration: Math.floor(resumeInfo.duration || 0), title }) });
                            }
                        } catch(_) {}
                        hideResumeModal();
                        await openInVLC();
                        cleanup();
                    };
                    const onOver = async () => {
                        try { if (resumeKey) await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(resumeKey)}`, { method: 'DELETE' }); } catch(_){ }
                        resumeInfo = null;
                        hideResumeModal();
                        await openInVLC();
                        cleanup();
                    };
                    const cleanup = () => {
                        resumeContinue.removeEventListener('click', onCont);
                        resumeStartOver.removeEventListener('click', onOver);
                        resumeClose.removeEventListener('click', onClose);
                        document.removeEventListener('keydown', onEsc);
                    };
                    const onClose = () => { hideResumeModal(); cleanup(); };
                    const onEsc = (e) => { if (e.key === 'Escape') { hideResumeModal(); cleanup(); } };
                    resumeContinue.addEventListener('click', onCont);
                    resumeStartOver.addEventListener('click', onOver);
                    resumeClose.addEventListener('click', onClose);
                    document.addEventListener('keydown', onEsc);
                    return;
                }
                await openInVLC();
            }

            if (openVLCBtn) openVLCBtn.addEventListener('click', handleOpenVLCClick);
            copyStreamBtn.addEventListener('click', copyStreamUrl);
            playNowBtn.addEventListener('click', handlePlayNowClick);
            
            // Chromecast button (in MPV controls) - uses backend catt
            const castToChromecastBtn = document.getElementById('castToChromecastBtn');
            if (castToChromecastBtn) {
                castToChromecastBtn.addEventListener('click', castMPVToChromecast);
            }
            
            // Custom Player Controls
            playPauseBtn.addEventListener('click', togglePlayPause);
            rewindBtn.addEventListener('click', () => skipTime(-10));
            forwardBtn.addEventListener('click', () => skipTime(10));
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            
            // Cast button (in custom player controls) - uses Google Cast SDK
            const castBtn = document.getElementById('castBtn');
            if (castBtn) {
                castBtn.addEventListener('click', castToChromecast);
            }
            
            progressBar.addEventListener('click', seekVideo);
            subtitleFile.addEventListener('change', handleSubtitleUpload);
            // HTML5 audio controls
            htmlVolume.addEventListener('input', () => { customVideo.volume = Math.max(0, Math.min(1, Number(htmlVolume.value) / 100)); });
            htmlMuteBtn.addEventListener('click', () => { customVideo.muted = !customVideo.muted; htmlMuteBtn.innerHTML = customVideo.muted ? '<i class="fas fa-volume-mute"></i>' : '<i class="fas fa-volume-up"></i>'; });
            // HTML5 Subtitles menu
            htmlSubsBtn.addEventListener('click', () => {
                if (htmlSubsPanel.style.display === 'block') htmlSubsPanel.style.display = 'none';
                else { 
                    htmlSubsPanel.style.display = 'block'; 
                    fetchAndRenderHtmlSubs();
                    updateSubtitleControlDisplays();
                }
            });
            htmlSubsClose.addEventListener('click', () => htmlSubsPanel.style.display = 'none');
            
            // Subtitle customization controls
            if (htmlSubsUploadBtn && subtitleFile) {
                htmlSubsUploadBtn.addEventListener('click', () => subtitleFile.click());
            }
            
            if (subsSizeInput) {
                subsSizeInput.addEventListener('input', () => {
                    subtitleSettings.size = Number(subsSizeInput.value);
                    updateSubtitleControlDisplays();
                    applySubtitleSettings();
                });
            }
            
            if (subsColorInput) {
                subsColorInput.addEventListener('input', () => {
                    subtitleSettings.color = subsColorInput.value;
                    applySubtitleSettings();
                });
            }
            
            if (subsBackgroundInput) {
                subsBackgroundInput.addEventListener('input', () => {
                    subtitleSettings.background = subsBackgroundInput.value;
                    applySubtitleSettings();
                });
            }
            
            if (subsBackgroundOpacityInput) {
                subsBackgroundOpacityInput.addEventListener('input', () => {
                    subtitleSettings.backgroundOpacity = Number(subsBackgroundOpacityInput.value);
                    updateSubtitleControlDisplays();
                    applySubtitleSettings();
                });
            }
            
            if (subsFontSelect) {
                subsFontSelect.addEventListener('change', () => {
                    subtitleSettings.font = subsFontSelect.value;
                    applySubtitleSettings();
                });
            }
            
            // WCJS Controls
            closeWcjsPlayer.addEventListener('click', closeWCJSPlayer);
            wcjsPlayPauseBtn.addEventListener('click', wcjsTogglePlayPause);
            wcjsRewindBtn.addEventListener('click', () => wcjsSkipTime(-10));
            wcjsForwardBtn.addEventListener('click', () => wcjsSkipTime(10));
            wcjsFullscreenBtn.addEventListener('click', wcjsToggleFullscreen);
            wcjsProgressBar.addEventListener('click', wcjsSeek);
            wcjsMuteBtn.addEventListener('click', wcjsToggleMute);
            wcjsVolume.addEventListener('input', wcjsSetVolume);
            wcjsSubtitleFile.addEventListener('change', wcjsHandleSubtitleUpload);
            wcjsSubsBtn.addEventListener('click', () => {
                if (wcjsSubsPanel.style.display === 'block') wcjsSubsPanel.style.display = 'none';
                else { wcjsSubsPanel.style.display = 'block'; wcjsAudioPanel.style.display = 'none'; fetchAndRenderSubtitles(); }
            });
            wcjsAudioBtn.addEventListener('click', () => {
                if (wcjsAudioPanel.style.display === 'block') wcjsAudioPanel.style.display = 'none';
                else { wcjsAudioPanel.style.display = 'block'; wcjsSubsPanel.style.display = 'none'; renderAudioTracks(); }
            });
            wcjsSubsRefresh.addEventListener('click', fetchAndRenderSubtitles);
            wcjsSubsClose.addEventListener('click', () => wcjsSubsPanel.style.display = 'none');
            wcjsAudioClose.addEventListener('click', () => wcjsAudioPanel.style.display = 'none');
            
          
            customVideo.addEventListener('loadstart', () => {
                loadingOverlay.style.display = 'flex';
            });
            
            customVideo.addEventListener('canplay', () => {
                loadingOverlay.style.display = 'none';
            });
            
            customVideo.addEventListener('timeupdate', updateProgress);
            customVideo.addEventListener('loadedmetadata', updateDuration);
            customVideo.addEventListener('play', () => {
                playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                
                // Start Trakt scrobbling when video plays
                if (currentStreamTitle && traktAutoScrobbleToggle.checked) {
                    const progress = customVideo.currentTime / customVideo.duration * 100;
                    const { title, type, year, season, episode } = parseMediaTitle(currentStreamTitle);
                    scrobbleStart(title, type, year, season, episode, Math.floor(progress));
                }
            });
            customVideo.addEventListener('pause', () => {
                playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                
                // Pause Trakt scrobbling when video pauses
                if (customVideo.duration && traktScrobbleProgressToggle.checked) {
                    const progress = customVideo.currentTime / customVideo.duration * 100;
                    scrobblePause(Math.floor(progress));
                }
            });
            customVideo.addEventListener('ended', () => {
                // Stop Trakt scrobbling when video ends
                if (customVideo.duration) {
                    scrobbleStop(100); // 100% watched
                }
            });
            
           
            detailsModal.addEventListener('click', (e) => {
                if (e.target === detailsModal) {
                    closeModal();
                }
            });
            
 

            customPlayerContainer.addEventListener('click', (e) => {
                if (e.target === customPlayerContainer) {
                    closeCustomPlayer_();
                }
            });

          
            wcjsPlayerContainer.addEventListener('click', (e) => {
                if (e.target === wcjsPlayerContainer) {
                    closeWCJSPlayer();
                }
            });

            // Close settings modal when clicking outside
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    hideSettingsModal();
                }
            });

            // Category filtering (home)
            document.querySelectorAll('.category').forEach(category => {
                category.addEventListener('click', () => {
                    document.querySelectorAll('.category').forEach(c => c.classList.remove('active'));
                    category.classList.add('active');
                    currentCategory = category.dataset.category;
                    moviesGrid.innerHTML = '';
                    currentPage = 1;
                    loadMovies(currentCategory);
                });
            });

            // Toggle buttons on genre details
            toggleMoviesBtn.addEventListener('click', () => {
                if (currentGenreType !== 'movie') {
                    setGenreType('movie');
                }
            });
            toggleTVBtn.addEventListener('click', () => {
                if (currentGenreType !== 'tv') {
                    setGenreType('tv');
                }
            });

            // Keyboard shortcuts for custom player
            document.addEventListener('keydown', (e) => {
                if (customPlayerContainer.classList.contains('active')) {
                    switch(e.code) {
                        case 'Space':
                            e.preventDefault();
                            togglePlayPause();
                            break;
                        case 'ArrowRight':
                            skipTime(10);
                            break;
                        case 'ArrowLeft':
                            skipTime(-10);
                            break;
                        case 'KeyF':
                            toggleFullscreen();
                            break;
                        case 'Escape':
                            closeCustomPlayer_();
                            break;
                    }
                } else if (wcjsPlayerContainer.classList.contains('active')) {
                    switch(e.code) {
                        case 'Space':
                            e.preventDefault();
                            wcjsTogglePlayPause();
                            break;
                        case 'ArrowRight':
                            wcjsSkipTime(10);
                            break;
                        case 'ArrowLeft':
                            wcjsSkipTime(-10);
                            break;
                        case 'KeyF':
                            wcjsToggleFullscreen();
                            break;
                        case 'Escape':
                            closeWCJSPlayer();
                            break;
                    }
                }
            });
            
            // Logo click handlers - navigate to home
            const sidebarLogo = document.getElementById('sidebarLogo');
            if (sidebarLogo) {
                sidebarLogo.addEventListener('click', () => {
                    window.location.href = 'http://localhost:3000';
                });
            }
            
            // Header logo click (for both OLD and NEW UI)
            const headerLogo = document.querySelector('.logo');
            if (headerLogo) {
                headerLogo.addEventListener('click', (e) => {
                    e.preventDefault();
                    window.location.href = 'http://localhost:3000';
                });
            }
            
            // Sidebar navigation for new UI
            const sidebarNavItems = document.querySelectorAll('.nav-item[data-page]');
            sidebarNavItems.forEach(item => {
                item.addEventListener('click', () => {
                    const page = item.dataset.page;
                    sidebarNavItems.forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                    
                    if (page === 'home') {
                        showHomePage();
                    } else if (page === 'genres') {
                        showGenresPage();
                    } else if (page === 'my-list') {
                        showMyListPage();
                    } else if (page === 'done-watching') {
                        showDoneWatchingPage();
                    } else if (page === 'trakt') {
                        showTraktPage();
                    } else if (page === 'livetv') {
                        showLiveTvPage();
                    } else if (page === 'iptv') {
                        showIptvPage();
                    } else if (page === 'games-downloader') {
                        showGamesDownloaderPage();
                    } else if (page === 'minigames') {
                        showMiniGamesPage();
                    } else if (page === 'books') {
                        showBooksPage();
                    } else if (page === 'music') {
                        showMusicPage();
                    } else if (page === 'booktorrio') {
                        showBookTorrioPage();
                    } else if (page === 'anime') {
                        showAnimePage();
                    } else if (page === 'manga') {
                        showMangaPage();
                    } else if (page === 'downloader') {
                        showDownloaderPage();
                    }
                });
            });
            
            // Sidebar clear cache
            const sidebarClearCache = document.getElementById('sidebarClearCache');
            if (sidebarClearCache) {
                sidebarClearCache.addEventListener('click', async () => {
                    const result = await window.electronAPI.clearCache();
                    showNotification(result.message, result.success ? 'success' : 'error');
                });
            }
            
            // Sidebar settings
            const sidebarSettings = document.getElementById('sidebarSettings');
            if (sidebarSettings) {
                sidebarSettings.addEventListener('click', showSettingsModal);
            }

            // Floating navigation (Old UI)
            const floatingNavContainer = document.getElementById('floatingNavContainer');
            const floatingNavBtn = document.getElementById('floatingNavBtn');
            const floatingNavMenu = document.getElementById('floatingNavMenu');
            
            if (floatingNavBtn) {
                floatingNavBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    floatingNavContainer.classList.toggle('active');
                });
            }

            // Handle floating nav menu item clicks
            if (floatingNavMenu) {
                floatingNavMenu.addEventListener('click', (e) => {
                    const item = e.target.closest('.floating-nav-item');
                    if (item) {
                        const action = item.getAttribute('data-action');
                        floatingNavContainer.classList.remove('active');
                        
                        switch (action) {
                            case 'settings':
                                showSettingsModal();
                                break;
                            case 'home':
                                showHomePage();
                                break;
                            case 'genres':
                                showGenresPage();
                                break;
                            case 'my-list':
                                showMyListPage();
                                break;
                            case 'done-watching':
                                showDoneWatchingPage();
                                break;
                            case 'livetv':
                                showLiveTvPage();
                                break;
                            case 'iptv':
                                showIptvPage();
                                break;
                            case 'games-downloader':
                                showGamesDownloaderPage();
                                break;
                            case 'minigames':
                                showMiniGamesPage();
                                break;
                            case 'music':
                                showMusicPage();
                                break;
                            case 'books':
                                showBooksPage();
                                break;
                            case 'booktorrio':
                                showBookTorrioPage();
                                break;
                            case 'anime':
                                showAnimePage();
                                break;
                            case 'manga':
                                showMangaPage();
                                break;
                            case 'downloader':
                                showDownloaderPage();
                                break;
                            case 'trakt':
                                showTraktPage();
                                break;
                        }
                    }
                });
            }

            // Close floating nav when clicking outside
            document.addEventListener('click', (e) => {
                if (floatingNavContainer && !floatingNavContainer.contains(e.target)) {
                    floatingNavContainer.classList.remove('active');
                }
            });

            // Books Functionality
            let booksSearchResults = [];
            
            // Books search input and button
            const booksSearchInput = document.getElementById('books-search-input');
            const booksSearchBtn = document.getElementById('books-search-btn');
            const booksLoading = document.getElementById('books-loading');
            const booksEmpty = document.getElementById('books-empty');
            const booksResults = document.getElementById('books-results');
            const booksResultsGrid = document.getElementById('books-results-grid');
            const booksResultsTitle = document.getElementById('books-results-title');
            const booksResultsCount = document.getElementById('books-results-count');
            
            // Books reader modal
            const booksReaderModal = document.getElementById('books-reader-modal');
            const booksReaderBack = document.getElementById('books-reader-back');
            const booksReaderTitle = document.getElementById('books-reader-title');
            const booksReaderFrame = document.getElementById('books-reader-frame');
            
            // Search functionality
            async function searchBooks(query) {
                if (!query || query.trim().length === 0) {
                    showNotification('Please enter a search term', 'warning');
                    return;
                }
                
                const searchTerm = query.trim();
                console.log('[BOOKS] Searching for:', searchTerm);
                
                // Show loading state
                booksEmpty.style.display = 'none';
                booksResults.style.display = 'none';
                booksLoading.style.display = 'block';
                
                try {
                    const encodedQuery = encodeURIComponent(searchTerm);
                    // Resolve Books server base URL dynamically from main process (port may vary)
                    let booksBase = 'http://localhost:3000/zlib';
                    try {
                        if (window.electronAPI?.booksGetUrl) {
                            const r = await window.electronAPI.booksGetUrl();
                            if (r?.success && r?.url) booksBase = r.url;
                        }
                    } catch(_) {}
                    const response = await fetch(`${booksBase}/search/${encodedQuery}`);
                    const data = await response.json();
                    
                    console.log('[BOOKS] Search results:', data);
                    
                    booksLoading.style.display = 'none';
                    
                    if (data.results && data.results.length > 0) {
                        booksSearchResults = data.results;
                        displayBooksResults(data.results, searchTerm);
                        showNotification(`Found ${data.results.length} books`, 'success');
                    } else {
                        booksResults.style.display = 'none';
                        booksEmpty.style.display = 'block';
                        booksEmpty.innerHTML = `
                            <div class="books-empty-icon">
                                <i class="fas fa-search"></i>
                            </div>
                            <h3>No Books Found</h3>
                            <p>No results found for "${searchTerm}". Try a different search term.</p>
                        `;
                        showNotification('No books found for your search', 'info');
                    }
                } catch (error) {
                    console.error('[BOOKS] Search error:', error);
                    booksLoading.style.display = 'none';
                    booksResults.style.display = 'none';
                    booksEmpty.style.display = 'block';
                    booksEmpty.innerHTML = `
                        <div class="books-empty-icon">
                            <i class="fas fa-exclamation-triangle"></i>
                        </div>
                        <h3>Search Error</h3>
                        <p>Failed to search books. Please check your connection and try again.</p>
                    `;
                    showNotification('Failed to search books', 'error');
                }
            }
            
            function displayBooksResults(books, query) {
                booksResultsTitle.textContent = `Search Results for "${query}"`;
                booksResultsCount.textContent = `${books.length} book${books.length !== 1 ? 's' : ''} found`;
                
                booksResultsGrid.innerHTML = '';
                
                books.forEach(book => {
                    const bookCard = document.createElement('div');
                    bookCard.className = 'books-book-card';
                    
                    bookCard.innerHTML = `
                        <div class="books-book-cover">
                            <img loading="lazy" src="${book.photo}" alt="${book.title}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="books-book-cover-placeholder" style="display: none;">
                                <i class="fas fa-book"></i>
                            </div>
                            <div class="books-book-format">${book.format}</div>
                        </div>
                        <div class="books-book-info">
                            <h3 class="books-book-title">${book.title}</h3>
                            <p class="books-book-author">by ${book.author}</p>
                            ${book.year ? `<span class="books-book-year">${book.year}</span>` : ''}
                            <div class="books-book-actions">
                                <button class="books-read-btn" data-read-link="${book.readLink}" data-title="${book.title}">
                                    <i class="fas fa-book-open"></i>
                                    Read Now
                                </button>
                                <button class="books-download-btn" data-book-url="${book.bookUrl}" title="View on Z-Library">
                                    <i class="fas fa-external-link-alt"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    
                    booksResultsGrid.appendChild(bookCard);
                });
                
                // Add event listeners to Read Now buttons
                const readButtons = booksResultsGrid.querySelectorAll('.books-read-btn');
                readButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const readLink = e.currentTarget.getAttribute('data-read-link');
                        const title = e.currentTarget.getAttribute('data-title');
                        // Open in default browser instead of iframe
                        if (readLink && window.electronAPI?.openExternal) {
                            console.log('[BOOKS] Opening book reader in browser:', title, readLink);
                            window.electronAPI.openExternal(readLink);
                            showNotification(`Opening "${title}" in browser...`, 'success');
                        }
                    });
                });
                
                // Add event listeners to download buttons
                const downloadButtons = booksResultsGrid.querySelectorAll('.books-download-btn');
                downloadButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const bookUrl = e.currentTarget.getAttribute('data-book-url');
                        if (bookUrl) {
                            window.electronAPI.openExternal(bookUrl);
                        }
                    });
                });
                
                booksEmpty.style.display = 'none';
                booksResults.style.display = 'block';
            }

            // Music Functionality
            let musicResultsCache = [];
            const musicSearchInput = document.getElementById('music-search-input');
            const musicSearchBtn = document.getElementById('music-search-btn');
            const musicLoading = document.getElementById('music-loading');
            const musicEmpty = document.getElementById('music-empty');
            const musicResults = document.getElementById('music-results');
            const musicResultsGrid = document.getElementById('music-results-grid');
            const musicResultsCount = document.getElementById('music-results-count');
            const musicResultsTitle = document.getElementById('music-results-title');

            const musicModal = document.getElementById('music-player-modal');
            const musicModalBack = document.getElementById('music-player-back');
            const musicModalMinimize = document.getElementById('music-player-minimize');
            const musicModalTitle = document.getElementById('music-player-title');
            const musicSongTitle = document.getElementById('music-player-song-title');
            const musicArtist = document.getElementById('music-player-artist');
            const musicCover = document.getElementById('music-player-cover');
            const musicAudio = document.getElementById('music-player-audio');
            const musicPlayPauseBtn = document.getElementById('music-play-pause-btn');
            const musicBackwardBtn = document.getElementById('music-backward-btn');
            const musicForwardBtn = document.getElementById('music-forward-btn');
            const musicPrevTrackBtn = document.getElementById('music-prev-track-btn');
            const musicNextTrackBtn = document.getElementById('music-next-track-btn');
            const musicProgressBar = document.getElementById('music-progress-bar');
            const musicProgressFill = document.getElementById('music-progress-fill');
            const musicCurrentTime = document.getElementById('music-current-time');
            const musicTotalTime = document.getElementById('music-total-time');
            const musicVolumeSlider = document.getElementById('music-volume-slider');
            const musicVolumeFill = document.getElementById('music-volume-fill');
            const musicAutoplayToggle = document.getElementById('music-autoplay-toggle');
            
            // Mini player elements
            const miniPlayer = document.getElementById('music-mini-player');
            const miniPlayerMaximize = document.getElementById('music-player-maximize');
            const miniPlayerSongTitle = document.getElementById('mini-player-song-title');
            const miniPlayerArtist = document.getElementById('mini-player-artist');
            const miniPlayPauseBtn = document.getElementById('mini-play-pause-btn');
            const miniBackwardBtn = document.getElementById('mini-backward-btn');
            const miniForwardBtn = document.getElementById('mini-forward-btn');
            const miniPrevTrackBtn = document.getElementById('mini-prev-track-btn');
            const miniNextTrackBtn = document.getElementById('mini-next-track-btn');
            const miniProgressBar = document.getElementById('mini-progress-bar');
            const miniProgressFill = document.getElementById('mini-progress-fill');
            const miniCurrentTime = document.getElementById('mini-current-time');
            const miniTotalTime = document.getElementById('mini-total-time');
            // Playlist chooser modal refs
            const playlistChooser = document.getElementById('music-playlist-chooser');
            const playlistChooserBack = document.getElementById('playlist-chooser-back');
            const playlistChooserList = document.getElementById('playlist-chooser-list');
            const playlistChooserEmpty = document.getElementById('playlist-chooser-empty');
            const playlistChooserNewName = document.getElementById('playlist-chooser-new-name');
            const playlistChooserCreate = document.getElementById('playlist-chooser-create');
            let playlistChooserTrack = null;

            // Music providers (fallback order)
            const HIFI_BASES = [
                'https://frankfurt.monochrome.tf',
                'https://hifi.401658.xyz',
                'https://virginia.monochrome.tf',
                'https://ohio.monochrome.tf',
                'https://singapore.monochrome.tf',
                'https://california.monochrome.tf',
                'https://oregon.monochrome.tf',
                'https://jakarta.monochrome.tf',
                'https://tokyo.monochrome.tf',
                'https://tidal.401658.xyz',
                'https://hund.qqdl.site',
                'https://katze.qqdl.site',
                'https://vogel.qqdl.site',
                'https://maus.qqdl.site',
                'https://wolf.qqdl.site'
            ];

            // Helper to fetch from music providers with fallback
            async function musicFetchJson(path) {
                let lastError = null;
                for (const base of HIFI_BASES) {
                    try {
                        const resp = await fetch(`${base}${path}`);
                        if (resp.ok) {
                            return await resp.json();
                        }
                        lastError = new Error(`HTTP ${resp.status} from ${base}`);
                    } catch (e) {
                        lastError = e;
                    }
                }
                throw lastError || new Error('All music providers failed');
            }

            function tidalCoverUrl(cover) {
                if (!cover) return '';
                try {
                    return `https://resources.tidal.com/images/${cover.replace(/-/g, '/')}/320x320.jpg`;
                } catch (_) {
                    return '';
                }
            }

            function fmtTime(sec) {
                if (!isFinite(sec)) return '0:00';
                const m = Math.floor(sec / 60);
                const s = Math.floor(sec % 60).toString().padStart(2, '0');
                return `${m}:${s}`;
            }

            async function searchMusic(query) {
                if (!query || !query.trim()) {
                    showNotification('Please enter a search term', 'warning');
                    return;
                }

                const q = query.trim();
                musicEmpty.style.display = 'none';
                musicResults.style.display = 'none';
                musicLoading.style.display = 'block';

                try {
                    const data = await musicFetchJson(`/search/?s=${encodeURIComponent(q)}`);
                    musicLoading.style.display = 'none';
                    const items = Array.isArray(data?.items) ? data.items : [];

                    if (!items.length) {
                        musicResults.style.display = 'none';
                        musicEmpty.style.display = 'block';
                        musicEmpty.innerHTML = `
                            <div class="books-empty-icon"><i class="fas fa-search"></i></div>
                            <h3>No Music Found</h3>
                            <p>No results found for "${q}". Try a different search.</p>
                        `;
                        showNotification('No music found for your search', 'info');
                        return;
                    }

                    // Prefer tracks; if mixed, filter to tracks when possible
                    const tracks = items.filter(it => (it.type || it.itemType || '').toString().toLowerCase() === 'track' || it.audioQuality || it.artist);
                    const results = tracks.length ? tracks : items;
                    musicResultsCache = results;
                    displayMusicResults(results, q);
                    showNotification(`Found ${results.length} items`, 'success');
                } catch (e) {
                    console.error('[MUSIC] Search error', e);
                    musicLoading.style.display = 'none';
                    musicResults.style.display = 'none';
                    musicEmpty.style.display = 'block';
                    musicEmpty.innerHTML = `
                        <div class="books-empty-icon"><i class="fas fa-exclamation-triangle"></i></div>
                        <h3>Search Error</h3>
                        <p>Failed to search music. Please try again.</p>
                    `;
                    showNotification('Failed to search music', 'error');
                }
            }

            function displayMusicResults(results, q) {
                // Store results for re-rendering after download
                window.currentMusicResults = results;
                window.currentMusicQuery = q;
                
                musicResultsTitle.textContent = `Search Results for "${q}"`;
                musicResultsCount.textContent = `${results.length} item${results.length !== 1 ? 's' : ''} found`;
                // Ensure we are not in playlist-open mode when showing generic results
                const musicPage = document.getElementById('music-page');
                if (musicPage) musicPage.classList.remove('playlist-open');
                // Hide My Albums and Album View when showing generic results
                const myAlbumsSec = document.getElementById('my-albums');
                if (myAlbumsSec) myAlbumsSec.style.display = 'none';
                const albumViewSec = document.getElementById('music-album-view');
                if (albumViewSec) albumViewSec.style.display = 'none';
                musicResultsGrid.innerHTML = '';

                // Store for building a queue from search results
                const currentSearchTracks = [];
                results.forEach(item => {
                    const trackId = item.id || item.trackId || item.itemId;
                    const title = item.title || item.trackTitle || 'Unknown Title';
                    const artistName = (item.artist && (item.artist.name || item.artist)) || (item.artists && item.artists[0]?.name) || 'Unknown Artist';
                    const cover = item.album?.cover || item.cover || item.albumCover || '';
                    const img = tidalCoverUrl(cover) || 'https://via.placeholder.com/320x320?text=Music';
                    if (trackId) currentSearchTracks.push({ id: String(trackId), title, artist: artistName, cover: img });

                    const card = document.createElement('div');
                    card.className = 'music-card';
                    const isSaved = getMyMusic().some(x => x.id == trackId);
                    const isDownloaded = isTrackDownloaded(trackId);
                    card.innerHTML = `
                        <div class="music-cover">
                            <img loading="lazy" src="${img}" alt="${title}">
                        </div>
                        <div class="music-info">
                            <div class="music-title">${title}</div>
                            <div class="music-artist">${artistName}</div>
                            <div class="music-actions">
                                <button class="music-play-btn" data-id="${trackId}" data-title="${title.replace(/\"/g,'&quot;')}" data-artist="${artistName.replace(/\"/g,'&quot;')}" data-cover="${img}"><i class="fas fa-play"></i> Play</button>
                                <button class="music-heart-btn ${isSaved ? 'added' : ''}" title="${isSaved ? 'In My Music' : 'Add to My Music'}" data-id="${trackId}" data-title="${title.replace(/\"/g,'&quot;')}" data-artist="${artistName.replace(/\"/g,'&quot;')}" data-cover="${img}"><i class="fas ${isSaved ? 'fa-heart' : 'fa-heart'}"></i></button>
                                <button class="music-plus-btn" title="Add to Playlist" data-id="${trackId}" data-title="${title.replace(/\"/g,'&quot;')}" data-artist="${artistName.replace(/\"/g,'&quot;')}" data-cover="${img}"><i class="fas fa-plus"></i></button>
                                ${isDownloaded ? 
                                    `<button class="music-download-btn downloaded" title="Downloaded" data-id="${trackId}" data-title="${title.replace(/\"/g,'&quot;')}" data-artist="${artistName.replace(/\"/g,'&quot;')}" data-cover="${img}"><i class="fas fa-check-circle"></i></button>` : 
                                    `<button class="music-download-btn" title="Download" data-id="${trackId}" data-title="${title.replace(/\"/g,'&quot;')}" data-artist="${artistName.replace(/\"/g,'&quot;')}" data-cover="${img}"><i class="fas fa-download"></i></button>`
                                }
                            </div>
                        </div>
                    `;
                    musicResultsGrid.appendChild(card);
                });

                // Wire up buttons
                musicResultsGrid.querySelectorAll('.music-play-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const trackId = String(e.currentTarget.getAttribute('data-id'));
                        const idx = currentSearchTracks.findIndex(t => String(t.id) === trackId);
                        if (idx >= 0) {
                            setPlayQueue(currentSearchTracks, idx);
                        } else {
                            const card = e.currentTarget.closest('.music-card');
                            const title = card.querySelector('.music-title')?.textContent || 'Unknown Title';
                            const artistName = card.querySelector('.music-artist')?.textContent || 'Unknown Artist';
                            const coverSrc = card.querySelector('img')?.src || '';
                            await playMusicTrack({ trackId, title, artistName, coverSrc });
                        }
                    });
                });

                // Heart (My Music)
                musicResultsGrid.querySelectorAll('.music-heart-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const el = e.currentTarget;
                        const saved = getMyMusic();
                        const track = {
                            id: el.getAttribute('data-id'),
                            title: el.getAttribute('data-title'),
                            artist: el.getAttribute('data-artist'),
                            cover: el.getAttribute('data-cover')
                        };
                        if (!saved.find(x => x.id === track.id)) {
                            saved.push(track);
                            setMyMusic(saved);
                            showNotification(`Saved "${track.title}" to My Music`, 'success');
                            el.classList.add('added');
                            el.title = 'In My Music';
                        } else {
                            showNotification('Already in My Music', 'info');
                        }
                    });
                });

                // Add to playlist
                musicResultsGrid.querySelectorAll('.music-plus-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const el = e.currentTarget;
                        const track = {
                            id: el.getAttribute('data-id'),
                            title: el.getAttribute('data-title'),
                            artist: el.getAttribute('data-artist'),
                            cover: el.getAttribute('data-cover')
                        };
                        showPlaylistChooser(track);
                    });
                });

                // Download music
                musicResultsGrid.querySelectorAll('.music-download-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        // Prevent concurrent downloads: if one is in progress, show notice and do nothing
                        if (currentDownloadId || currentDownloadController) {
                            showNotification('Please wait for the current download to finish', 'info');
                            return;
                        }
                        const el = e.currentTarget;
                        const trackId = el.getAttribute('data-id');
                        const title = el.getAttribute('data-title');
                        const artist = el.getAttribute('data-artist');
                        const cover = el.getAttribute('data-cover');
                        
                        if (isTrackDownloaded(trackId)) {
                            showNotification('Track already downloaded', 'info');
                            return;
                        }
                        
                        await downloadMusicTrack(trackId, title, artist, cover);
                    });
                });

                

                musicEmpty.style.display = 'none';
                musicResults.style.display = 'block';
            }

            // ===== Albums Search & View =====
            const albumSearchBtn = document.getElementById('music-album-search-btn');
            const albumsSection = document.getElementById('music-albums');
            const albumsGrid = document.getElementById('music-albums-grid');
            const albumsCount = document.getElementById('music-albums-count');
            const albumView = document.getElementById('music-album-view');
            const albumCloseBtn = document.getElementById('album-close-btn');
            const albumTracksEl = document.getElementById('album-tracks');
            const albumViewTitle = document.getElementById('album-view-title');
            const albumViewMeta = document.getElementById('album-view-meta');
            const albumViewCover = document.getElementById('album-view-cover');

            function setMusicSectionVisible(section) {
                const sections = ['music-results','my-music','music-playlists','music-albums','music-album-view'];
                const empty = document.getElementById('music-empty');
                sections.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                });
                if (empty) empty.style.display = 'none';
                const musicPage = document.getElementById('music-page');
                if (musicPage) musicPage.classList.remove('playlist-open');
                if (section === 'results') document.getElementById('music-results').style.display = '';
                if (section === 'my-music') document.getElementById('my-music').style.display = '';
                if (section === 'music-playlists') document.getElementById('music-playlists').style.display = '';
                if (section === 'albums') document.getElementById('music-albums').style.display = '';
                if (section === 'album-view') document.getElementById('music-album-view').style.display = '';
                if (section === 'my-albums') document.getElementById('my-albums').style.display = '';
            }

            async function searchAlbums(query) {
                if (!query || !query.trim()) {
                    showNotification('Please enter an album search term', 'warning');
                    return;
                }
                setMusicSectionVisible('albums');
                albumsGrid.innerHTML = '';
                albumsCount.textContent = 'Searching';
                try {
                    const data = await musicFetchJson(`/search/?al=${encodeURIComponent(query.trim())}`);
                    const albums = (data && data.albums && Array.isArray(data.albums.items)) ? data.albums.items : [];
                    renderAlbumResults(albums);
                } catch (e) {
                    console.error('[MUSIC] Album search error', e);
                    albumsCount.textContent = 'Error searching albums';
                }
            }

            function renderAlbumResults(albums) {
                albumsGrid.innerHTML = '';
                albumsCount.textContent = `${albums.length} album${albums.length===1?'':'s'}`;
                if (!albums.length) {
                    albumsGrid.innerHTML = '<div class="album-empty">No albums found.</div>';
                    return;
                }
                albums.forEach(a => {
                    const artistName = (a.artists && a.artists[0]?.name) ? a.artists[0].name : 'Unknown Artist';
                    const coverUrl = a.cover ? tidalCoverUrl(a.cover) : '';
                    const card = document.createElement('div');
                    card.className = 'album-card';
                    const saved = getMyAlbums().some(x => String(x.id) === String(a.id));
                    card.innerHTML = `
                        <img loading="lazy" class="album-cover" src="${coverUrl}" alt="${a.title}">
                        <div class="album-body">
                            <div class="album-title">${a.title}</div>
                            <div class="album-artist">${artistName}</div>
                            <div class="album-meta">
                                <span>${a.type || 'ALBUM'}</span>
                                <span></span>
                                <span>${a.numberOfTracks || 0} tracks</span>
                                ${a.releaseDate ? `<span></span><span>${a.releaseDate}</span>` : ''}
                            </div>
                            <div style="display:flex; gap:0.5rem;">
                                <button class="album-open-btn"><i class="fas fa-folder-open"></i> Open</button>
                                <button class="album-heart-btn ${saved ? 'added' : ''}" title="${saved ? 'In My Albums' : 'Save Album'}"><i class="fas fa-heart"></i></button>
                            </div>
                        </div>`;
                    card.querySelector('.album-open-btn').addEventListener('click', () => openAlbum(a));
                    card.querySelector('.album-heart-btn').addEventListener('click', () => saveAlbum(a, card.querySelector('.album-heart-btn')));
                    albumsGrid.appendChild(card);
                });
            }

            // Store current album tracks for Play All functionality
            let currentAlbumTracks = [];

            async function openAlbum(albumFromSearch) {
                try {
                    setMusicSectionVisible('album-view');
                    albumTracksEl.innerHTML = '<div class="album-empty">Loading tracks</div>';
                    currentAlbumTracks = []; // Clear previous album data

                    const json = await musicFetchJson(`/album/?id=${encodeURIComponent(albumFromSearch.id)}`);

                    // API shape per example: [ albumMeta, { limit, offset, totalNumberOfItems, items: [{ item: {track}, type: 'track' }, ...] } ]
                    let albumMeta = null;
                    let tracks = [];
                    if (Array.isArray(json)) {
                        albumMeta = json[0] || null;
                        const items = json[1]?.items || [];
                        tracks = items.map(x => x?.item).filter(Boolean);
                    } else if (Array.isArray(json?.tracks)) {
                        // fallback shape support
                        tracks = json.tracks;
                        albumMeta = albumFromSearch || null;
                    } else {
                        albumMeta = albumFromSearch || null;
                    }

                    // Header info using albumMeta when available
                    const title = albumMeta?.title || albumFromSearch?.title || 'Album';
                    const artistName = albumMeta?.artist?.name || (albumMeta?.artists && albumMeta.artists[0]?.name) || (albumFromSearch?.artists && albumFromSearch.artists[0]?.name) || 'Unknown Artist';
                    const numTracks = albumMeta?.numberOfTracks ?? albumFromSearch?.numberOfTracks ?? (Array.isArray(tracks) ? tracks.length : 0);
                    const releaseDate = albumMeta?.releaseDate || albumFromSearch?.releaseDate || '';
                    const coverId = albumMeta?.cover || albumFromSearch?.cover || '';

                    albumViewTitle.textContent = title;
                    albumViewMeta.textContent = `${artistName}  ${numTracks} tracks${releaseDate ? '  ' + releaseDate : ''}`;
                    albumViewCover.src = coverId ? tidalCoverUrl(coverId) : '';

                    // Store tracks for Play All before rendering
                    const coverSrc = coverId ? tidalCoverUrl(coverId) : '';
                    currentAlbumTracks = tracks.map((t, idx) => {
                        const trackId = t.id || t.trackNumber || idx + 1;
                        const trackTitle = t.title || t.name || `Track ${idx+1}`;
                        const trackArtist = (t.artists && t.artists[0]?.name) ? t.artists[0].name : artistName;
                        return {
                            id: trackId,
                            title: trackTitle,
                            artist: trackArtist,
                            cover: coverSrc
                        };
                    }).filter(t => t.id); // Only tracks with valid IDs

                    renderAlbumTracks(tracks, { artists: [{ name: artistName }], cover: coverId });
                } catch (e) {
                    console.error('[MUSIC] openAlbum error', e);
                    albumTracksEl.innerHTML = '<div class="album-empty">Failed to load album.</div>';
                    currentAlbumTracks = []; // Clear on error
                }
            }

            function renderAlbumTracks(tracks, album) {
                if (!tracks.length) {
                    albumTracksEl.innerHTML = '<div class="album-empty">No tracks found in this album.</div>';
                    return;
                }
                albumTracksEl.innerHTML = '';
                const coverSrc = album.cover ? tidalCoverUrl(album.cover) : '';
                tracks.forEach((t, idx) => {
                    const trackId = t.id || t.trackNumber || idx + 1; // prefer real id
                    const trackTitle = t.title || t.name || `Track ${idx+1}`;
                    const artistName = (t.artists && t.artists[0]?.name) ? t.artists[0].name : ((album.artists && album.artists[0]?.name) ? album.artists[0].name : 'Unknown Artist');
                    const durationSec = (typeof t.duration === 'number') ? t.duration : (t.durationMs ? Math.round(t.durationMs/1000) : 0);

                    const row = document.createElement('div');
                    row.className = 'track-row';
                    row.innerHTML = `
                        <div class="track-index">${idx+1}</div>
                        <div class="track-title">${trackTitle} <span style="color:#94a3b8; font-weight:600;"> ${artistName}</span></div>
                        <div class="track-duration">${fmtTime(durationSec)}</div>
                        <div class="track-actions">
                            <button class="track-play-btn"><i class="fas fa-play"></i> Play</button>
                            <button class="track-plus-btn"><i class="fas fa-plus"></i> Playlist</button>
                            <button class="track-heart-btn"><i class="fas fa-heart"></i> Save</button>
                        </div>`;

                    row.querySelector('.track-play-btn').addEventListener('click', () => {
                        if (!t.id) { showNotification('Unable to play: missing track id', 'error'); return; }
                        // Use the prebuilt album queue so next/prev works
                        const idx = currentAlbumTracks.findIndex(x => String(x.id) === String(t.id));
                        if (idx >= 0) {
                            setPlayQueue(currentAlbumTracks, idx);
                        } else {
                            playMusicTrack({ trackId: t.id, title: trackTitle, artistName, coverSrc });
                        }
                    });
                    row.querySelector('.track-plus-btn').addEventListener('click', () => {
                        if (!t.id) { showNotification('Unable to add: missing track id', 'error'); return; }
                        showPlaylistChooser({ id: String(t.id), title: trackTitle, artist: artistName, cover: coverSrc });
                    });
                    row.querySelector('.track-heart-btn').addEventListener('click', () => {
                        if (!t.id) { showNotification('Unable to save: missing track id', 'error'); return; }
                        const list = getMyMusic();
                        if (!list.find(x => String(x.id) === String(t.id))) {
                            list.push({ id: String(t.id), title: trackTitle, artist: artistName, cover: coverSrc });
                            setMyMusic(list);
                            showNotification(`Saved "${trackTitle}" to My Music`, 'success');
                        } else {
                            showNotification('Already in My Music', 'info');
                        }
                    });

                    albumTracksEl.appendChild(row);
                });
            }

            if (albumSearchBtn) {
                albumSearchBtn.addEventListener('click', () => searchAlbums(musicSearchInput?.value || ''));
            }
            if (albumCloseBtn) {
                albumCloseBtn.addEventListener('click', () => {
                    // If albums list has content, go back there; else back to generic state
                    if (albumsGrid && albumsGrid.children.length) setMusicSectionVisible('albums');
                    else if (musicResultsGrid && musicResultsGrid.children.length) setMusicSectionVisible('results');
                    else setMusicSectionVisible('results');
                });
            }

            // Play All button handlers
            const albumPlayAllBtn = document.getElementById('album-play-all-btn');
            if (albumPlayAllBtn) {
                albumPlayAllBtn.addEventListener('click', () => {
                    // Use stored album tracks instead of querying DOM
                    if (currentAlbumTracks.length === 0) {
                        showNotification('No tracks to play', 'info');
                        return;
                    }
                    playAllTracks(currentAlbumTracks);
                });
            }

            const myMusicPlayAllBtn = document.getElementById('my-music-play-all-btn');
            if (myMusicPlayAllBtn) {
                myMusicPlayAllBtn.addEventListener('click', () => {
                    const tracks = getMyMusic();
                    if (tracks.length === 0) {
                        showNotification('No tracks in My Music', 'info');
                        return;
                    }
                    playAllTracks(tracks);
                });
            }

            // ===== My Albums storage and rendering =====
            const MY_ALBUMS_KEY = 'pt_my_albums_v1';
            function getMyAlbums() {
                try { return JSON.parse(localStorage.getItem(MY_ALBUMS_KEY) || '[]'); } catch(_) { return []; }
            }
            function setMyAlbums(arr) {
                try { localStorage.setItem(MY_ALBUMS_KEY, JSON.stringify(arr)); } catch(_) {}
            }
            function saveAlbum(album, btnEl) {
                const list = getMyAlbums();
                const exists = list.find(x => String(x.id) === String(album.id));
                if (exists) {
                    showNotification('Album already saved', 'info');
                    if (btnEl) btnEl.classList.add('added');
                    return;
                }
                const toSave = {
                    id: album.id,
                    title: album.title,
                    cover: album.cover || null,
                    artist: (album.artist?.name) || (album.artists && album.artists[0]?.name) || 'Unknown Artist',
                    numberOfTracks: album.numberOfTracks || 0,
                    releaseDate: album.releaseDate || ''
                };
                list.push(toSave);
                setMyAlbums(list);
                showNotification(`Saved "${toSave.title}" to My Albums`, 'success');
                if (btnEl) btnEl.classList.add('added');
            }

            function renderMyAlbums() {
                const grid = document.getElementById('my-albums-grid');
                const count = document.getElementById('my-albums-count');
                const empty = document.getElementById('my-albums-empty');
                const albums = getMyAlbums();
                grid.innerHTML = '';
                if (!albums.length) {
                    count.textContent = '0 albums';
                    empty.style.display = '';
                    return;
                }
                empty.style.display = 'none';
                count.textContent = `${albums.length} album${albums.length===1?'':'s'}`;
                albums.forEach(a => {
                    const card = document.createElement('div');
                    card.className = 'album-card';
                    const coverUrl = a.cover ? tidalCoverUrl(a.cover) : '';
                    card.innerHTML = `
                        <img loading="lazy" class="album-cover" src="${coverUrl}" alt="${a.title}">
                        <div class="album-body">
                            <div class="album-title">${a.title}</div>
                            <div class="album-artist">${a.artist || ''}</div>
                            <div class="album-meta"><span>${a.numberOfTracks||0} tracks</span>${a.releaseDate?`<span></span><span>${a.releaseDate}</span>`:''}</div>
                            <div style="display:flex; gap:0.5rem;">
                                <button class="album-open-btn" data-id="${a.id}"><i class="fas fa-folder-open"></i> Open</button>
                                <button class="album-heart-btn added" title="Remove from My Albums" data-remove="true" data-id="${a.id}"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>`;
                    grid.appendChild(card);
                });
                // Wire open and remove
                grid.querySelectorAll('.album-open-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const id = btn.getAttribute('data-id');
                        const album = getMyAlbums().find(x => String(x.id) === String(id));
                        if (album) openAlbum(album);
                    });
                });
                grid.querySelectorAll('.album-heart-btn[data-remove="true"]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const id = btn.getAttribute('data-id');
                        const list = getMyAlbums().filter(x => String(x.id) !== String(id));
                        setMyAlbums(list);
                        renderMyAlbums();
                        showNotification('Removed album', 'info');
                    });
                });
            }

            // Toggle My Albums
            const myAlbumsBtn = document.getElementById('music-my-albums-btn');
            if (myAlbumsBtn) {
                myAlbumsBtn.addEventListener('click', () => {
                    const sec = document.getElementById('my-albums');
                    const resSec = document.getElementById('music-results');
                    const empty = document.getElementById('music-empty');
                    const mySec = document.getElementById('my-music');
                    const plsSec = document.getElementById('music-playlists');
                    const downloadedSec = document.getElementById('music-downloaded');
                    const albListSec = document.getElementById('music-albums');
                    const albumViewSec = document.getElementById('music-album-view');
                    const showing = sec.style.display !== 'none';
                    if (showing) {
                        sec.style.display = 'none';
                        if (albListSec && albListSec.children.length) { albListSec.style.display = 'block'; }
                        else if (musicResultsGrid && musicResultsGrid.children.length) { resSec.style.display = 'block'; empty.style.display = 'none'; }
                        else { resSec.style.display = 'none'; empty.style.display = ''; }
                        if (albumViewSec) albumViewSec.style.display = 'none';
                    } else {
                        renderMyAlbums();
                        sec.style.display = 'block';
                        resSec.style.display = 'none';
                        empty.style.display = 'none';
                        mySec.style.display = 'none';
                        plsSec.style.display = 'none';
                        if (downloadedSec) downloadedSec.style.display = 'none';
                        if (albListSec) albListSec.style.display = 'none';
                        if (albumViewSec) albumViewSec.style.display = 'none';
                    }
                });
            }

            // My Music storage helpers
            const MY_MUSIC_KEY = 'pt_my_music_v1';
            function getMyMusic() {
                try { return JSON.parse(localStorage.getItem(MY_MUSIC_KEY) || '[]'); } catch(_) { return []; }
            }
            function setMyMusic(arr) {
                try { localStorage.setItem(MY_MUSIC_KEY, JSON.stringify(arr)); } catch(_) {}
            }

            // Playlists storage helpers
            const PLAYLISTS_KEY = 'pt_playlists_v1';
            function getPlaylists() {
                try { return JSON.parse(localStorage.getItem(PLAYLISTS_KEY) || '[]'); } catch(_) { return []; }
            }
            function setPlaylists(arr) {
                try { localStorage.setItem(PLAYLISTS_KEY, JSON.stringify(arr)); } catch(_) {}
            }
            function addTrackToPlaylist(playlistId, track) {
                const pls = getPlaylists();
                const pl = pls.find(p => p.id === playlistId);
                if (!pl) return false;
                if (!pl.tracks) pl.tracks = [];
                if (!pl.tracks.find(t => t.id === track.id)) {
                    pl.tracks.push(track);
                    setPlaylists(pls);
                    return true;
                }
                return false;
            }

            // Downloaded Music storage helpers
            const DOWNLOADED_MUSIC_KEY = 'pt_downloaded_music_v1';
            function getDownloadedMusic() {
                try { return JSON.parse(localStorage.getItem(DOWNLOADED_MUSIC_KEY) || '[]'); } catch(_) { return []; }
            }
            function setDownloadedMusic(arr) {
                try { localStorage.setItem(DOWNLOADED_MUSIC_KEY, JSON.stringify(arr)); } catch(_) {}
            }
            function isTrackDownloaded(trackId) {
                const downloaded = getDownloadedMusic();
                return downloaded.some(d => String(d.id) === String(trackId));
            }
            function addToDownloaded(track) {
                const downloaded = getDownloadedMusic();
                if (!downloaded.find(d => String(d.id) === String(track.id))) {
                    downloaded.push(track);
                    setDownloadedMusic(downloaded);
                    return true;
                }
                return false;
            }
            function removeFromDownloaded(trackId) {
                // Ensure type-safe comparison so numeric vs string IDs don't break removal
                const downloaded = getDownloadedMusic().filter(d => String(d.id) !== String(trackId));
                setDownloadedMusic(downloaded);
            }

            // Reconcile local downloaded list with actual files on disk
            async function reconcileDownloadedMusicWithDisk() {
                try {
                    const list = getDownloadedMusic();
                    if (!Array.isArray(list) || list.length === 0) return [];
                    const filePaths = Array.from(new Set(list.map(d => d && d.filePath).filter(Boolean)));
                    if (filePaths.length === 0) return list;
                    const res = await fetch('/api/music/exists-batch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ filePaths })
                    });
                    if (!res.ok) return list;
                    const data = await res.json();
                    const existsMap = (data && data.results) || {};
                    const filtered = list.filter(item => item && item.filePath && existsMap[item.filePath]);
                    if (filtered.length !== list.length) {
                        setDownloadedMusic(filtered);
                    }
                    return filtered;
                } catch (e) {
                    console.warn('[Music] Reconcile with disk failed:', e);
                    return getDownloadedMusic();
                }
            }

            // Track current download for cancellation
            let currentDownloadController = null;
            let currentDownloadFilePath = null;
            let currentDownloadId = null;
            let currentDownloadPoll = null;
            let currentDownloadCancelled = false;
            let isDownloadMinimized = false;

            // Helper: fetch image and return as data URL for offline cover storage
            async function fetchImageAsDataURL(url) {
                try {
                    if (!url || url.startsWith('data:')) return url || '';
                    const res = await fetch(url);
                    if (!res.ok) throw new Error('Image fetch failed');
                    const blob = await res.blob();
                    return await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                } catch (e) {
                    console.warn('Cover to dataURL failed, keeping URL:', e?.message || e);
                    return url || '';
                }
            }

            function updateBothProgressBars(width, status) {
                // Update modal progress
                const progressBar = document.getElementById('music-download-progress-fill');
                const statusText = document.getElementById('music-download-status');
                if (progressBar) progressBar.style.width = width;
                if (statusText) statusText.textContent = status;
                
                // Update minimized progress
                const minProgressBar = document.getElementById('music-download-minimized-progress');
                const minStatusText = document.getElementById('music-download-minimized-status');
                if (minProgressBar) minProgressBar.style.width = width;
                if (minStatusText) minStatusText.textContent = status;
            }

            // Download music track function
            async function downloadMusicTrack(trackId, title, artistName, coverSrc) {
                // Guard: only one download at a time
                if (currentDownloadId || currentDownloadController) {
                    showNotification('Please wait for the current download to finish', 'info');
                    return;
                }
                // Create new AbortController for this download
                currentDownloadController = new AbortController();
                currentDownloadFilePath = null;
                isDownloadMinimized = false;
                // Assign a downloadId immediately so cancel works even before network calls
                currentDownloadId = Date.now().toString();
                
                try {
                    // Show download modal
                    const modal = document.getElementById('music-download-modal');
                    const minimized = document.getElementById('music-download-minimized');
                    const songNameEl = document.getElementById('music-download-song-name');
                    const artistNameEl = document.getElementById('music-download-artist-name');
                    const minSongEl = document.getElementById('music-download-minimized-song');
                    const minArtistEl = document.getElementById('music-download-minimized-artist');
                    
                    // Immediately show minimized notification instead of full modal
                    modal.style.display = 'none';
                    minimized.style.display = 'block';
                    isDownloadMinimized = true;
                    if (songNameEl) songNameEl.textContent = title;
                    if (artistNameEl) artistNameEl.textContent = artistName;
                    if (minSongEl) minSongEl.textContent = title;
                    if (minArtistEl) minArtistEl.textContent = artistName;

                    updateBothProgressBars('0%', 'Fetching track information...');

                    // Use the same API as playMusicTrack
                    const data = await musicFetchJson(`/track/?id=${encodeURIComponent(trackId)}&quality=LOSSLESS`);
                    let trackUrl = null;
                    if (Array.isArray(data) && data.length >= 3) {
                        trackUrl = data[2]?.OriginalTrackUrl || data[2]?.originalTrackUrl;
                    }
                    if (!trackUrl && Array.isArray(data)) {
                        for (const item of data) {
                            const candidate = item?.OriginalTrackUrl || item?.originalTrackUrl;
                            if (candidate && !candidate.startsWith('http://www.tidal.com')) {
                                trackUrl = candidate;
                                break;
                            }
                        }
                    }

                    if (!trackUrl) throw new Error('No valid track URL found');

                    updateBothProgressBars('10%', 'Starting download...');

                    // Use the pre-assigned unique download ID
                    const downloadId = currentDownloadId;
                    currentDownloadCancelled = false;
                    // Real-time updates (no step snapping)

                    // Poll for progress updates BEFORE starting download
                    const pollProgress = setInterval(async () => {
                        try {
                            const progressRes = await fetch(`/api/music/download/progress/${downloadId}`);
                            if (progressRes.ok) {
                                const progressData = await progressRes.json();
                                if (typeof progressData.progress === 'number') {
                                    const pct = Math.max(0, Math.min(100, progressData.progress));
                                    updateBothProgressBars(`${pct}%`, `Converting... ${pct}%  (If it looks stuck, please wait a bit longer)`);
                                }
                                if (progressData.filePath) {
                                    currentDownloadFilePath = progressData.filePath;
                                }
                                if (progressData.complete) {
                                    clearInterval(pollProgress);
                                }
                            }
                        } catch (e) {
                            console.error('Progress poll error:', e);
                        }
                    }, 300);
                    currentDownloadPoll = pollProgress;

                    // Start download (non-blocking with progress polling)
                    fetch('/api/music/download', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            trackUrl,
                            songName: title,
                            artistName,
                            downloadId,
                            cover: coverSrc
                        }),
                        signal: currentDownloadController.signal
                    }).then(async (downloadRes) => {
                        clearInterval(pollProgress);
                        currentDownloadPoll = null;
                        
                        if (!downloadRes.ok) {
                            const err = await downloadRes.json();
                            throw new Error(err.error || 'Download failed');
                        }

                        const result = await downloadRes.json();
                        currentDownloadFilePath = result.filePath;
                        
                        // Add to downloaded list with cover image (stored as data URL for offline when possible)
                        let coverToStore = coverSrc;
                        try { coverToStore = await fetchImageAsDataURL(coverSrc); } catch(_) {}
                        addToDownloaded({
                            id: String(trackId),
                            title,
                            artist: artistName,
                            cover: coverToStore,
                            filePath: result.filePath
                        });

                        // Update UI
                        updateBothProgressBars('100%', ' Download complete!');
                        
                        setTimeout(() => {
                            const modal = document.getElementById('music-download-modal');
                            const minimized = document.getElementById('music-download-minimized');
                            modal.style.display = 'none';
                            minimized.style.display = 'none';
                            currentDownloadController = null;
                            currentDownloadFilePath = null;
                            currentDownloadId = null;
                            // Return focus to the music search bar so user can continue searching
                            try { musicSearchInput && musicSearchInput.focus && musicSearchInput.focus(); } catch(_) {}
                        }, 1500);

                        showNotification(`Downloaded "${title}"`, 'success');
                        
                        // Re-render music results to update button
                        const currentResults = window.currentMusicResults || [];
                        const currentQuery = window.currentMusicQuery || '';
                        if (currentResults.length > 0) {
                            displayMusicResults(currentResults, currentQuery);
                        }
                    }).catch((error) => {
                        clearInterval(pollProgress);
                        currentDownloadPoll = null;
                        console.error('Download error:', error);
                        const modal = document.getElementById('music-download-modal');
                        const minimized = document.getElementById('music-download-minimized');
                        modal.style.display = 'none';
                        minimized.style.display = 'none';
                        
                        // Delete partial file if download was cancelled or failed
                        if (!currentDownloadCancelled && currentDownloadFilePath) {
                            fetch('/api/music/delete', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ filePath: currentDownloadFilePath })
                            }).catch(e => console.error('Failed to delete partial file:', e));
                        }
                        
                        currentDownloadController = null;
                        currentDownloadFilePath = null;
                        currentDownloadId = null;
                        // Ensure user can interact and refocus the search bar after failure
                        try { musicSearchInput && musicSearchInput.focus && musicSearchInput.focus(); } catch(_) {}
                        
                        if (error.name === 'AbortError') {
                            showNotification('Download cancelled', 'info');
                        } else {
                            showNotification(`Download failed: ${error.message}`, 'error');
                        }
                    });

                } catch (error) {
                    console.error('Initial download error:', error);
                    const modal = document.getElementById('music-download-modal');
                    const minimized = document.getElementById('music-download-minimized');
                    modal.style.display = 'none';
                    minimized.style.display = 'none';
                    currentDownloadController = null;
                    showNotification(`Failed to start download: ${error.message}`, 'error');
                    // Ensure focus returns to the search bar on error
                    try { musicSearchInput && musicSearchInput.focus && musicSearchInput.focus(); } catch(_) {}
                }
            }

            // Minimize download button handler
            const minimizeDownloadBtn = document.getElementById('music-download-minimize-btn');
            if (minimizeDownloadBtn) {
                minimizeDownloadBtn.addEventListener('click', () => {
                    const modal = document.getElementById('music-download-modal');
                    const minimized = document.getElementById('music-download-minimized');
                    modal.style.display = 'none';
                    minimized.style.display = 'block';
                    isDownloadMinimized = true;
                });
            }

            // Restore download button handler
            const restoreDownloadBtn = document.getElementById('music-download-restore-btn');
            if (restoreDownloadBtn) {
                restoreDownloadBtn.addEventListener('click', () => {
                    const modal = document.getElementById('music-download-modal');
                    const minimized = document.getElementById('music-download-minimized');
                    modal.style.display = 'flex';
                    minimized.style.display = 'none';
                    isDownloadMinimized = false;
                });
            }

            // Cancel download button handler (modal)
            const cancelDownloadBtn = document.getElementById('music-download-cancel-btn');
            if (cancelDownloadBtn) {
                cancelDownloadBtn.addEventListener('click', async () => {
                    try {
                        currentDownloadCancelled = true;
                        if (currentDownloadPoll) { clearInterval(currentDownloadPoll); currentDownloadPoll = null; }
                        if (currentDownloadController) {
                            try { currentDownloadController.abort(); } catch(_) {}
                        }
                        if (currentDownloadId) {
                            await fetch('/api/music/download/cancel', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ downloadId: currentDownloadId })
                            }).catch(()=>{});
                        }
                    } finally {
                        const modal = document.getElementById('music-download-modal');
                        const minimized = document.getElementById('music-download-minimized');
                        if (modal) modal.style.display = 'none';
                        if (minimized) minimized.style.display = 'none';
                        currentDownloadController = null;
                        currentDownloadFilePath = null;
                        currentDownloadId = null;
                        updateBothProgressBars('0%', '');
                        showNotification('Download cancelled', 'info');
                        // Refocus search for quick next query
                        try { musicSearchInput && musicSearchInput.focus && musicSearchInput.focus(); } catch(_) {}
                    }
                });
            }

            // Cancel download button handler (minimized)
            const cancelDownloadMinBtn = document.getElementById('music-download-cancel-minimized-btn');
            if (cancelDownloadMinBtn) {
                cancelDownloadMinBtn.addEventListener('click', async () => {
                    try {
                        currentDownloadCancelled = true;
                        if (currentDownloadPoll) { clearInterval(currentDownloadPoll); currentDownloadPoll = null; }
                        if (currentDownloadController) {
                            try { currentDownloadController.abort(); } catch(_) {}
                        }
                        if (currentDownloadId) {
                            await fetch('/api/music/download/cancel', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ downloadId: currentDownloadId })
                            }).catch(()=>{});
                        }
                    } finally {
                        const modal = document.getElementById('music-download-modal');
                        const minimized = document.getElementById('music-download-minimized');
                        if (modal) modal.style.display = 'none';
                        if (minimized) minimized.style.display = 'none';
                        currentDownloadController = null;
                        currentDownloadFilePath = null;
                        currentDownloadId = null;
                        updateBothProgressBars('0%', '');
                        showNotification('Download cancelled', 'info');
                        // Refocus search for quick next query
                        try { musicSearchInput && musicSearchInput.focus && musicSearchInput.focus(); } catch(_) {}
                    }
                });
            }

            function renderPlaylists() {
                const wrap = document.getElementById('music-playlists');
                if (!wrap) return;
                const list = document.getElementById('playlists-list');
                const empty = document.getElementById('playlists-empty');
                const pls = getPlaylists();
                list.innerHTML = '';
                if (!pls.length) {
                    empty.style.display = '';
                    return;
                }
                empty.style.display = 'none';
                pls.forEach(pl => {
                    const card = document.createElement('div');
                    card.className = 'music-card';
                    card.innerHTML = `
                        <div class="music-info">
                            <div class="music-title">${pl.name}</div>
                            <div class="music-artist">${(pl.tracks?.length||0)} track${(pl.tracks?.length||0)!==1?'s':''}</div>
                            <div class="music-actions">
                                <button class="playlist-open-btn" data-id="${pl.id}"><i class="fas fa-folder-open"></i> Open</button>
                                <button class="playlist-delete-btn" data-id="${pl.id}"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>`;
                    list.appendChild(card);
                });
                // open
                list.querySelectorAll('.playlist-open-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.currentTarget.getAttribute('data-id');
                        openPlaylist(id);
                    });
                });
                // delete
                list.querySelectorAll('.playlist-delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.currentTarget.getAttribute('data-id');
                        const pls = getPlaylists().filter(p => p.id !== id);
                        setPlaylists(pls);
                        renderPlaylists();
                        showNotification('Playlist deleted', 'info');
                    });
                });
            }

            function openPlaylist(id) {
                const pls = getPlaylists();
                const pl = pls.find(p => p.id === id);
                if (!pl) return;
                // Reuse results grid to show playlist content
                const resSec = document.getElementById('music-results');
                const empty = document.getElementById('music-empty');
                const mySec = document.getElementById('my-music');
                mySec.style.display = 'none';
                resSec.style.display = 'block'; empty.style.display = 'none';
                musicResultsTitle.textContent = `Playlist: ${pl.name}`;
                // mark playlist-open on page for CSS tweaks
                const musicPage = document.getElementById('music-page');
                if (musicPage) musicPage.classList.add('playlist-open');
                // Add Close Playlist button in the header
                const header = resSec.querySelector('.books-results-header');
                if (header && !header.querySelector('#playlist-close-btn')) {
                    // Add Play All button first
                    const playAllBtn = document.createElement('button');
                    playAllBtn.id = 'playlist-play-all-btn';
                    playAllBtn.className = 'action-btn';
                    playAllBtn.style.background = 'linear-gradient(135deg, #ec4899, #a855f7)';
                    playAllBtn.innerHTML = '<i class="fas fa-play"></i><span>Play All</span>';
                    header.appendChild(playAllBtn);
                    playAllBtn.addEventListener('click', () => {
                        const tracks = pl.tracks || [];
                        if (tracks.length === 0) {
                            showNotification('No tracks in this playlist', 'info');
                            return;
                        }
                        playAllTracks(tracks);
                    });
                    
                    const closeBtn = document.createElement('button');
                    closeBtn.id = 'playlist-close-btn';
                    closeBtn.className = 'playlist-close-btn';
                    closeBtn.style.marginLeft = 'auto';
                    closeBtn.innerHTML = '<i class="fas fa-times"></i><span>Close Playlist</span>';
                    header.appendChild(closeBtn);
                    closeBtn.addEventListener('click', () => {
                        // Clear playlist-open mode and header buttons
                        if (musicPage) musicPage.classList.remove('playlist-open');
                        const pBtn = document.getElementById('playlist-play-all-btn');
                        const cBtn = document.getElementById('playlist-close-btn');
                        if (pBtn) pBtn.remove();
                        if (cBtn) cBtn.remove();
                        // Go back to Playlists view explicitly
                        resSec.style.display = 'none';
                        empty.style.display = 'none';
                        const plsSec = document.getElementById('music-playlists');
                        if (plsSec) {
                            plsSec.style.display = 'block';
                            try { renderPlaylists(); } catch(_) {}
                        }
                    });
                }
                const tracks = pl.tracks || [];
                musicResultsCount.textContent = `${tracks.length} track${tracks.length!==1?'s':''}`;
                musicResultsGrid.innerHTML = '';
                tracks.forEach(t => {
                    const card = document.createElement('div');
                    card.className = 'music-card';
                    card.innerHTML = `
                        <div class="music-cover"><img loading="lazy" src="${t.cover}" alt="${t.title}"></div>
                        <div class="music-info">
                            <div class="music-title">${t.title}</div>
                            <div class="music-artist">${t.artist}</div>
                            <div class="music-actions">
                                <button class="music-play-btn" data-id="${t.id}" data-title="${t.title}" data-artist="${t.artist}" data-cover="${t.cover}"><i class="fas fa-play"></i> Play</button>
                                <button class="playlist-delete-btn playlist-remove-btn" data-id="${t.id}" data-pl="${id}" title="Remove from Playlist"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>`;
                    musicResultsGrid.appendChild(card);
                });
                musicResultsGrid.querySelectorAll('.music-play-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const el = e.currentTarget;
                        // When inside a playlist, set queue to that playlist's tracks
                        const tracks = (pl.tracks || []).map(t => ({ id: String(t.id), title: t.title, artist: t.artist, cover: t.cover }));
                        const idx = tracks.findIndex(t => String(t.id) === String(el.getAttribute('data-id')));
                        if (idx >= 0 && tracks.length) {
                            setPlayQueue(tracks, idx);
                        } else {
                            playMusicTrack({
                                trackId: el.getAttribute('data-id'),
                                title: el.getAttribute('data-title'),
                                artistName: el.getAttribute('data-artist'),
                                coverSrc: el.getAttribute('data-cover')
                            });
                        }
                    });
                });
                musicResultsGrid.querySelectorAll('.playlist-remove-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const idTrack = e.currentTarget.getAttribute('data-id');
                        const pid = e.currentTarget.getAttribute('data-pl');
                        const pls = getPlaylists();
                        const pl2 = pls.find(p => p.id === pid);
                        if (pl2) {
                            pl2.tracks = (pl2.tracks||[]).filter(t => t.id !== idTrack);
                            setPlaylists(pls);
                            openPlaylist(pid);
                            showNotification('Removed from playlist', 'info');
                        }
                    });
                });
            }

            function showPlaylistChooser(track) {
                // Open the modal chooser and list playlists to add into
                playlistChooserTrack = track;
                const pls = getPlaylists();
                if (!playlistChooser || !playlistChooserList || !playlistChooserEmpty) return;
                playlistChooserList.innerHTML = '';
                if (!pls.length) {
                    playlistChooserEmpty.style.display = '';
                } else {
                    playlistChooserEmpty.style.display = 'none';
                    pls.forEach(pl => {
                        const row = document.createElement('div');
                        row.className = 'music-card';
                        row.innerHTML = `
                            <div class="music-info">
                                <div class="music-title">${pl.name}</div>
                                <div class="music-artist">${(pl.tracks?.length||0)} track${(pl.tracks?.length||0)!==1?'s':''}</div>
                                <div class="music-actions">
                                    <button class="playlist-open-btn playlist-choose-btn" data-id="${pl.id}"><i class="fas fa-check"></i><span>Add Here</span></button>
                                </div>
                            </div>`;
                        playlistChooserList.appendChild(row);
                    });
                    playlistChooserList.querySelectorAll('.playlist-choose-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const pid = btn.getAttribute('data-id');
                            const ok = addTrackToPlaylist(pid, playlistChooserTrack);
                            const name = (getPlaylists().find(p => p.id===pid)?.name) || 'playlist';
                            showNotification(ok ? `Added to ${name}` : 'Already in playlist', ok ? 'success' : 'info');
                            closePlaylistChooser();
                        });
                    });
                }
                playlistChooser.style.display = 'flex';
            }

            function closePlaylistChooser() {
                if (playlistChooser) playlistChooser.style.display = 'none';
                playlistChooserTrack = null;
                if (playlistChooserNewName) playlistChooserNewName.value = '';
            }

            function renderDownloadedMusic() {
                const wrap = document.getElementById('music-downloaded');
                if (!wrap) return;
                const grid = document.getElementById('music-downloaded-grid');
                const empty = document.getElementById('music-downloaded-empty');
                const countEl = document.getElementById('music-downloaded-count');
                const downloaded = getDownloadedMusic();
                grid.innerHTML = '';
                if (!downloaded.length) {
                    if (countEl) countEl.textContent = '0 items';
                    empty.style.display = '';
                    return;
                }
                empty.style.display = 'none';
                if (countEl) countEl.textContent = `${downloaded.length} item${downloaded.length !== 1 ? 's' : ''}`;
                downloaded.forEach(track => {
                    const card = document.createElement('div');
                    card.className = 'music-card';
                    card.innerHTML = `
                        <div class="music-cover"><img loading="lazy" src="${track.cover}" alt="${track.title}"></div>
                        <div class="music-info">
                            <div class="music-title">${track.title}</div>
                            <div class="music-artist">${track.artist}</div>
                            <div class="music-actions">
                                <button class="music-play-btn" data-id="${track.id}" data-title="${track.title}" data-artist="${track.artist}" data-cover="${track.cover}"><i class="fas fa-play"></i> Play</button>
                                <button class="music-folder-btn" data-path="${track.filePath}" title="Open Folder"><i class="fas fa-folder-open"></i></button>
                                <button class="music-delete-downloaded-btn" data-id="${track.id}" data-path="${track.filePath}" title="Delete"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>`;
                    grid.appendChild(card);
                });

                // Play button handler
                grid.querySelectorAll('.music-play-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const el = e.currentTarget;
                        const tracks = downloaded.map(t => ({ id: String(t.id), title: t.title, artist: t.artist, cover: t.cover }));
                        const idx = tracks.findIndex(t => String(t.id) === String(el.getAttribute('data-id')));
                        if (idx >= 0 && tracks.length) {
                            setPlayQueue(tracks, idx);
                        } else {
                            playMusicTrack({
                                trackId: el.getAttribute('data-id'),
                                title: el.getAttribute('data-title'),
                                artistName: el.getAttribute('data-artist'),
                                coverSrc: el.getAttribute('data-cover')
                            });
                        }
                    });
                });

                // Open folder button handler
                grid.querySelectorAll('.music-folder-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const filePath = e.currentTarget.getAttribute('data-path');
                        if (filePath && window.electronAPI?.showFolderInExplorer) {
                            try {
                                // Get the directory path from file path
                                const dirPath = filePath.substring(0, filePath.lastIndexOf('\\'));
                                await window.electronAPI.showFolderInExplorer(dirPath);
                            } catch (error) {
                                console.error('Failed to open folder:', error);
                                showNotification('Failed to open folder', 'error');
                            }
                        }
                    });
                });

                // Delete button handler
                grid.querySelectorAll('.music-delete-downloaded-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const trackId = e.currentTarget.getAttribute('data-id');
                        const filePath = e.currentTarget.getAttribute('data-path');
                        
                        if (!confirm('Delete this downloaded track?')) return;

                        try {
                            // Delete file from disk
                            const res = await fetch('/api/music/delete', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ filePath })
                            });

                            if (!res.ok) {
                                const err = await res.json();
                                throw new Error(err.error || 'Delete failed');
                            }

                            // Remove from downloaded list and any active play queue
                            removeFromDownloaded(trackId);
                            if (Array.isArray(window.currentPlayQueue)) {
                                window.currentPlayQueue = window.currentPlayQueue.filter(t => String(t.id) !== String(trackId));
                                if (typeof window.currentQueueIndex === 'number') {
                                    window.currentQueueIndex = Math.min(window.currentQueueIndex, Math.max(0, window.currentPlayQueue.length - 1));
                                }
                            }
                            
                            // Re-render
                            renderDownloadedMusic();
                            showNotification('Track deleted', 'success');

                            // Re-render current music results if showing to update button
                            const currentResults = window.currentMusicResults || [];
                            const currentQuery = window.currentMusicQuery || '';
                            if (currentResults.length > 0) {
                                displayMusicResults(currentResults, currentQuery);
                            }

                        } catch (error) {
                            console.error('Delete error:', error);
                            showNotification(`Delete failed: ${error.message}`, 'error');
                        }
                    });
                });
            }

            // Playlist chooser events
            if (playlistChooserBack && playlistChooser) {
                playlistChooserBack.addEventListener('click', closePlaylistChooser);
                playlistChooser.addEventListener('click', (e) => {
                    if (e.target === playlistChooser) closePlaylistChooser();
                });
            }
            if (playlistChooserCreate) {
                playlistChooserCreate.addEventListener('click', () => {
                    const name = (playlistChooserNewName.value || '').trim();
                    if (!name) { showNotification('Enter a playlist name', 'warning'); return; }
                    const pls = getPlaylists();
                    if (pls.find(p => p.name.toLowerCase() === name.toLowerCase())) { showNotification('Playlist exists', 'info'); return; }
                    const id = 'pl_' + Math.random().toString(36).slice(2,10);
                    pls.push({ id, name, tracks: [] });
                    setPlaylists(pls);
                    playlistChooserNewName.value = '';
                    // Refresh chooser list
                    showPlaylistChooser(playlistChooserTrack || null);
                    showNotification('Playlist created', 'success');
                });
            }

            // Removed offline rendering and related actions

            // Render My Music grid
            function renderMyMusic() {
                const list = getMyMusic();
                const grid = document.getElementById('my-music-grid');
                const count = document.getElementById('my-music-count');
                const empty = document.getElementById('my-music-empty');
                grid.innerHTML = '';
                if (!list.length) {
                    count.textContent = '0 items';
                    empty.style.display = '';
                    return;
                }
                empty.style.display = 'none';
                count.textContent = `${list.length} item${list.length!==1?'s':''}`;
                list.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'music-card';
                    card.innerHTML = `
                        <div class="music-cover"><img loading="lazy" src="${item.cover}" alt="${item.title}"></div>
                        <div class="music-info">
                            <div class="music-title">${item.title}</div>
                            <div class="music-artist">${item.artist}</div>
                            <div class="music-actions">
                                <button class="music-play-btn" data-id="${item.id}"><i class="fas fa-play"></i> Play</button>
                                <button class="music-add-btn" title="Remove from My Music" data-remove="true" data-id="${item.id}"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>`;
                    grid.appendChild(card);
                });
                // wire play/open
                grid.querySelectorAll('.music-play-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const id = String(e.currentTarget.getAttribute('data-id'));
                        const list = getMyMusic().map(x => ({ id: String(x.id), title: x.title, artist: x.artist, cover: x.cover }));
                        const idx = list.findIndex(x => String(x.id) === id);
                        if (idx >= 0 && list.length) {
                            setPlayQueue(list, idx);
                        } else {
                            const card = e.currentTarget.closest('.music-card');
                            const title = card.querySelector('.music-title')?.textContent || 'Unknown Title';
                            const artistName = card.querySelector('.music-artist')?.textContent || 'Unknown Artist';
                            const coverSrc = card.querySelector('img')?.src || '';
                            await playMusicTrack({ trackId: id, title, artistName, coverSrc });
                        }
                    });
                });
                grid.querySelectorAll('.music-add-btn[data-remove="true"]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.currentTarget.getAttribute('data-id');
                        const list2 = getMyMusic().filter(x => x.id !== id);
                        setMyMusic(list2);
                        renderMyMusic();
                        showNotification('Removed from My Music', 'info');
                    });
                });
            }

            // Toggle My Music section
            const myBtn = document.getElementById('music-my-btn');
            if (myBtn) {
                myBtn.addEventListener('click', () => {
                    const mySec = document.getElementById('my-music');
                    const resSec = document.getElementById('music-results');
                    const empty = document.getElementById('music-empty');
                    const plsSec = document.getElementById('music-playlists');
                    const downloadedSec = document.getElementById('music-downloaded');
                    const myAlbumsSec2 = document.getElementById('my-albums');
                    const albumListSec2 = document.getElementById('music-albums');
                    const albumViewSec2 = document.getElementById('music-album-view');
                    const showing = mySec.style.display !== 'none';
                    if (showing) {
                        mySec.style.display = 'none';
                        // Restore last state: show results if present else empty
                        if (musicResultsGrid && musicResultsGrid.children.length) {
                            resSec.style.display = 'block';
                            empty.style.display = 'none';
                        } else {
                            resSec.style.display = 'none';
                            empty.style.display = '';
                        }
                        plsSec.style.display = 'none';
                        if (downloadedSec) downloadedSec.style.display = 'none';
                        if (myAlbumsSec2) myAlbumsSec2.style.display = 'none';
                        if (albumListSec2) albumListSec2.style.display = 'none';
                        if (albumViewSec2) albumViewSec2.style.display = 'none';
                        const musicPage = document.getElementById('music-page');
                        if (musicPage) musicPage.classList.remove('playlist-open');
                    } else {
                        renderMyMusic();
                        mySec.style.display = 'block';
                        resSec.style.display = 'none';
                        empty.style.display = 'none';
                        plsSec.style.display = 'none';
                        if (downloadedSec) downloadedSec.style.display = 'none';
                        if (myAlbumsSec2) myAlbumsSec2.style.display = 'none';
                        if (albumListSec2) albumListSec2.style.display = 'none';
                        if (albumViewSec2) albumViewSec2.style.display = 'none';
                        const musicPage = document.getElementById('music-page');
                        if (musicPage) musicPage.classList.remove('playlist-open');
                    }
                });
            }

            // Toggle Playlists
            const playlistsBtn = document.getElementById('music-playlists-btn');
            if (playlistsBtn) {
                playlistsBtn.addEventListener('click', () => {
                    const sec = document.getElementById('music-playlists');
                    const resSec = document.getElementById('music-results');
                    const empty = document.getElementById('music-empty');
                    const mySec = document.getElementById('my-music');
                    const downloadedSec = document.getElementById('music-downloaded');
                    const myAlbumsSec3 = document.getElementById('my-albums');
                    const showing = sec.style.display !== 'none';
                    if (showing) {
                        sec.style.display = 'none';
                        if (musicResultsGrid && musicResultsGrid.children.length) { resSec.style.display = 'block'; empty.style.display = 'none'; }
                        else { resSec.style.display = 'none'; empty.style.display = ''; }
                        const musicPage = document.getElementById('music-page');
                        if (musicPage) musicPage.classList.remove('playlist-open');
                        if (myAlbumsSec3) myAlbumsSec3.style.display = 'none';
                    } else {
                        renderPlaylists();
                        sec.style.display = 'block';
                        resSec.style.display = 'none';
                        empty.style.display = 'none';
                        mySec.style.display = 'none';
                        if (downloadedSec) downloadedSec.style.display = 'none';
                        if (myAlbumsSec3) myAlbumsSec3.style.display = 'none';
                        const musicPage = document.getElementById('music-page');
                        if (musicPage) musicPage.classList.remove('playlist-open');
                    }
                });
            }

            // Toggle Downloaded
            const downloadedBtn = document.getElementById('music-downloaded-btn');
            if (downloadedBtn) {
                downloadedBtn.addEventListener('click', async () => {
                    const sec = document.getElementById('music-downloaded');
                    const resSec = document.getElementById('music-results');
                    const empty = document.getElementById('music-empty');
                    const mySec = document.getElementById('my-music');
                    const plsSec = document.getElementById('music-playlists');
                    const myAlbumsSec = document.getElementById('my-albums');
                    const showing = sec.style.display !== 'none';
                    if (showing) {
                        sec.style.display = 'none';
                        if (musicResultsGrid && musicResultsGrid.children.length) { resSec.style.display = 'block'; empty.style.display = 'none'; }
                        else { resSec.style.display = 'none'; empty.style.display = ''; }
                        const musicPage = document.getElementById('music-page');
                        if (musicPage) musicPage.classList.remove('playlist-open');
                        if (myAlbumsSec) myAlbumsSec.style.display = 'none';
                    } else {
                        // Reconcile with disk before showing the list
                        try { await reconcileDownloadedMusicWithDisk(); } catch(_){ }
                        renderDownloadedMusic();
                        sec.style.display = 'block';
                        resSec.style.display = 'none';
                        empty.style.display = 'none';
                        mySec.style.display = 'none';
                        if (plsSec) plsSec.style.display = 'none';
                        if (myAlbumsSec) myAlbumsSec.style.display = 'none';
                        const musicPage = document.getElementById('music-page');
                        if (musicPage) musicPage.classList.remove('playlist-open');
                    }
                });
            }

            const createPlBtn = document.getElementById('playlist-create-btn');
            const plNameInput = document.getElementById('playlist-name-input');
            if (createPlBtn) {
                createPlBtn.addEventListener('click', () => {
                    const name = (plNameInput.value || '').trim();
                    if (!name) { showNotification('Enter a playlist name', 'warning'); return; }
                    const pls = getPlaylists();
                    if (pls.find(p => p.name.toLowerCase() === name.toLowerCase())) { showNotification('Playlist exists', 'info'); return; }
                    const id = 'pl_' + Math.random().toString(36).slice(2,10);
                    pls.push({ id, name, tracks: [] });
                    setPlaylists(pls);
                    plNameInput.value = '';
                    renderPlaylists();
                    showNotification('Playlist created', 'success');
                });
            }

            // Offline removed

            async function playMusicTrack({ trackId, title, artistName, coverSrc }) {
                if (!trackId) {
                    showNotification('Missing track ID', 'error');
                    return;
                }
                try {
                    // Check if this track is already downloaded
                    const downloaded = getDownloadedMusic();
                    const downloadedTrack = downloaded.find(t => String(t.id) === String(trackId));
                    
                    if (downloadedTrack && downloadedTrack.filePath) {
                        // Play from downloaded file
                        console.log('[MUSIC] Playing downloaded file:', downloadedTrack.filePath);
                        
                        // Show modal or mini player based on current state
                        if (isPlayerMinimized) {
                            miniPlayer.style.display = 'block';
                            musicModal.style.display = 'none';
                        } else {
                            musicModal.style.display = 'flex';
                            miniPlayer.style.display = 'none';
                        }
                        
                        musicModalTitle.textContent = 'Now Playing (Offline)';
                        musicSongTitle.textContent = title;
                        musicArtist.textContent = artistName;
                        if (coverSrc) musicCover.src = coverSrc;
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                        
                        // Update mini player info
                        if (miniPlayerSongTitle) miniPlayerSongTitle.textContent = title;
                        if (miniPlayerArtist) miniPlayerArtist.textContent = artistName;
                        if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                        // Clear existing sources
                        while (musicAudio.firstChild) musicAudio.removeChild(musicAudio.firstChild);
                        
                        // Use local file endpoint
                        const source = document.createElement('source');
                        source.src = `/api/music/serve/${encodeURIComponent(downloadedTrack.filePath)}`;
                        source.type = 'audio/flac';
                        musicAudio.appendChild(source);

                        // Load then play
                        musicAudio.load();
                        try {
                            await musicAudio.play();
                        } catch (err) {
                            await new Promise(r => setTimeout(r, 150));
                            await musicAudio.play();
                        }
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                        if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                        updateTimeDisplays();
                        
                        // Update Discord presence for music
                        updateDiscordForMusic(title, artistName, '');
                        return;
                    }
                    
                    // Not downloaded - stream from TIDAL
                    // Show modal or mini player based on current state
                    if (isPlayerMinimized) {
                        miniPlayer.style.display = 'block';
                        musicModal.style.display = 'none';
                    } else {
                        musicModal.style.display = 'flex';
                        miniPlayer.style.display = 'none';
                    }
                    
                    musicModalTitle.textContent = 'Now Playing';
                    musicSongTitle.textContent = title;
                    musicArtist.textContent = artistName;
                    if (coverSrc) musicCover.src = coverSrc;
                    musicPlayPauseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                    
                    // Update mini player info
                    if (miniPlayerSongTitle) miniPlayerSongTitle.textContent = title;
                    if (miniPlayerArtist) miniPlayerArtist.textContent = artistName;
                    if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                    const data = await musicFetchJson(`/track/?id=${encodeURIComponent(trackId)}&quality=LOSSLESS`);
                    let url = null;
                    if (Array.isArray(data) && data.length >= 3) {
                        // HiFi API returns [trackInfo, manifest, {OriginalTrackUrl: "..."}]
                        // We want the third element with OriginalTrackUrl
                        url = data[2]?.OriginalTrackUrl || data[2]?.originalTrackUrl;
                    }
                    // Fallback: scan all elements if not found
                    if (!url && Array.isArray(data)) {
                        for (const item of data) {
                            const candidate = item?.OriginalTrackUrl || item?.originalTrackUrl;
                            if (candidate && !candidate.startsWith('http://www.tidal.com')) {
                                url = candidate;
                                break;
                            }
                        }
                    }
                    if (!url) throw new Error('Track URL not found');

                    // Set <source> with a suitable type hint
                    while (musicAudio.firstChild) musicAudio.removeChild(musicAudio.firstChild);
                    const source = document.createElement('source');
                    source.src = url;
                    const lowerUrl = url.toLowerCase();
                    if (lowerUrl.includes('.flac')) source.type = 'audio/flac';
                    else if (lowerUrl.includes('.mp4') || lowerUrl.includes('.m4a')) source.type = 'audio/mp4';
                    else if (lowerUrl.includes('.aac')) source.type = 'audio/aac';
                    else if (lowerUrl.includes('.ogg') || lowerUrl.includes('.ogx')) source.type = 'audio/ogg';
                    musicAudio.appendChild(source);

                    // Load then play
                    musicAudio.load();
                    try {
                        await musicAudio.play();
                    } catch (err) {
                        await new Promise(r => setTimeout(r, 150));
                        await musicAudio.play();
                    }
                    musicPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    updateTimeDisplays();
                    
                    // Update Discord presence for music
                    updateDiscordForMusic(title, artistName, '');
                } catch (e) {
                    console.error('[MUSIC] Play error', e);
                    showNotification('Failed to play track', 'error');
                    musicModal.style.display = 'none';
                }
            }

            // Fully close/stop music modal and unload audio
            function closeMusicModal() {
                // Clear Discord presence when music stops
                if (discordMusicActive) {
                    clearDiscordPresence();
                }
                
                try {
                    if (musicAudio) {
                        try { musicAudio.pause(); } catch(_) {}
                        // Clear source(s) to stop network streaming
                        musicAudio.removeAttribute('src');
                        while (musicAudio.firstChild) musicAudio.removeChild(musicAudio.firstChild);
                        musicAudio.load();
                    }
                } catch(_) {}
                if (musicProgressFill) musicProgressFill.style.width = '0%';
                if (musicCurrentTime) musicCurrentTime.textContent = '0:00';
                if (musicTotalTime) musicTotalTime.textContent = '0:00';
                if (musicPlayPauseBtn) musicPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                if (musicModal) musicModal.style.display = 'none';
                if (miniPlayer) miniPlayer.style.display = 'none';
                isPlayerMinimized = false;
            }

            // Play All functionality and queue management
            let currentPlayQueue = [];
            let currentQueueIndex = 0;
            const MUSIC_AUTOPLAY_KEY = 'pt_music_autoplay_next_v1';
            let musicAutoPlayNext = false;
            let isPlayerMinimized = false; // Track if player is minimized

            // hydrate autoplay setting
            try {
                const savedAuto = localStorage.getItem(MUSIC_AUTOPLAY_KEY);
                musicAutoPlayNext = savedAuto === '1';
            } catch(_) {}

            function updateAutoplayToggleUI() {
                if (!musicAutoplayToggle) return;
                if (musicAutoPlayNext) {
                    musicAutoplayToggle.style.background = 'linear-gradient(135deg, rgba(236,72,153,0.25), rgba(168,85,247,0.25))';
                    musicAutoplayToggle.style.borderColor = 'rgba(236,72,153,0.55)';
                    musicAutoplayToggle.style.color = '#fff';
                } else {
                    musicAutoplayToggle.style.background = 'rgba(236,72,153,0.08)';
                    musicAutoplayToggle.style.borderColor = 'rgba(236,72,153,0.35)';
                    musicAutoplayToggle.style.color = '#ec4899';
                }
            }
            updateAutoplayToggleUI();
            if (musicAutoplayToggle) {
                musicAutoplayToggle.addEventListener('click', () => {
                    musicAutoPlayNext = !musicAutoPlayNext;
                    try { localStorage.setItem(MUSIC_AUTOPLAY_KEY, musicAutoPlayNext ? '1' : '0'); } catch(_) {}
                    updateAutoplayToggleUI();
                    showNotification(`Autoplay ${musicAutoPlayNext ? 'enabled' : 'disabled'}`, 'info');
                });
            }

            function setPlayQueue(tracks, startIndex) {
                if (!Array.isArray(tracks) || tracks.length === 0) {
                    currentPlayQueue = [];
                    currentQueueIndex = 0;
                    return false;
                }
                currentPlayQueue = tracks;
                currentQueueIndex = Math.max(0, Math.min(startIndex || 0, tracks.length - 1));
                const t = currentPlayQueue[currentQueueIndex];
                playMusicTrack({ trackId: t.id, title: t.title, artistName: t.artist, coverSrc: t.cover });
                return true;
            }

            function playAllTracks(tracks) {
                if (!tracks || tracks.length === 0) {
                    showNotification('No tracks to play', 'info');
                    return;
                }
                // Ensure Autoplay Next is ON for Play All so it advances through the queue
                musicAutoPlayNext = true;
                try { localStorage.setItem(MUSIC_AUTOPLAY_KEY, '1'); } catch(_) {}
                updateAutoplayToggleUI();
                
                // Store the queue
                currentPlayQueue = tracks;
                currentQueueIndex = 0;
                
                // Play the first track
                const firstTrack = tracks[0];
                playMusicTrack({
                    trackId: firstTrack.id,
                    title: firstTrack.title,
                    artistName: firstTrack.artist,
                    coverSrc: firstTrack.cover
                });
                
                showNotification(`Playing ${tracks.length} track${tracks.length !== 1 ? 's' : ''}`, 'success');
            }

            function playNextInQueue() {
                if (currentPlayQueue.length === 0) return;
                
                currentQueueIndex++;
                
                if (currentQueueIndex >= currentPlayQueue.length) {
                    // Queue finished
                    currentPlayQueue = [];
                    currentQueueIndex = 0;
                    showNotification('Queue finished', 'info');
                    if (musicAutoPlayNext) {
                        // exit the player when autoplay is on and queue ends
                        closeMusicModal();
                    }
                    return;
                }
                
                // Play next track
                const nextTrack = currentPlayQueue[currentQueueIndex];
                playMusicTrack({
                    trackId: nextTrack.id,
                    title: nextTrack.title,
                    artistName: nextTrack.artist,
                    coverSrc: nextTrack.cover
                });
            }

            function playPreviousInQueue() {
                if (currentPlayQueue.length === 0) return;
                // If we're >3s into the current track, just restart it
                if ((musicAudio?.currentTime || 0) > 3) {
                    try { musicAudio.currentTime = 0; } catch(_) {}
                    return;
                }
                if (currentQueueIndex <= 0) return;
                currentQueueIndex--;
                const prev = currentPlayQueue[currentQueueIndex];
                playMusicTrack({
                    trackId: prev.id,
                    title: prev.title,
                    artistName: prev.artist,
                    coverSrc: prev.cover
                });
            }

            // Modal Controls
            function updateTimeDisplays() {
                musicCurrentTime.textContent = fmtTime(musicAudio.currentTime || 0);
                musicTotalTime.textContent = fmtTime(musicAudio.duration || 0);
                const p = (musicAudio.currentTime || 0) / (musicAudio.duration || 1) * 100;
                musicProgressFill.style.width = `${p}%`;
                
                // Update mini player displays too
                if (miniCurrentTime) miniCurrentTime.textContent = fmtTime(musicAudio.currentTime || 0);
                if (miniTotalTime) miniTotalTime.textContent = fmtTime(musicAudio.duration || 0);
                if (miniProgressFill) miniProgressFill.style.width = `${p}%`;
            }
            
            // Minimize/Maximize functions
            function minimizeMusicPlayer() {
                if (musicModal) musicModal.style.display = 'none';
                if (miniPlayer) miniPlayer.style.display = 'block';
                isPlayerMinimized = true;
                // Sync play/pause state
                if (miniPlayPauseBtn) {
                    miniPlayPauseBtn.innerHTML = musicAudio.paused ? '<i class="fas fa-play"></i>' : '<i class="fas fa-pause"></i>';
                }
            }
            
            function maximizeMusicPlayer() {
                if (miniPlayer) miniPlayer.style.display = 'none';
                if (musicModal) musicModal.style.display = 'flex';
                isPlayerMinimized = false;
            }

            if (musicAudio) {
                musicAudio.addEventListener('timeupdate', updateTimeDisplays);
                musicAudio.addEventListener('loadedmetadata', updateTimeDisplays);
                musicAudio.addEventListener('ended', () => {
                    musicPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    // Auto-play next track in queue if available and enabled
                    if (musicAutoPlayNext) {
                        if (currentPlayQueue.length > 0 && currentQueueIndex < currentPlayQueue.length - 1) {
                            setTimeout(() => playNextInQueue(), 400);
                            return;
                        }
                        // If queue is empty or finished, exit player when autoplay is enabled
                        if (currentPlayQueue.length === 0 || currentQueueIndex >= currentPlayQueue.length - 1) {
                            setTimeout(() => closeMusicModal(), 250);
                        }
                    }
                });
            }

            if (musicPlayPauseBtn) {
                musicPlayPauseBtn.addEventListener('click', async () => {
                    if (musicAudio.paused) {
                        try { await musicAudio.play(); } catch(_) {}
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                        if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    } else {
                        musicAudio.pause();
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                        if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    }
                });
            }

            if (musicBackwardBtn) {
                musicBackwardBtn.addEventListener('click', () => {
                    musicAudio.currentTime = Math.max(0, (musicAudio.currentTime || 0) - 10);
                    updateTimeDisplays();
                });
            }

            if (musicForwardBtn) {
                musicForwardBtn.addEventListener('click', () => {
                    const dur = musicAudio.duration || 0;
                    musicAudio.currentTime = Math.min(dur, (musicAudio.currentTime || 0) + 10);
                    updateTimeDisplays();
                });
            }

            if (musicNextTrackBtn) {
                musicNextTrackBtn.addEventListener('click', () => {
                    if (currentPlayQueue.length === 0) return;
                    // Jump to next or finish
                    if (currentQueueIndex < currentPlayQueue.length - 1) playNextInQueue();
                    else closeMusicModal();
                });
            }

            if (musicPrevTrackBtn) {
                musicPrevTrackBtn.addEventListener('click', () => {
                    playPreviousInQueue();
                });
            }

            if (musicProgressBar) {
                musicProgressBar.addEventListener('click', (e) => {
                    const rect = musicProgressBar.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const ratio = Math.min(1, Math.max(0, x / rect.width));
                    musicAudio.currentTime = ratio * (musicAudio.duration || 0);
                    updateTimeDisplays();
                });
            }

            if (musicVolumeSlider) {
                const setVolumeFromEvent = (clientX) => {
                    const rect = musicVolumeSlider.getBoundingClientRect();
                    const x = clientX - rect.left;
                    const ratio = Math.min(1, Math.max(0, x / rect.width));
                    musicAudio.volume = ratio;
                    musicVolumeFill.style.width = `${ratio * 100}%`;
                };
                musicVolumeSlider.addEventListener('click', (e) => setVolumeFromEvent(e.clientX));
            }

            if (musicModalBack && musicModal) {
                musicModalBack.addEventListener('click', closeMusicModal);
                musicModal.addEventListener('click', (e) => {
                    if (e.target === musicModal) closeMusicModal();
                });
            }
            
            // Minimize/Maximize button handlers
            if (musicModalMinimize) {
                musicModalMinimize.addEventListener('click', () => {
                    minimizeMusicPlayer();
                    // Update mini player info
                    if (miniPlayerSongTitle) miniPlayerSongTitle.textContent = musicSongTitle.textContent;
                    if (miniPlayerArtist) miniPlayerArtist.textContent = musicArtist.textContent;
                });
            }
            
            if (miniPlayerMaximize) {
                miniPlayerMaximize.addEventListener('click', maximizeMusicPlayer);
            }
            
            // Mini player controls
            if (miniPlayPauseBtn) {
                miniPlayPauseBtn.addEventListener('click', async () => {
                    if (musicAudio.paused) {
                        try { await musicAudio.play(); } catch(_) {}
                        miniPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    } else {
                        musicAudio.pause();
                        miniPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    }
                });
            }
            
            if (miniBackwardBtn) {
                miniBackwardBtn.addEventListener('click', () => {
                    musicAudio.currentTime = Math.max(0, (musicAudio.currentTime || 0) - 10);
                    updateTimeDisplays();
                });
            }
            
            if (miniForwardBtn) {
                miniForwardBtn.addEventListener('click', () => {
                    const dur = musicAudio.duration || 0;
                    musicAudio.currentTime = Math.min(dur, (musicAudio.currentTime || 0) + 10);
                    updateTimeDisplays();
                });
            }
            
            if (miniPrevTrackBtn) {
                miniPrevTrackBtn.addEventListener('click', () => {
                    if (currentPlayQueue.length > 0 && currentQueueIndex > 0) {
                        playPreviousInQueue();
                    }
                });
            }
            
            if (miniNextTrackBtn) {
                miniNextTrackBtn.addEventListener('click', () => {
                    if (currentPlayQueue.length > 0 && currentQueueIndex < currentPlayQueue.length - 1) {
                        playNextInQueue();
                    }
                });
            }
            
            if (miniProgressBar) {
                miniProgressBar.addEventListener('click', (e) => {
                    const rect = miniProgressBar.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const ratio = Math.min(1, Math.max(0, x / rect.width));
                    musicAudio.currentTime = ratio * (musicAudio.duration || 0);
                    updateTimeDisplays();
                });
            }

            // Keyboard controls when modal open
            document.addEventListener('keydown', (e) => {
                if (!musicModal || musicModal.style.display === 'none') return;
                const tag = (document.activeElement && document.activeElement.tagName) || '';
                const isTyping = ['INPUT', 'TEXTAREA'].includes(tag);
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closeMusicModal();
                } else if (e.key === ' ' && !isTyping) {
                    e.preventDefault();
                    if (musicAudio.paused) {
                        musicAudio.play();
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                        if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    } else {
                        musicAudio.pause();
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                        if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    }
                }
            });

            // Wire search input/button
            if (musicSearchBtn && musicSearchInput) {
                musicSearchBtn.addEventListener('click', () => searchMusic(musicSearchInput.value));
                musicSearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') searchMusic(musicSearchInput.value);
                });
            }
            
            function openBookReader(readLink, title) {
                console.log('[BOOKS] Opening reader for:', title, readLink);
                booksReaderTitle.textContent = title;
                booksReaderFrame.src = readLink;
                booksReaderModal.style.display = 'flex';
                document.body.classList.add('books-reader-open');
            }
            
            function closeBooksReader() {
                booksReaderModal.style.display = 'none';
                booksReaderFrame.src = '';
                document.body.classList.remove('books-reader-open');
            }
            
            // Event listeners for books
            if (booksSearchBtn) {
                booksSearchBtn.addEventListener('click', () => {
                    const query = booksSearchInput.value;
                    searchBooks(query);
                });
            }
            
            if (booksSearchInput) {
                booksSearchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const query = booksSearchInput.value;
                        searchBooks(query);
                    }
                });
            }
            
            if (booksReaderBack) {
                booksReaderBack.addEventListener('click', closeBooksReader);
            }
            
            // Close reader modal when clicking outside
            booksReaderModal?.addEventListener('click', (e) => {
                if (e.target === booksReaderModal) {
                    closeBooksReader();
                }
            });

            // Streaming Server Configuration
            const serverConfig = [
                {
                    name: 'Videasy',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://player.videasy.net/movie/${id}`
                            : `https://player.videasy.net/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'LunaStream',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://lunastream.fun/watch/movie/${id}`
                            : `https://lunastream.fun/watch/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'VidRock',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidrock.net/movie/${id}`
                            : `https://vidrock.net/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'HexaWatch',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://hexa.watch/watch/movie/${id}`
                            : `https://hexa.watch/watch/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'FMovies',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://www.fmovies.gd/watch/movie/${id}`
                            : `https://www.fmovies.gd/watch/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'Xprime',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://xprime.tv/watch/${id}`
                            : `https://xprime.tv/watch/${id}/${season}/${episode}`
                },
                {
                    name: 'Vidnest',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidnest.fun/movie/${id}`
                            : `https://vidnest.fun/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'veloratv',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://veloratv.ru/watch/movie/${id}`
                            : `https://veloratv.ru/watch/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'Vidfast 1',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidfast.pro/movie/${id}`
                            : `https://vidfast.pro/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'Vidfast 2',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidfast.to/embed/movie/${id}`
                            : `https://vidfast.to/embed/tv/${id}/${season}/${episode}`
                },
                {
                    name: '111Movies',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://111movies.com/movie/${id}`
                            : `https://111movies.com/tv/${id}/${season}/${episode}`
                },
                
                {
                    name: 'MovieClub',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://moviesapi.club/movie/${id}`
                            : `https://moviesapi.club/tv/${id}-${season}-${episode}`
                },
                {
                    name: 'MapleTV',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://mapple.uk/watch/movie/${id}`
                            : `https://mapple.uk/watch/tv/${id}-${season}-${episode}`
                },
                {
                    name: '2Embed',
                    getUrl: (type, id, season, episode) =>
                        `https://multiembed.mov/?video_id=${id}&tmdb=1&media_type=${type}${type === 'tv' ? `&season=${season}&episode=${episode}` : ''}`
                },
                {
                    name: 'SmashyStream',
                    getUrl: (type, id, season, episode) =>
                        (type === 'movie'
                            ? `https://player.smashy.stream/movie/${id}`
                            : `https://player.smashy.stream/tv/${id}?s=${season}&e=${episode}`)
                },
                {
                    name: 'Autoembed',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://player.autoembed.cc/embed/movie/${id}`
                            : `https://player.autoembed.cc/embed/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'GoDrivePlayer',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://godriveplayer.com/player.php?imdb=${id}`
                            : `https://godriveplayer.com/player.php?type=tv&tmdb=${id}&season=${season}&episode=${episode}`
                },
                {
                    name: 'VidWTF Premium',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.wtf/api/4/movie/?id=${id}&color=e01621`
                            : `https://vidsrc.wtf/api/4/tv/?id=${id}&s=${season}&e=${episode}&color=e01621`
                }
            ];

            // Server Selection Modal Elements
            const serverSelectionModal = document.getElementById('server-selection-modal');
            const serverSelectionBack = document.getElementById('server-selection-back');
            const serverSelectionTitle = document.getElementById('server-selection-title');
            const serverMediaPoster = document.getElementById('server-media-poster');
            const serverMediaTitle = document.getElementById('server-media-title');
            const serverMediaSubtitle = document.getElementById('server-media-subtitle');
            const serverMediaYear = document.getElementById('server-media-year');
            const serverMediaRating = document.getElementById('server-media-rating');
            const serverDropdown = document.getElementById('server-dropdown');
            const serverWatchBtn = document.getElementById('server-watch-btn');
            const serverTorrentBtn = document.getElementById('server-torrent-btn');

            // Video Player Modal Elements
            const videoPlayerModal = document.getElementById('video-player-modal');
            const videoPlayerBack = document.getElementById('video-player-back');
            const videoPlayerTitle = document.getElementById('video-player-title');
            const videoPlayerFrame = document.getElementById('video-player-frame');
            const videoPlayerFullscreen = document.getElementById('video-player-fullscreen');

            // Media Data
            let currentMediaData = null;

            // Initialize server dropdown
            function initServerDropdown() {
                serverDropdown.innerHTML = '';
                serverConfig.forEach(server => {
                    const option = document.createElement('option');
                    option.value = server.name;
                    option.textContent = server.name;
                    if (server.name === selectedServer) {
                        option.selected = true;
                    }
                    serverDropdown.appendChild(option);
                });
            }

            // Show server selection modal
            function showServerSelection(mediaData) {
                currentMediaData = mediaData;
                console.log('[SERVERS] Showing server selection for:', mediaData);

                // Populate media info
                serverMediaTitle.textContent = mediaData.title;
                serverMediaSubtitle.textContent = mediaData.subtitle || '';
                serverMediaYear.textContent = mediaData.year || '';
                serverMediaRating.textContent = mediaData.rating ? ` ${mediaData.rating}` : '';
                serverMediaPoster.src = mediaData.poster || '';

                // Initialize dropdown
                initServerDropdown();

                // Show modal
                serverSelectionModal.style.display = 'flex';
                document.body.classList.add('server-modal-open');
            }

            // Hide server selection modal
            function hideServerSelection() {
                console.log('[SERVERS] Hiding server selection modal');
                
                // Close any active video player first
                const serverVideoSection = document.getElementById('server-video-section');
                if (serverVideoSection && serverVideoSection.style.display !== 'none') {
                    console.log('[SERVERS] Closing active video player before hiding modal');
                    closeVideoPlayer();
                }
                
                // Hide the modal
                serverSelectionModal.style.display = 'none';
                document.body.classList.remove('server-modal-open');
                currentMediaData = null;
                
                console.log('[SERVERS] Server selection modal hidden and video stopped');
            }
            
            // Debug: Test if showServerSelection is accessible
            console.log('[DEBUG] showServerSelection function exists:', typeof showServerSelection);

            // Show embedded video player
            function showVideoPlayer(url, title) {
                console.log('[SERVERS] Opening embedded video player for:', title, url);
                
                // Update Discord presence for streaming
                // Use TMDB title from currentContent, not the passed title parameter
                const tmdbTitle = currentContent?.title || currentContent?.name || title;
                
                // Determine provider based on selectedProvider setting
                let provider;
                if (selectedProvider === 'jackett') {
                    provider = 'Jackett';
                } else if (selectedProvider === 'nuvio') {
                    provider = 'Nuvio';
                } else if (selectedProvider === 'comet') {
                    provider = 'Comet';
                } else if (selectedProvider === '111477') {
                    provider = '111477';
                } else if (selectedProvider === 'moviebox') {
                    provider = 'MovieBox';
                } else if (selectedProvider === 'torrentio') {
                    provider = 'Torrentio';
                } else if (selectedProvider === 'torrentless') {
                    provider = 'PlayTorrio';
                } else {
                    provider = 'App Sources';  // Default fallback
                }
                
                // For TV shows, pass the season number
                const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
                updateDiscordForStreaming(tmdbTitle, provider, seasonNum);
                
                // Get embedded video elements
                const serverVideoSection = document.getElementById('server-video-section');
                const serverVideoTitle = document.getElementById('server-video-title');
                const serverVideoFrame = document.getElementById('server-video-frame');
                
                if (serverVideoSection && serverVideoTitle && serverVideoFrame) {
                    // Update title and URL
                    serverVideoTitle.textContent = title;
                    serverVideoFrame.removeAttribute('sandbox');
                    
                    // Store the expected URL pattern for monitoring
                    serverVideoFrame.expectedUrl = url;
                    serverVideoFrame.originalDomain = new URL(url).origin;
                    
                    // Set up URL monitoring
                    setupUrlMonitoring(serverVideoFrame, url);
                    
                    // Set the iframe source
                    serverVideoFrame.src = url;
                    
                    // Show the video section
                    serverVideoSection.style.display = 'block';
                    
                    // Auto-scroll to video player after a brief delay
                    setTimeout(() => {
                        serverVideoSection.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start' 
                        });
                    }, 500);
                    
                    console.log('[SERVERS] Embedded video player displayed successfully');
                } else {
                    console.error('[SERVERS] Embedded video elements not found, falling back to fullscreen');
                    // Fallback to original fullscreen method
                    videoPlayerTitle.textContent = title;
                    videoPlayerFrame.removeAttribute('sandbox');
                    videoPlayerFrame.src = url;
                    videoPlayerModal.style.display = 'flex';
                    document.body.classList.add('video-modal-open');
                    hideServerSelection();
                }
            }

            // Setup URL monitoring for iframe
            function setupUrlMonitoring(iframe, expectedUrl) {
                // Extract expected URL patterns for validation - STRICT MATCHING
                const urlPatterns = {
                    'vidrock.net': /^https:\/\/vidrock\.net\/(movie|tv)\/\d+(\?.*)?$/,
                    'hexa.watch': /^https:\/\/hexa\.watch\/watch\/(movie|tv)\/\d+(\?.*)?$/,
                    'www.fmovies.gd': /^https:\/\/www\.fmovies\.gd\/watch\/(movie|tv)\/\d+(\?.*)?$/,
                    'xprime.tv': /^https:\/\/xprime\.tv\/watch\/\d+(\?.*)?$/,
                    'vidnest.fun': /^https:\/\/vidnest\.fun\/(movie|tv)\/\d+(\?.*)?$/,
                    'player.videasy.net': /^https:\/\/player\.videasy\.net\/(movie|tv)\/\d+(\?.*)?$/,
                    'lunastream.fun': /^https:\/\/lunastream\.fun\/watch\/(movie\/\d+|tv\/\d+\/\d+\/\d+)(\?.*)?$/,
                    'veloratv.ru': /^https:\/\/veloratv\.ru\/watch\/(movie|tv)\/\d+(\?.*)?$/,
                    'vidfast.pro': /^https:\/\/vidfast\.pro\/(movie\/\d+|tv\/\d+\/\d+\/\d+)(\?.*)?$/,
                    'vidfast.to': /^https:\/\/vidfast\.to\/embed\/(movie\/\d+|tv\/\d+\/\d+\/\d+)(\?.*)?$/,
                    '111movies.com': /^https:\/\/111movies\.com\/(movie\/\d+|tv\/\d+\/\d+\/\d+)(\?.*)?$/,
                    'moviesapi.club': /^https:\/\/moviesapi\.club\/(movie\/\d+|tv\/\d+-\d+-\d+)(\?.*)?$/,
                    'mapple.uk': /^https:\/\/mapple\.uk\/watch\/(movie\/\d+|tv\/\d+-\d+-\d+)(\?.*)?$/,
                    'multiembed.mov': /^https:\/\/multiembed\.mov\/\?video_id=\d+&tmdb=1&media_type=(movie|tv)(\&.*)?$/,
                    'player.smashy.stream': /^https:\/\/player\.smashy\.stream\/(movie\/\d+|tv\/\d+\?s=\d+&e=\d+)(\?.*)?$/,
                    'player.autoembed.cc': /^https:\/\/player\.autoembed\.cc\/embed\/(movie|tv)\/\d+(\?.*)?$/,
                    'godriveplayer.com': /^https:\/\/godriveplayer\.com\/player\.php\?(imdb=\d+|type=tv&tmdb=\d+&season=\d+&episode=\d+)(\&.*)?$/,
                    'databasegdriveplayer.xyz': /^https:\/\/databasegdriveplayer\.xyz\/+player\.php\?tmdb=\d+(\&.*)?$/,
                    'database.gdriveplayer.us': /^https:\/\/database\.gdriveplayer\.us\/player\.php\?type=series&tmdb=\d+&season=\d+&episode=\d+(\&.*)?$/,
                    'cinemaos.tech': /^https:\/\/cinemaos\.tech\/player\/\d+(?:\/\d+\/\d+)?(\?.*)?$/,
                    'primesrc.me': /^https:\/\/primesrc\.me\/embed\/(movie|tv)\?tmdb=\d+(?:&season=\d+&episode=\d+)?(\&.*)?$/,
                    'vidsrc.wtf': /^https:\/\/vidsrc\.wtf\/api\/(1|2|3|4)\/(movie|tv)\/\?id=\d+(\&.*)?$/
                };
                
                // Get the domain from the expected URL
                const expectedDomain = new URL(expectedUrl).hostname;
                const pattern = urlPatterns[expectedDomain];
                
                if (!pattern) {
                    console.warn('[SERVERS] No URL pattern defined for domain:', expectedDomain);
                    return;
                }
                
                console.log('[SERVERS] Setting up URL monitoring for domain:', expectedDomain);
                console.log('[SERVERS] Expected URL pattern:', pattern);
                console.log('[SERVERS] Initial URL:', expectedUrl);
                
                // Monitor iframe load events
                iframe.addEventListener('load', function() {
                    try {
                        // Try to access iframe location (may be blocked by CORS)
                        const currentUrl = iframe.contentWindow.location.href;
                        console.log('[SERVERS] Iframe loaded URL:', currentUrl);
                        
                        // Check if current URL matches expected pattern
                        if (!pattern.test(currentUrl)) {
                            console.error('[SERVERS]  URL VIOLATION DETECTED!');
                            console.error('[SERVERS] Current URL:', currentUrl);
                            console.error('[SERVERS] Expected pattern:', pattern.toString());
                            console.error('[SERVERS] Closing player immediately!');
                            
                            closeVideoPlayer();
                            return;
                        } else {
                            console.log('[SERVERS]  URL pattern valid:', currentUrl);
                        }
                    } catch (e) {
                        // CORS restriction - iframe is on different domain
                        console.log('[SERVERS] Iframe access blocked (CORS) - this is normal for streaming sites');
                    }
                });
                
                // More aggressive monitoring - check on any iframe activity
                iframe.addEventListener('beforeunload', function() {
                    console.log('[SERVERS] Iframe beforeunload detected - page changing');
                });
                
                // Periodic URL checking (backup method) - more frequent
                const monitorInterval = setInterval(() => {
                    try {
                        if (!iframe || !iframe.contentWindow || !iframe.parentNode) {
                            console.log('[SERVERS] Iframe no longer exists, clearing monitor');
                            clearInterval(monitorInterval);
                            return;
                        }
                        
                        const currentUrl = iframe.contentWindow.location.href;
                        
                        // If we can access the URL and it doesn't match pattern, close player
                        if (currentUrl && !pattern.test(currentUrl)) {
                            console.error('[SERVERS]  PERIODIC CHECK: URL violation detected!');
                            console.error('[SERVERS] Current URL:', currentUrl);
                            console.error('[SERVERS] Expected pattern:', pattern.toString());
                            
                            clearInterval(monitorInterval);
                            
                            // Close player silently when navigation is detected
                            console.log('[SERVERS] Player closed: Detected navigation away from streaming content');
                            closeVideoPlayer();
                            return;
                        }
                        
                        console.log('[SERVERS]  Periodic check: URL monitoring active');
                    } catch (e) {
                        // Expected - CORS protection means iframe is still on streaming site
                        console.log('[SERVERS]  Periodic check: CORS blocked (streaming site active)');
                    }
                }, 1000); // Check every 1 second (more frequent)
                
                // Store interval for cleanup
                iframe.monitorInterval = monitorInterval;
            }

            // Close video player function
            function closeVideoPlayer() {
                console.log('[SERVERS] Closing video player due to URL violation');
                
                // Clear Discord presence when video closes
                if (discordStreamingActive) {
                    clearDiscordPresence();
                }
                
                const serverVideoSection = document.getElementById('server-video-section');
                const serverVideoFrame = document.getElementById('server-video-frame');
                
                if (serverVideoSection) {
                    // Hide the video player box
                    serverVideoSection.style.display = 'none';
                    console.log('[SERVERS] Video player box hidden');
                }
                
                if (serverVideoFrame) {
                    // Clear monitoring interval
                    if (serverVideoFrame.monitorInterval) {
                        clearInterval(serverVideoFrame.monitorInterval);
                        console.log('[SERVERS] URL monitoring interval cleared');
                    }
                    
                    // Remove the server content from iframe
                    serverVideoFrame.src = 'about:blank';
                    serverVideoFrame.removeAttribute('expectedUrl');
                    serverVideoFrame.removeAttribute('originalDomain');
                    
                    console.log('[SERVERS] Iframe cleared and server removed');
                }
                
                // Also clear the video title
                const serverVideoTitle = document.getElementById('server-video-title');
                if (serverVideoTitle) {
                    serverVideoTitle.textContent = 'Player Closed';
                }
                
                console.log('[SERVERS] Video player completely shut down');
            }

            // Hide video player
            function hideVideoPlayer() {
                videoPlayerModal.style.display = 'none';
                videoPlayerFrame.src = '';
                document.body.classList.remove('video-modal-open');
            }

            // Get streaming URL for current media
            function getStreamingUrl(mediaData, serverName) {
                console.log('[SERVERS] Generating URL for server:', serverName, 'media:', mediaData);
                
                // Define server configurations inline (serverConfig not accessible from this scope)
                const servers = {
                    'CinemaOS': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://cinemaos.tech/player/${id}`
                            : `https://cinemaos.tech/player/${id}/${season}/${episode}`,
                    'Videasy': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://player.videasy.net/movie/${id}`
                            : `https://player.videasy.net/tv/${id}/${season}/${episode}`,
                    'LunaStream': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://lunastream.fun/watch/movie/${id}`
                            : `https://lunastream.fun/watch/tv/${id}/${season}/${episode}`,
                    'VidRock': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidrock.net/movie/${id}`
                            : `https://vidrock.net/tv/${id}/${season}/${episode}`,
                    'HexaWatch': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://hexa.watch/watch/movie/${id}`
                            : `https://hexa.watch/watch/tv/${id}/${season}/${episode}`,
                    'FMovies': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://www.fmovies.gd/watch/movie/${id}`
                            : `https://www.fmovies.gd/watch/tv/${id}/${season}/${episode}`,
                    'Xprime': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://xprime.tv/watch/${id}`
                            : `https://xprime.tv/watch/${id}/${season}/${episode}`,
                    'Vidnest': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidnest.fun/movie/${id}`
                            : `https://vidnest.fun/tv/${id}/${season}/${episode}`,
                    'veloratv': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://veloratv.ru/watch/movie/${id}`
                            : `https://veloratv.ru/watch/tv/${id}/${season}/${episode}`,
                    'Vidfast 1': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidfast.pro/movie/${id}`
                            : `https://vidfast.pro/tv/${id}/${season}/${episode}`,
                    'Vidfast 2': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidfast.to/embed/movie/${id}`
                            : `https://vidfast.to/embed/tv/${id}/${season}/${episode}`,
                    '111Movies': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://111movies.com/movie/${id}`
                            : `https://111movies.com/tv/${id}/${season}/${episode}`,
                    'VidSrc 1': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.wtf/api/1/movie/?id=${id}&color=e01621`
                            : `https://vidsrc.wtf/api/1/tv/?id=${id}&s=${season}&e=${episode}&color=e01621`,
                    'VidSrc 2': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.wtf/api/2/movie/?id=${id}&color=e01621`
                            : `https://vidsrc.wtf/api/2/tv/?id=${id}&s=${season}&e=${episode}&color=e01621`,
                    'VidSrc 3': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.wtf/api/3/movie/?id=${id}&color=e01621`
                            : `https://vidsrc.wtf/api/3/tv/?id=${id}&s=${season}&e=${episode}&color=e01621`,
                    'VidSrc 4': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.wtf/api/4/movie/?id=${id}&color=e01621`
                            : `https://vidsrc.wtf/api/4/tv/?id=${id}&s=${season}&e=${episode}&color=e01621`,
                    'PrimeSrc': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://primesrc.me/embed/movie?tmdb=${id}`
                            : `https://primesrc.me/embed/tv?tmdb=${id}&season=${season}&episode=${episode}`,
                    'MovieClub': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://moviesapi.club/movie/${id}`
                            : `https://moviesapi.club/tv/${id}-${season}-${episode}`,
                    'MapleTV': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://mapple.uk/watch/movie/${id}`
                            : `https://mapple.uk/watch/tv/${id}-${season}-${episode}`,
                    '2Embed': (type, id, season, episode) =>
                        `https://multiembed.mov/?video_id=${id}&tmdb=1&media_type=${type}${type === 'tv' ? `&season=${season}&episode=${episode}` : ''}`,
                    'SmashyStream': (type, id, season, episode) =>
                        (type === 'movie'
                            ? `https://player.smashy.stream/movie/${id}`
                            : `https://player.smashy.stream/tv/${id}?s=${season}&e=${episode}`),
                    'Autoembed': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://player.autoembed.cc/embed/movie/${id}`
                            : `https://player.autoembed.cc/embed/tv/${id}/${season}/${episode}`,
                    'GoDrivePlayer': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://godriveplayer.com/player.php?imdb=${id}`
                            : `https://godriveplayer.com/player.php?type=tv&tmdb=${id}&season=${season}&episode=${episode}`,
                    'VidWTF Premium': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.wtf/api/4/movie/?id=${id}&color=e01621`
                            : `https://vidsrc.wtf/api/4/tv/?id=${id}&s=${season}&e=${episode}&color=e01621`,
                    // New additional servers
                    'CinemaOS Embed': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://cinemaos.tech/embed/movie/${id}`
                            : `https://cinemaos.tech/embed/tv/${id}/${season}/${episode}`,
                    
                    'GDrivePlayer API': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://databasegdriveplayer.xyz/player.php?tmdb=${id}`
                            : `https://database.gdriveplayer.us/player.php?type=series&tmdb=${id}&season=${season}&episode=${episode}`,
                    'Nontongo': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://nontongo.win/embed/movie/${id}`
                            : `https://nontongo.win/embed/tv/${id}/${season}/${episode}`,
                    
                    'SpencerDevs': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://spencerdevs.xyz/movie/${id}`
                            : `https://spencerdevs.xyz/tv/${id}/${season}/${episode}`,
                    'VidAPI': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidapi.xyz/embed/movie/${id}`
                            : `https://vidapi.xyz/embed/tv/${id}/${season}/${episode}`,
                    'Vidify': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidify.top/embed/movie/${id}`
                            : `https://vidify.top/embed/tv/${id}/${season}/${episode}`,
                    'VidSrc CX': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.cx/embed/movie/${id}`
                            : `https://vidsrc.cx/embed/tv/${id}/${season}/${episode}`,
                    'VidSrc ME': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.me/embed/movie/${id}`
                            : `https://vidsrc.me/embed/tv/${id}/${season}/${episode}`,
                    'VidSrc TO': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.to/embed/movie/${id}`
                            : `https://vidsrc.to/embed/tv/${id}/${season}/${episode}`,
                    'VidSrc VIP': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.vip/embed/movie/${id}`
                            : `https://vidsrc.vip/embed/tv/${id}/${season}/${episode}`,
                    'VixSrc': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vixsrc.to/movie/${id}/`
                            : `https://vixsrc.to/tv/${id}/${season}/${episode}/`
                };

                const serverFunction = servers[serverName];
                if (!serverFunction) {
                    console.error('[SERVERS] Server not found:', serverName);
                    return null;
                }

                const url = serverFunction(
                    mediaData.type,
                    mediaData.id,
                    mediaData.season,
                    mediaData.episode
                );
                
                console.log('[SERVERS] Generated URL:', url);
                return url;
            }

            // Event listeners for server selection
            if (serverSelectionBack) {
                serverSelectionBack.addEventListener('click', hideServerSelection);
            }

            if (serverDropdown) {
                serverDropdown.addEventListener('change', (e) => {
                    selectedServer = e.target.value;
                    localStorage.setItem('selectedServer', selectedServer);
                    console.log('[SERVERS] Selected server:', selectedServer);
                });
            }

            if (serverWatchBtn) {
                serverWatchBtn.addEventListener('click', () => {
                    console.log('[SERVERS] Start Watching button clicked!');
                    
                    // Try to get media data from multiple sources
                    const mediaData = currentMediaData || window.currentMediaData;
                    console.log('[SERVERS] currentMediaData:', currentMediaData);
                    console.log('[SERVERS] window.currentMediaData:', window.currentMediaData);
                    console.log('[SERVERS] Using mediaData:', mediaData);
                    
                    if (!mediaData) {
                        console.error('[SERVERS] No media data available');
                        alert('No media selected. Please select a movie or show first.');
                        return;
                    }
                    
                    // Get current selected server from dropdown
                    const currentSelectedServer = serverDropdown ? serverDropdown.value : (localStorage.getItem('selectedServer') || 'Videasy');
                    console.log('[SERVERS] Selected server:', currentSelectedServer);
                    
                    const streamUrl = getStreamingUrl(mediaData, currentSelectedServer);
                    console.log('[SERVERS] Generated stream URL:', streamUrl);
                    
                    if (streamUrl) {
                        const title = `${mediaData.title} - ${currentSelectedServer}`;
                        console.log('[SERVERS] Calling showVideoPlayer with:', title);
                        showVideoPlayer(streamUrl, title);
                    } else {
                        showNotification('Failed to generate streaming URL', 'error');
                    }
                });
            }

            if (serverTorrentBtn) {
                serverTorrentBtn.addEventListener('click', () => {
                    console.log('[SERVERS] Use Torrent Instead button clicked!');
                    
                    // Turn off streaming servers mode
                    localStorage.setItem('useStreamingServers', 'false');
                    console.log('[SERVERS] Disabled streaming servers mode');
                    
                    // Update toggle in settings for ALL instances
                    const useStreamingServersToggles = document.querySelectorAll('#useStreamingServersToggle');
                    useStreamingServersToggles.forEach(toggle => {
                        toggle.checked = false;
                    });
                    
                    // Update button text
                    updateWatchButtonText();
                    
                    // Hide server selection modal
                    hideServerSelection();
                    
                    // Fall back to torrent mode
                    if (currentMediaData && currentMediaData.fallbackToTorrent) {
                        console.log('[SERVERS] Calling fallback function');
                        currentMediaData.fallbackToTorrent();
                    } else {
                        console.log('[SERVERS] No fallback function, manually showing torrents');
                        // Manually trigger torrent display
                        const streamingMode = localStorage.getItem('useStreamingServers') === 'true';
                        console.log('[SERVERS] Streaming mode after toggle:', streamingMode);
                        if (!streamingMode && typeof showTorrents === 'function') {
                            showTorrents(null, currentMediaData?.season, currentMediaData?.episode);
                        }
                    }
                });
            }

            // Embedded video player event handlers
            const serverVideoClose = document.getElementById('server-video-close');
            const serverVideoFrame = document.getElementById('server-video-frame');

            if (serverVideoClose) {
                serverVideoClose.addEventListener('click', () => {
                    closeVideoPlayer();
                });
            }

            // Server switching while watching
            if (serverDropdown) {
                serverDropdown.addEventListener('change', (e) => {
                    const newServer = e.target.value;
                    const serverVideoSection = document.getElementById('server-video-section');
                    
                    // Only switch if video is currently playing
                    if (serverVideoSection && serverVideoSection.style.display !== 'none' && currentMediaData) {
                        console.log('[SERVERS] Switching to server:', newServer);
                        
                        // Update selected server
                        localStorage.setItem('selectedServer', newServer);
                        
                        // Generate new streaming URL
                        const newStreamUrl = getStreamingUrl(currentMediaData, newServer);
                        
                        if (newStreamUrl && serverVideoFrame) {
                            // Update iframe source
                            serverVideoFrame.src = newStreamUrl;
                            
                            // Update title to show new server
                            const serverVideoTitle = document.getElementById('server-video-title');
                            if (serverVideoTitle) {
                                serverVideoTitle.textContent = `${currentMediaData.title} - ${newServer}`;
                            }
                            
                            console.log('[SERVERS] Successfully switched to:', newServer);
                        } else {
                            console.error('[SERVERS] Failed to generate URL for server:', newServer);
                            // Revert dropdown selection
                            const oldServer = localStorage.getItem('selectedServer') || 'Videasy';
                            e.target.value = oldServer;
                        }
                    }
                });
            }

            // Video player event listeners
            if (videoPlayerBack) {
                videoPlayerBack.addEventListener('click', () => {
                    hideVideoPlayer();
                    if (currentMediaData) {
                        showServerSelection(currentMediaData);
                    }
                });
            }

            if (videoPlayerFullscreen) {
                videoPlayerFullscreen.addEventListener('click', () => {
                    const frame = videoPlayerFrame;
                    if (frame.requestFullscreen) {
                        frame.requestFullscreen();
                    } else if (frame.webkitRequestFullscreen) {
                        frame.webkitRequestFullscreen();
                    } else if (frame.msRequestFullscreen) {
                        frame.msRequestFullscreen();
                    }
                });
            }

            // Disable closing server selection when clicking on the backdrop
            // Absorb clicks on the empty area so they don't close or trigger anything behind
            serverSelectionModal?.addEventListener('click', (e) => {
                if (e.target === serverSelectionModal) {
                    e.stopPropagation();
                    // Intentionally do nothing: require explicit Back button to close
                }
            });
            // Also stop click propagation inside the content
            const serverSelectionContent = document.querySelector('#server-selection-modal .server-selection-content');
            serverSelectionContent?.addEventListener('click', (e) => e.stopPropagation());

            videoPlayerModal?.addEventListener('click', (e) => {
                if (e.target === videoPlayerModal) {
                    hideVideoPlayer();
                }
            });

            // Update watch button text based on streaming mode
            function updateWatchButtonText() {
                const watchBtn = document.getElementById('watchNowBtn');
                const note = document.getElementById('watchNowNote');
                const toggleBtn = document.getElementById('useStreamsBtn');
                const streamingMode = localStorage.getItem('useStreamingServers') === 'true';
                if (watchBtn) {
                    if (streamingMode) {
                        // For TV shows in streaming mode, hide the button and show hint
                        if (currentMediaType === 'tv') {
                            watchBtn.style.display = 'none';
                            if (note) note.style.display = '';
                        } else {
                            watchBtn.style.display = '';
                            watchBtn.innerHTML = '<i class="fas fa-play"></i> Watch Now';
                            if (note) note.style.display = 'none';
                        }
                    } else {
                        watchBtn.style.display = '';
                        watchBtn.innerHTML = '<i class="fas fa-play"></i> Find Media';
                        if (note) note.style.display = 'none';
                    }
                }

                // Update the toggle button label between Streams/Torrents
                if (toggleBtn) {
                    if (streamingMode) {
                        toggleBtn.innerHTML = '<i class="fas fa-magnet"></i> Use Torrents instead';
                    } else {
                        toggleBtn.innerHTML = '<i class="fas fa-broadcast-tower"></i> Use Streams instead';
                    }
                }
            }

            // Initialize streaming servers setting for ALL instances
            const useStreamingServersToggles = document.querySelectorAll('#useStreamingServersToggle');
            if (useStreamingServersToggles.length > 0) {
                const currentSetting = localStorage.getItem('useStreamingServers') === 'true';
                
                useStreamingServersToggles.forEach(toggle => {
                    toggle.checked = currentSetting;
                    toggle.addEventListener('change', (e) => {
                        const newValue = e.target.checked;
                        localStorage.setItem('useStreamingServers', newValue);
                        console.log('[SERVERS] Streaming servers mode:', newValue ? 'enabled' : 'disabled');
                        
                        // Update ALL other toggles to match
                        useStreamingServersToggles.forEach(t => t.checked = newValue);
                        
                        updateWatchButtonText(); // Update button text when mode changes
                    });
                });
            }

            // Set initial button text
            updateWatchButtonText();

            // Downloader wiring (top-level)
            const downloaderQuery = document.getElementById('downloaderQuery');
            const downloaderBtn = document.getElementById('downloaderSearchBtn');
            const downloaderResults = document.getElementById('downloaderResults');
            const downloaderEmpty = document.getElementById('downloaderEmpty');
            const filterMoviesBtn = document.getElementById('downloaderFilterMovies');
            const filterTvBtn = document.getElementById('downloaderFilterTV');
            let downloaderType = 'movies'; // 'movies' | 'tv'
            async function runDownloaderSearch(q) {
                if (!downloaderResults || !downloaderEmpty) return;
                const query = (q || '').trim();
                downloaderResults.innerHTML = '';
                downloaderResults.classList.remove('single');
                if (!query) { downloaderEmpty.style.display = ''; downloaderEmpty.textContent = 'Type a search above to see results.'; return; }
                downloaderEmpty.style.display = 'none';
                try {
                    // Try local 111477 service first
                    let results = [];
                    try {
                        const res = await fetch(`http://localhost:3000/111477/api/tmdb/search/${encodeURIComponent(query)}`);
                        if (res.ok) {
                            const data = await res.json();
                            results = Array.isArray(data?.results) ? data.results : [];
                        }
                    } catch (_) {}
                    if (!results.length) {
                        // Fallback: direct TMDB (movies + TV)
                        const [mRes, tvRes] = await Promise.all([
                            fetch(`https://api.themoviedb.org/3/search/movie?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&page=1&include_adult=false`),
                            fetch(`https://api.themoviedb.org/3/search/tv?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&page=1&include_adult=false`)
                        ]);
                        const [mData, tvData] = [await mRes.json(), await tvRes.json()];
                        const mResults = Array.isArray(mData?.results) ? mData.results.map(r => ({
                            title: r.title,
                            posterPath: r.poster_path ? `https://image.tmdb.org/t/p/w500${r.poster_path}` : '',
                            releaseDate: r.release_date || '',
                            year: r.release_date ? String(r.release_date).slice(0,4) : '',
                            tmdbId: r.id,
                            mediaType: 'movie'
                        })) : [];
                        const tvResults = Array.isArray(tvData?.results) ? tvData.results.map(r => ({
                            title: r.name,
                            posterPath: r.poster_path ? `https://image.tmdb.org/t/p/w500${r.poster_path}` : '',
                            releaseDate: r.first_air_date || '',
                            year: r.first_air_date ? String(r.first_air_date).slice(0,4) : '',
                            tmdbId: r.id,
                            mediaType: 'tv'
                        })) : [];
                        results = [...mResults, ...tvResults];
                    }
                    // Filter by selected type
                    const filtered = results.filter((item) => {
                        const mt = (item.mediaType || item.media_type || (item.firstAirDate || item.name ? 'tv' : 'movie')).toLowerCase();
                        return downloaderType === 'movies' ? mt === 'movie' : mt === 'tv';
                    });
                    if (!filtered.length) {
                        // Fallback fetch type-specific from TMDB if none after filtering
                        if (downloaderType === 'tv') {
                            const tvRes = await fetch(`https://api.themoviedb.org/3/search/tv?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&page=1&include_adult=false`);
                            const tvData = await tvRes.json();
                            results = Array.isArray(tvData?.results) ? tvData.results.map(r => ({
                                title: r.name,
                                posterPath: r.poster_path ? `https://image.tmdb.org/t/p/w500${r.poster_path}` : '',
                                releaseDate: r.first_air_date || '',
                                year: r.first_air_date ? String(r.first_air_date).slice(0,4) : '',
                                tmdbId: r.id,
                                mediaType: 'tv'
                            })) : [];
                        } else {
                            const mRes2 = await fetch(`https://api.themoviedb.org/3/search/movie?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&page=1&include_adult=false`);
                            const mData2 = await mRes2.json();
                            results = Array.isArray(mData2?.results) ? mData2.results.map(r => ({
                                title: r.title,
                                posterPath: r.poster_path ? `https://image.tmdb.org/t/p/w500${r.poster_path}` : '',
                                releaseDate: r.release_date || '',
                                year: r.release_date ? String(r.release_date).slice(0,4) : '',
                                tmdbId: r.id,
                                mediaType: 'movie'
                            })) : [];
                        }
                    } else {
                        results = filtered;
                    }
                    results = results.slice(0, 10);
                    if (!results.length) {
                        downloaderEmpty.style.display = '';
                        downloaderEmpty.textContent = downloaderType === 'movies' ? 'No movies found.' : 'No TV shows found.';
                        return;
                    }
                    const frag = document.createDocumentFragment();
                    results.forEach((item) => {
                        const card = document.createElement('div');
                        card.className = 'downloader-item';
                        card.tabIndex = 0;
                        const poster = item.posterPath || '';
                        const title = item.title || item.name || item.constructedName || 'Untitled';
                        const year = item.year || (item.releaseDate ? String(item.releaseDate).slice(0,4) : '');
                        const tmdbId = item.tmdbId || item.id || item.tmdb_id || '';
                        const mediaType = item.mediaType || item.media_type || (item.firstAirDate || item.name ? 'tv' : 'movie');
                        if (tmdbId) card.dataset.tmdbId = String(tmdbId);
                        if (mediaType) card.dataset.mediaType = String(mediaType);
                        card.innerHTML = `
                            <img loading="lazy" class="downloader-thumb" src="${poster}" alt="${title.replace(/"/g,'&quot;')}" onerror="this.style.opacity=0;" />
                            <div class="downloader-meta">
                                <div class="downloader-title">${title}</div>
                                <div class="downloader-year">${year || ''}</div>
                            </div>`;
                        card.addEventListener('click', (e) => {
                            e.preventDefault(); e.stopPropagation();
                            // Remove other cards and center the selected one
                            const container = downloaderResults;
                            document.querySelectorAll('.downloader-item').forEach(el => { if (el !== card) el.remove(); });
                            container.classList.add('single');
                            document.querySelectorAll('.downloader-item.selected').forEach(el => el.classList.remove('selected'));
                            card.classList.add('selected');
                            const id = card.dataset.tmdbId;
                            const type = (card.dataset.mediaType || 'movie').toLowerCase();
                            // Remove any previous blocks (files, tv controls)
                            container.querySelectorAll('.downloader-files-card, .downloader-tv-controls').forEach(el => el.remove());
                            if (id) {
                                if (type === 'tv') {
                                    fetchAndRenderTvSelectors(id, container);
                                } else {
                                    fetchDownloaderFilesByTmdb(id, container);
                                }
                            }
                        });
                        frag.appendChild(card);
                    });
                    downloaderResults.appendChild(frag);
                } catch (err) {
                    console.error('Downloader search failed:', err);
                    downloaderEmpty.style.display = '';
                    downloaderEmpty.textContent = 'Search failed.';
                }
            }
            function renderFilesCard(files, container, loadKey) {
                // If a key is provided but doesn't match the latest, skip (prevents duplicates)
                if (loadKey && container.dataset.filesLoadKey && container.dataset.filesLoadKey !== loadKey) return;
                const filesWrap = document.createElement('div');
                filesWrap.className = 'trakt-card downloader-files-card';
                filesWrap.style.maxWidth = '900px';
                filesWrap.style.width = '100%';
                const inner = document.createElement('div');
                inner.className = 'trakt-card-body';
                inner.innerHTML = `<h3 style="margin-bottom:0.75rem;">Available files (${files.length})</h3>`;
                if (!files.length) {
                    const empty = document.createElement('div');
                    empty.className = 'downloader-empty';
                    empty.textContent = 'No files found for this title.';
                    inner.appendChild(empty);
                } else {
                    const list = document.createElement('div');
                    list.style.display = 'flex';
                    list.style.flexDirection = 'column';
                    list.style.gap = '0.5rem';
                    // Show up to 100 files (increased from 50 due to multiple variants)
                    files.slice(0, 100).forEach(f => {
                        const row = document.createElement('div');
                        row.style.display = 'flex';
                        row.style.justifyContent = 'space-between';
                        row.style.alignItems = 'center';
                        row.style.background = 'rgba(255,255,255,0.06)';
                        row.style.border = '1px solid rgba(255,255,255,0.08)';
                        row.style.borderRadius = '10px';
                        row.style.padding = '0.6rem 0.8rem';
                        const name = document.createElement('div');
                        name.style.flex = '1';
                        name.style.marginRight = '0.75rem';
                        name.style.overflow = 'hidden';
                        name.style.whiteSpace = 'nowrap';
                        name.style.textOverflow = 'ellipsis';
                        name.textContent = f.name || 'File';
                        const size = document.createElement('div');
                        size.style.color = '#9ca3af';
                        size.style.marginRight = '0.75rem';
                        size.style.minWidth = '80px';
                        size.style.textAlign = 'right';
                        size.textContent = f.sizeFormatted || '';
                        const btn = document.createElement('button');
                        btn.className = 'api-btn api-btn-primary';
                        btn.innerHTML = '<i class="fas fa-download"></i> Download';
                        btn.addEventListener('click', async (ev) => {
                            ev.preventDefault(); ev.stopPropagation();
                            const href = f.url || '';
                            if (!href) return;
                            try {
                                if (window.electronAPI?.openExternal) {
                                    await window.electronAPI.openExternal(href);
                                } else {
                                    window.open(href, '_blank', 'noopener');
                                }
                            } catch (_) { window.open(href, '_blank'); }
                        });
                        row.appendChild(name);
                        row.appendChild(size);
                        row.appendChild(btn);
                        list.appendChild(row);
                    });
                    inner.appendChild(list);
                    
                    // If there are more files than displayed, show a note
                    if (files.length > 100) {
                        const moreNote = document.createElement('div');
                        moreNote.style.marginTop = '0.5rem';
                        moreNote.style.color = '#9ca3af';
                        moreNote.style.fontSize = '0.9rem';
                        moreNote.style.textAlign = 'center';
                        moreNote.textContent = `Showing first 100 of ${files.length} files`;
                        inner.appendChild(moreNote);
                    }
                }
                filesWrap.appendChild(inner);
                // Remove any previous files card before appending (last-writer-wins)
                container.querySelectorAll('.downloader-files-card').forEach(el => el.remove());
                container.appendChild(filesWrap);
            }

            function startFilesLoad(container) {
                const key = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
                container.dataset.filesLoadKey = key;
                return key;
            }

            async function fetchDownloaderFilesByTmdb(tmdbId, container) {
                try {
                    const loadKey = startFilesLoad(container);
                    const res = await fetch(`http://localhost:3000/111477/api/tmdb/movie/${encodeURIComponent(tmdbId)}`);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const data = await res.json();
                    
                    // Handle new multi-result format from 111477 API
                    let allFiles = [];
                    if (Array.isArray(data?.results)) {
                        // New format: extract files from all successful results
                        data.results.forEach(result => {
                            if (result.success && Array.isArray(result.files)) {
                                allFiles = allFiles.concat(result.files);
                            }
                        });
                    } else if (Array.isArray(data?.files)) {
                        // Old format: direct files array
                        allFiles = data.files;
                    }
                    
                    renderFilesCard(allFiles, container, loadKey);
                } catch (e) {
                    console.error('Failed to load files by TMDB id', e);
                    showNotification('Failed to load files for this title');
                }
            }

            async function fetchAndRenderTvSelectors(tmdbId, container) {
                // Controls card
                const ctrl = document.createElement('div');
                ctrl.className = 'trakt-card downloader-tv-controls';
                ctrl.style.maxWidth = '900px';
                ctrl.style.width = '100%';
                const body = document.createElement('div');
                body.className = 'trakt-card-body';
                body.innerHTML = '<h3 style="margin-bottom:0.75rem;">Pick season and episode</h3>';

                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.gap = '0.75rem';
                row.style.alignItems = 'center';
                row.style.flexWrap = 'wrap';

                const seasonLabel = document.createElement('label');
                seasonLabel.textContent = 'Season';
                seasonLabel.style.marginRight = '0.25rem';
                const seasonSel = document.createElement('select');
                seasonSel.style.padding = '0.5rem 0.6rem';
                seasonSel.style.borderRadius = '8px';
                seasonSel.style.border = '1px solid rgba(255,255,255,0.15)';
                seasonSel.style.background = 'rgba(0,0,0,0.25)';
                seasonSel.style.color = '#fff';

                const episodeLabel = document.createElement('label');
                episodeLabel.textContent = 'Episode';
                episodeLabel.style.marginRight = '0.25rem';
                const episodeSel = document.createElement('select');
                episodeSel.style.padding = '0.5rem 0.6rem';
                episodeSel.style.borderRadius = '8px';
                episodeSel.style.border = '1px solid rgba(255,255,255,0.15)';
                episodeSel.style.background = 'rgba(0,0,0,0.25)';
                episodeSel.style.color = '#fff';
                episodeSel.disabled = true;

                row.appendChild(seasonLabel);
                row.appendChild(seasonSel);
                row.appendChild(episodeLabel);
                row.appendChild(episodeSel);
                body.appendChild(row);
                ctrl.appendChild(body);
                container.appendChild(ctrl);

                // Fetch TMDB TV info for seasons
                try {
                    const infoRes = await fetch(`https://api.themoviedb.org/3/tv/${encodeURIComponent(tmdbId)}?api_key=${TMDB_API_KEY}`);
                    const info = await infoRes.json();
                    const numberOfSeasons = info?.number_of_seasons || (Array.isArray(info?.seasons) ? info.seasons.length : 0);
                    const seasons = [];
                    for (let s = 1; s <= numberOfSeasons; s++) seasons.push(s);
                    if (!seasons.length) {
                        showNotification('No seasons found for this show');
                        return;
                    }
                    seasonSel.innerHTML = seasons.map(s => `<option value="${s}">S${String(s).padStart(2,'0')}</option>`).join('');

                    seasonSel.addEventListener('change', async () => {
                        const sVal = Number(seasonSel.value);
                        episodeSel.disabled = true;
                        episodeSel.innerHTML = '';
                        // Remove prior files card if any
                        container.querySelectorAll('.downloader-files-card').forEach(el => el.remove());
                        try {
                            const seasonRes = await fetch(`https://api.themoviedb.org/3/tv/${encodeURIComponent(tmdbId)}/season/${encodeURIComponent(sVal)}?api_key=${TMDB_API_KEY}`);
                            const seasonData = await seasonRes.json();
                            const eps = Array.isArray(seasonData?.episodes) ? seasonData.episodes.map(e => e.episode_number) : [];
                            if (!eps.length && Number.isFinite(seasonData?.episode_count)) {
                                for (let e = 1; e <= seasonData.episode_count; e++) eps.push(e);
                            }
                            episodeSel.innerHTML = eps.map(e => `<option value="${e}">E${String(e).padStart(2,'0')}</option>`).join('');
                            episodeSel.disabled = eps.length === 0;
                        } catch (err) {
                            console.error('Failed to fetch episodes list', err);
                            showNotification('Failed to load episodes');
                        }
                    });

                    episodeSel.addEventListener('change', async () => {
                        const sVal = Number(seasonSel.value);
                        const eVal = Number(episodeSel.value);
                        // Remove prior files card if any
                        container.querySelectorAll('.downloader-files-card').forEach(el => el.remove());
                        try {
                            const loadKey = startFilesLoad(container);
                            const res = await fetch(`http://localhost:3000/111477/api/tmdb/tv/${encodeURIComponent(tmdbId)}/season/${encodeURIComponent(sVal)}/episode/${encodeURIComponent(eVal)}`);
                            if (!res.ok) throw new Error(`HTTP ${res.status}`);
                            const data = await res.json();
                            
                            // Handle new multi-result format from 111477 API
                            let allFiles = [];
                            if (Array.isArray(data?.results)) {
                                // New format: extract files from all successful results
                                data.results.forEach(result => {
                                    if (result.success && Array.isArray(result.files)) {
                                        allFiles = allFiles.concat(result.files);
                                    }
                                });
                            } else if (Array.isArray(data?.files)) {
                                // Old format: direct files array
                                allFiles = data.files;
                            }
                            
                            renderFilesCard(allFiles, container, loadKey);
                        } catch (err) {
                            console.error('Failed to load TV episode files', err);
                            showNotification('Failed to load files for this episode');
                        }
                    });

                    // Trigger initial season load to populate episodes
                    seasonSel.dispatchEvent(new Event('change'));
                } catch (err) {
                    console.error('Failed to fetch TV info', err);
                    showNotification('Failed to load TV seasons');
                }
            }

            if (filterMoviesBtn && filterTvBtn) {
                filterMoviesBtn.addEventListener('click', () => {
                    if (downloaderType !== 'movies') {
                        downloaderType = 'movies';
                        filterMoviesBtn.classList.add('active');
                        filterTvBtn.classList.remove('active');
                        if (downloaderQuery.value.trim()) runDownloaderSearch(downloaderQuery.value);
                    }
                });
                filterTvBtn.addEventListener('click', () => {
                    if (downloaderType !== 'tv') {
                        downloaderType = 'tv';
                        filterTvBtn.classList.add('active');
                        filterMoviesBtn.classList.remove('active');
                        if (downloaderQuery.value.trim()) runDownloaderSearch(downloaderQuery.value);
                    }
                });
            }

            if (downloaderBtn && downloaderQuery) {
                downloaderBtn.addEventListener('click', () => runDownloaderSearch(downloaderQuery.value));
                downloaderQuery.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') runDownloaderSearch(downloaderQuery.value);
                });
            }
            
            // Quick refresh button
            const quickRefresh = document.getElementById('quickRefresh');
            if (quickRefresh) {
                quickRefresh.addEventListener('click', () => {
                    window.location.reload();
                });
            }
            
            // Sort and Filter buttons (NEW UI)
            const sortBtn = document.getElementById('sortBtn');
            const filterBtn = document.getElementById('filterBtn');
            if (sortBtn) {
                sortBtn.addEventListener('click', () => {
                    // Cycle through sort options
                    if (currentSort === 'popularity') {
                        currentSort = 'rating';
                        showNotification('Sorted by Rating ');
                    } else if (currentSort === 'rating') {
                        currentSort = 'date';
                        showNotification('Sorted by Release Date ');
                    } else {
                        currentSort = 'popularity';
                        showNotification('Sorted by Popularity ');
                    }
                    refreshDisplay();
                });
            }
            if (filterBtn) {
                filterBtn.addEventListener('click', () => {
                    // Cycle through filter options
                    if (currentFilter === 'all') {
                        currentFilter = 'hd';
                        showNotification('Filter: HD Quality (7+ rating) ');
                    } else if (currentFilter === 'hd') {
                        currentFilter = '4k';
                        showNotification('Filter: 4K Quality (8+ rating) ');
                    } else {
                        currentFilter = 'all';
                        showNotification('Filter: All Content ');
                    }
                    refreshDisplay();
                });
            }
            
            // Live TV Event Listeners
            const liveTvCategorySelect = document.getElementById('livetv-category-select');
            if (liveTvCategorySelect) {
                liveTvCategorySelect.addEventListener('change', () => {
                    loadLiveTvMatches(liveTvCategorySelect.value);
                });
            }
            
            const liveTvStreamsClose = document.getElementById('livetv-streams-close');
            if (liveTvStreamsClose) {
                liveTvStreamsClose.addEventListener('click', () => {
                    const modal = document.getElementById('livetv-streams-modal');
                    if (modal) modal.style.display = 'none';
                });
            }
            
            const liveTvModalBack = document.getElementById('livetv-modal-back');
            if (liveTvModalBack) {
                liveTvModalBack.addEventListener('click', () => {
                    const modal = document.getElementById('livetv-stream-modal');
                    const iframe = document.getElementById('livetv-stream-iframe');
                    if (modal) modal.style.display = 'none';
                    if (iframe) iframe.src = ''; // Stop stream
                });
            }
            
            const liveTvCopyBtn = document.getElementById('livetv-copy-stream-btn');
            if (liveTvCopyBtn) {
                liveTvCopyBtn.addEventListener('click', async () => {
                    const modal = document.getElementById('livetv-stream-modal');
                    const streamUrl = modal?.dataset.currentStreamUrl;
                    
                    if (streamUrl) {
                        try {
                            await navigator.clipboard.writeText(streamUrl);
                            const originalText = liveTvCopyBtn.innerHTML;
                            liveTvCopyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                            liveTvCopyBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                            
                            setTimeout(() => {
                                liveTvCopyBtn.innerHTML = originalText;
                                liveTvCopyBtn.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
                            }, 2000);
                        } catch (err) {
                            console.error('Failed to copy:', err);
                            showNotification('Failed to copy link', 'error');
                        }
                    }
                });
            }
            
            // Close modals on background click
            const liveTvStreamsModal = document.getElementById('livetv-streams-modal');
            if (liveTvStreamsModal) {
                liveTvStreamsModal.addEventListener('click', (e) => {
                    if (e.target === liveTvStreamsModal) {
                        liveTvStreamsModal.style.display = 'none';
                    }
                });
            }
        }

        // Router handler
        async function handleRoute() {
            const hash = window.location.hash || '#/';
            // Default route
            if (hash === '#/' || hash === '#') {
                activeRoute = 'home';
                showSection('home');
                // Load home content if first time or if grid empty
                if (moviesGrid.children.length === 0) {
                    currentPage = 1;
                    moviesGrid.innerHTML = '';
                    await loadMovies(currentCategory);
                }
                return;
            }

            if (hash.startsWith('#/genre/')) {
    const genreName = decodeURIComponent(hash.slice('#/genre/'.length)).trim();
    activeRoute = 'genreDetails';
    showSection('genreDetails');
    await ensureGenresLoaded();
    await openGenreDetails(genreName);
    return;
} else if (hash === '#/genres') {
    activeRoute = 'genres';
    showSection('genres');
    await ensureGenresLoaded();
    renderGenres();
    return;
} else if (hash === '#/my-list') {
    activeRoute = 'my-list';
    showSection('my-list');
    await displayMyList();
    return;
} else if (hash === '#/done-watching') {
    activeRoute = 'done-watching';
    showSection('done-watching');
    await displayDoneWatching();
    return;
} else if (hash === '#/trakt') {
    activeRoute = 'trakt';
    showSection('trakt');
    return;
} else if (hash === '#/livetv') {
    activeRoute = 'livetv';
    showSection('livetv');
    await initLiveTv();
    return;
} else if (hash === '#/iptv') {
    activeRoute = 'iptv';
    showSection('iptv');
    reloadIptvPage();
    return;
} else if (hash === '#/games-downloader') {
    activeRoute = 'games-downloader';
    showSection('games-downloader');
    return;
} else if (hash === '#/minigames') {
    activeRoute = 'minigames';
    showSection('minigames');
    reloadMiniGamesPage();
    return;
} else if (hash === '#/books') {
    activeRoute = 'books';
    showSection('books');
    return;
} else if (hash === '#/music') {
    activeRoute = 'music';
    showSection('music');
    return;
} else if (hash === '#/booktorrio') {
    activeRoute = 'booktorrio';
    showSection('booktorrio');
    return;
} else if (hash === '#/anime') {
    activeRoute = 'anime';
    showSection('anime');
    return;
} else if (hash === '#/manga') {
    activeRoute = 'manga';
    showSection('manga');
    return;
} else if (hash === '#/downloader') {
    activeRoute = 'downloader';
    showSection('downloader');
    return;
} else if (hash === '#/settings') {
    activeRoute = 'settings';
    showSection('settings');
    await loadSettingsData();
    return;
}

            // Fallback
            activeRoute = 'home';
            showSection('home');
        }

        function showSection(section) {
            // Hide ALL known top-level pages first to avoid stacking
            const allPageIds = [
                'homePage','genresPage','genreDetailsPage','myListPage','doneWatchingPage',
                'trakt-page','livetv-page','iptv-page','games-downloader-page','minigames-page','books-page','music-page',
                'booktorrio-page','anime-page','manga-page','manga-reader-page','downloader-page','settings-page'
            ];
            allPageIds.forEach(id => { const el = document.getElementById(id); if (el) el.style.display = 'none'; });

            // Special leave-behavior
            // Stop music if we are not showing the music page AND player is not minimized
            if (section !== 'music') {
                const audio = document.getElementById('music-player-audio');
                const modal = document.getElementById('music-player-modal');
                const miniPlayer = document.getElementById('music-mini-player');
                
                // Only pause if mini player is not visible (not minimized)
                const isMiniPlayerVisible = miniPlayer && miniPlayer.style.display !== 'none';
                if (!isMiniPlayerVisible) {
                    if (audio) { try { audio.pause(); } catch(_) {} }
                    if (modal) modal.style.display = 'none';
                }
            }
            // Clear IPTV iframe if not on IPTV page
            if (section !== 'iptv') {
                try { clearIptvPage(); } catch(_) {}
            }
            // Clear MiniGames iframe if not on MiniGames page
            if (section !== 'minigames') {
                try { clearMiniGamesPage(); } catch(_) {}
            }

            // Map route section to element id
            const map = {
                'home': 'homePage',
                'genres': 'genresPage',
                'genreDetails': 'genreDetailsPage',
                'my-list': 'myListPage',
                'done-watching': 'doneWatchingPage',
                'trakt': 'trakt-page',
                'livetv': 'livetv-page',
                'iptv': 'iptv-page',
                'games-downloader': 'games-downloader-page',
                'minigames': 'minigames-page',
                'books': 'books-page',
                'music': 'music-page',
                'booktorrio': 'booktorrio-page',
                'anime': 'anime-page',
                'manga': 'manga-page',
                'manga-reader': 'manga-reader-page',
                'downloader': 'downloader-page',
                'settings': 'settings-page'
            };
            const targetId = map[section];
            if (targetId) {
                const el = document.getElementById(targetId);
                if (el) el.style.display = '';
                // One-off init for Trakt page when shown
                if (section === 'trakt' && el && !el.dataset.initialized) {
                    initializeTraktPage();
                    el.dataset.initialized = 'true';
                }
                
                // Update Discord presence for MiniGames
                if (section === 'minigames') {
                    if (window.electronAPI?.updateDiscordPresence) {
                        window.electronAPI.updateDiscordPresence({
                            details: 'Playing mini games',
                            state: 'PlayTorrio MiniGames',
                            largeImageKey: 'playtorrio',
                            largeImageText: 'PlayTorrio',
                            smallImageKey: 'gaming',
                            smallImageText: 'Gaming'
                        }).catch(err => console.error('Discord presence error:', err));
                    }
                }
                
                // Update Discord presence for Games Downloader
                if (section === 'games-downloader') {
                    if (window.electronAPI?.updateDiscordPresence) {
                        window.electronAPI.updateDiscordPresence({
                            details: 'Browsing PC games',
                            state: 'Games Downloader',
                            largeImageKey: 'playtorrio',
                            largeImageText: 'PlayTorrio',
                            smallImageKey: 'download',
                            smallImageText: 'Downloading'
                        }).catch(err => console.error('Discord presence error:', err));
                    }
                }
            }

            // Update nav/fab, reset load flag, scroll to top
            updateNavigationStates(section);
            updateFloatingSettingsButton(section);
            isLoading = false;
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function updateFloatingSettingsButton(section) {
            const floatingNav = document.getElementById('floatingNavContainer');
            if (floatingNav) {
                // Show only on home page in old UI
                if (section === 'home') {
                    floatingNav.classList.add('show-on-home');
                } else {
                    floatingNav.classList.remove('show-on-home');
                    floatingNav.classList.remove('active'); // Close menu when leaving home
                }
            }
        }

        function updateNavigationStates(activeSection) {
            // Update sidebar navigation (new UI)
            const sidebarNavItems = document.querySelectorAll('.nav-item[data-page]');
            sidebarNavItems.forEach(item => {
                item.classList.remove('active');
                if (item.dataset.page === activeSection || 
                    (activeSection === 'genreDetails' && item.dataset.page === 'genres')) {
                    item.classList.add('active');
                }
            });

            // Update header buttons (classic UI)
            const headerButtons = {
                'home': null, // No specific home button
                'genres': document.getElementById('genresBtn'),
                'my-list': document.getElementById('myListBtn'),
                'done-watching': document.getElementById('doneWatchingBtn'),
                'trakt': null // Trakt is only in new UI sidebar
            };

            // Reset all header button active states
            Object.values(headerButtons).forEach(btn => {
                if (btn) btn.classList.remove('active');
            });

            // Set active header button
            const activeBtn = headerButtons[activeSection];
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }

        async function ensureGenresLoaded() {
            if (genresLoaded) return;
            try {
                genresLoading.style.display = 'block';
                // Fetch movie and tv genres
                const [movieRes, tvRes] = await Promise.all([
                    fetch(`https://api.themoviedb.org/3/genre/movie/list?api_key=${TMDB_API_KEY}`),
                    fetch(`https://api.themoviedb.org/3/genre/tv/list?api_key=${TMDB_API_KEY}`)
                ]);
                const [movieData, tvData] = await Promise.all([movieRes.json(), tvRes.json()]);
                const map = new Map();
                (movieData.genres || []).forEach(g => {
                    const key = g.name.toLowerCase();
                    map.set(key, { name: g.name, movieId: g.id, tvId: null });
                });
                (tvData.genres || []).forEach(g => {
                    const key = g.name.toLowerCase();
                    if (map.has(key)) {
                        map.get(key).tvId = g.id;
                    } else {
                        map.set(key, { name: g.name, movieId: null, tvId: g.id });
                    }
                });
                genresMap = map;
                genresLoaded = true;
            } catch (e) {
                console.error('Error loading genres:', e);
            } finally {
                genresLoading.style.display = 'none';
            }
        }

        function renderGenres() {
            genresGrid.innerHTML = '';
            const entries = Array.from(genresMap.values()).sort((a, b) => a.name.localeCompare(b.name));
            entries.forEach(g => {
                const card = document.createElement('div');
                card.className = 'genre-card';
                card.innerHTML = `
                    <div class="genre-info">
                        <div class="genre-title">${g.name}</div>
                        <div class="genre-availability">
                            ${g.movieId ? '<span class="genre-chip"><i class="fas fa-film"></i> Movie</span>' : ''}
                            ${g.tvId ? '<span class="genre-chip"><i class="fas fa-tv"></i> TV</span>' : ''}
                        </div>
                    </div>
                `;
                card.addEventListener('click', () => {
                    window.location.hash = `#/genre/${encodeURIComponent(g.name)}`;
                });
                genresGrid.appendChild(card);
            });
        }

        function setGenreToggleActive() {
            toggleMoviesBtn.classList.toggle('active', currentGenreType === 'movie');
            toggleTVBtn.classList.toggle('active', currentGenreType === 'tv');
        }

        async function openGenreDetails(genreName) {
            const key = genreName.toLowerCase();
            currentGenre = genresMap.get(key);
            if (!currentGenre) {
                // If genre map not found (edge case), reload genres and try again
                await ensureGenresLoaded();
                currentGenre = genresMap.get(key);
            }
            if (!currentGenre) {
                genreTitleEl.textContent = genreName;
                genreResultsGrid.innerHTML = '';
                genreEmptyMessage.style.display = 'block';
                return;
            }

            genreTitleEl.textContent = currentGenre.name;

            // Default type preference: movie if available, else tv
            currentGenreType = currentGenre.movieId ? 'movie' : 'tv';
            setGenreToggleActive();

            // Reset results grid
            genreResultsGrid.innerHTML = '';
            genreEmptyMessage.style.display = 'none';
            genreCurrentPage = 1;

            await loadGenreItems();
        }

        function setGenreType(type) {
            currentGenreType = type;
            setGenreToggleActive();
            // Reset and reload
            genreResultsGrid.innerHTML = '';
            genreEmptyMessage.style.display = 'none';
            genreCurrentPage = 1;
            isLoading = false;
            loadGenreItems();
        }

        async function loadGenreItems() {
            if (isLoading) return;
            const genreId = currentGenreType === 'movie' ? currentGenre.movieId : currentGenre.tvId;
            if (!genreId) {
                genreEmptyMessage.style.display = 'block';
                return;
            }
            isLoading = true;
            genreLoadingIndicator.style.display = 'block';
            try {
                const url = `https://api.themoviedb.org/3/discover/${currentGenreType}?api_key=${TMDB_API_KEY}&with_genres=${genreId}&sort_by=popularity.desc&page=${genreCurrentPage}`;
                const res = await fetch(url);
                const data = await res.json();
                const items = data.results || [];
                if (genreCurrentPage === 1 && items.length === 0) {
                    genreEmptyMessage.style.display = 'block';
                } else {
                    displayGenreItems(items, currentGenreType);
                    genreCurrentPage++;
                }
            } catch (e) {
                console.error('Error loading genre items:', e);
            } finally {
                isLoading = false;
                genreLoadingIndicator.style.display = 'none';
            }
        }

        function displayGenreItems(items, mediaType) {
            items.forEach(item => {
                if (!item.poster_path) return;
                const card = document.createElement('div');
                card.className = 'movie-card';
                const title = item.title || item.name || 'Untitled';
                const year = (item.release_date || item.first_air_date || '').substring(0, 4);
                const rating = (item.vote_average || 0).toFixed(1);
                // Only show Done Watching button for movies (not TV shows)
                const doneBtnHTML = mediaType === 'movie'
                    ? `<button class="done-watching-btn" onclick="toggleDoneWatching(event, ${item.id}, '${mediaType}', '${title.replace(/'/g, "\\'")}', '${item.poster_path}', '${year}', ${item.vote_average || 0})">
                        <i class="fas fa-check"></i>
                      </button>`
                    : '';
                card.innerHTML = `
                    <button class="add-to-list-btn" onclick="toggleMyList(event, ${item.id}, '${mediaType}', '${title.replace(/'/g, "\\'")}', '${item.poster_path}', '${year}', ${item.vote_average || 0})">
                        <i class="fas fa-plus"></i>
                    </button>
                    ${doneBtnHTML}
                    <img loading="lazy" decoding="async" src="https://image.tmdb.org/t/p/w342${item.poster_path}" alt="${title}" class="movie-poster">
                    <div class="movie-info">
                        <h3 class="movie-title">${title}</h3>
                        <p class="movie-year">${year}</p>
                    </div>
                    <div class="movie-rating">
                        <i class="fas fa-star"></i> ${rating}
                    </div>
                `;
                card.addEventListener('click', () => openDetailsModal(item, mediaType));
                genreResultsGrid.appendChild(card);
            });
        }

        // Load movies from TMDB (home)
        async function loadMovies(category = 'all') {
            if (isLoading) return;
            isLoading = true;
            loadingIndicator.style.display = 'block';
            
            // Reset cache if it's the first page
            if (currentPage === 1) {
                allMoviesCache = [];
            }
            
            // Reset page title to Trending Now
            const homePageIcon = document.getElementById('homePageIcon');
            const homePageText = document.getElementById('homePageText');
            if (homePageIcon && homePageText) {
                homePageIcon.className = 'fas fa-fire';
                homePageText.textContent = 'Trending Now';
            }

            try {
                let url;
                if (category === 'all') {
                    url = `https://api.themoviedb.org/3/trending/all/week?api_key=${TMDB_API_KEY}&page=${currentPage}`;
                } else {
                    url = `https://api.themoviedb.org/3/trending/${category}/week?api_key=${TMDB_API_KEY}&page=${currentPage}`;
                }
                const response = await fetch(url);
                const data = await response.json();
                displayMovies(data.results, currentPage > 1);
                currentPage++;
            } catch (error) {
                console.error('Error fetching movies:', error);
            }

            isLoading = false;
            loadingIndicator.style.display = 'none';
        }

        // Search for movies and shows
        async function searchMovies(query) {
            if (isLoading) return;
            isLoading = true;
            moviesGrid.innerHTML = '';
            loadingIndicator.style.display = 'block';
            
            // Update page title for search
            const homePageIcon = document.getElementById('homePageIcon');
            const homePageText = document.getElementById('homePageText');
            if (homePageIcon && homePageText) {
                homePageIcon.className = 'fas fa-search';
                homePageText.textContent = `Search Results for "${query}"`;
            }

            try {
                const response = await fetch(`https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&page=1`);
                const data = await response.json();
                displayMovies(data.results);
            } catch (error) {
                console.error('Error searching movies:', error);
            }

            isLoading = false;
            loadingIndicator.style.display = 'none';
        }

        // Display movies in the grid (chunked + capped for performance)
        function displayMovies(movies, append = true) {
            // Cache movies for sorting/filtering
            if (!append) {
                allMoviesCache = [...movies];
            } else {
                allMoviesCache = [...allMoviesCache, ...movies];
            }
            
            // Apply current sort and filter
            let filteredMovies = applySortAndFilter([...movies]);
            // Build in a fragment to minimize reflows
            const frag = document.createDocumentFragment();
            for (const movie of filteredMovies) {
                if (!movie.poster_path) continue;
                const card = document.createElement('div');
                card.className = 'movie-card';
                card.dataset.rating = movie.vote_average || 0;
                card.dataset.date = movie.release_date || movie.first_air_date || '';
                const mediaType = movie.media_type || 'movie';
                const doneBtnHTML = mediaType === 'movie'
                    ? `<button class="done-watching-btn" onclick="toggleDoneWatching(event, ${movie.id}, '${mediaType}', '${(movie.title || movie.name || '').replace(/'/g, "\\'")}', '${movie.poster_path}', '${(movie.release_date || movie.first_air_date || '').substring(0, 4)}', ${movie.vote_average || 0})">
                        <i class="fas fa-check"></i>
                      </button>`
                    : '';
                const year = (movie.release_date || movie.first_air_date || '').substring(0, 4);
                const titleSafe = (movie.title || movie.name || '').replace(/'/g, "\\'");
                const posterUrl = `https://image.tmdb.org/t/p/w342${movie.poster_path}`; // lighter grid thumbs
                card.innerHTML = `
                    <button class="add-to-list-btn" onclick="toggleMyList(event, ${movie.id}, '${mediaType}', '${titleSafe}', '${movie.poster_path}', '${year}', ${movie.vote_average || 0})">
                        <i class="fas fa-plus"></i>
                    </button>
                    ${doneBtnHTML}
                    <img loading="lazy" decoding="async" src="${posterUrl}" alt="${titleSafe}" class="movie-poster">
                    <div class="movie-info">
                        <h3 class="movie-title">${movie.title || movie.name}</h3>
                        <p class="movie-year">${year}</p>
                    </div>
                    <div class="movie-rating">
                        <i class="fas fa-star"></i> ${Number(movie.vote_average || 0).toFixed(1)}
                    </div>
                `;
                card.addEventListener('click', () => openDetailsModal(movie, movie.media_type || null));
                frag.appendChild(card);
            }
            moviesGrid.appendChild(frag);

            // Cap total DOM nodes in perf-mode to keep things snappy on low-end machines
            try {
                if (document.body.classList.contains('perf-mode')) {
                    const MAX_CARDS = 300; // adjustable
                    while (moviesGrid.children.length > MAX_CARDS) {
                        moviesGrid.removeChild(moviesGrid.firstElementChild);
                    }
                }
            } catch(_) {}
        }
        
        // Apply sort and filter to movies
        function applySortAndFilter(movies) {
            let filtered = [...movies];
            
            // Apply filter
            if (currentFilter === 'hd') {
                filtered = filtered.filter(m => (m.vote_average || 0) >= 7);
            } else if (currentFilter === '4k') {
                filtered = filtered.filter(m => (m.vote_average || 0) >= 8);
            }
            
            // Apply sort
            if (currentSort === 'rating') {
                filtered.sort((a, b) => (b.vote_average || 0) - (a.vote_average || 0));
            } else if (currentSort === 'date') {
                filtered.sort((a, b) => {
                    const dateA = new Date(a.release_date || a.first_air_date || 0);
                    const dateB = new Date(b.release_date || b.first_air_date || 0);
                    return dateB - dateA;
                });
            }
            // popularity is default (no sorting needed as TMDB returns sorted by popularity)
            
            return filtered;
        }
        
        // Refresh display with current sort/filter
        function refreshDisplay() {
            moviesGrid.innerHTML = '';
            displayMovies(allMoviesCache, false);
        }

        // Handle infinite scroll - route aware
        function handleScroll(e) {
            let shouldLoad = false;
            
            // Check if we're in NEW UI mode (scrolling inside main element)
            if (document.body.classList.contains('ui-new')) {
                const mainElement = document.querySelector('.app-main main');
                if (mainElement && e && e.target === mainElement) {
                    const scrollTop = mainElement.scrollTop;
                    const scrollHeight = mainElement.scrollHeight;
                    const clientHeight = mainElement.clientHeight;
                    shouldLoad = scrollTop + clientHeight >= scrollHeight - 500 && !isLoading;
                }
            } else {
                // OLD UI mode (scrolling on window)
                shouldLoad = window.innerHeight + window.scrollY >= document.body.offsetHeight - 500 && !isLoading;
            }
            
            if (shouldLoad) {
                if (activeRoute === 'home') {
                    loadMovies(currentCategory);
                } else if (activeRoute === 'genreDetails') {
                    loadGenreItems();
                }
            }
        }

        // Open details modal (accept optional forced type)
        async function openDetailsModal(movie, forcedType = null) {
            currentContent = movie;
            // Determine media type
            if (forcedType) {
                currentMediaType = forcedType === 'tv' ? 'tv' : 'movie';
            } else {
                if (movie.media_type) {
                    currentMediaType = movie.media_type === 'tv' ? 'tv' : 'movie';
                } else {
                    // Infer by presence of 'name' vs 'title'
                    currentMediaType = movie.name && !movie.title ? 'tv' : 'movie';
                }
            }
            torrentsLoaded = false;
            torrentsContainer.style.display = 'none';
            torrentsList.innerHTML = '';

            modalBackdrop.src = `https://image.tmdb.org/t/p/w1280${movie.backdrop_path || movie.poster_path || ''}`;
            modalPoster.src = `https://image.tmdb.org/t/p/w342${movie.poster_path || movie.backdrop_path || ''}`;
            modalTitle.textContent = movie.title || movie.name || 'Untitled';
            modalRating.textContent = Number(movie.vote_average || 0).toFixed(1);
            modalYear.textContent = (movie.release_date || movie.first_air_date || '').substring(0, 4);
            modalOverview.textContent = movie.overview || '';

            // Store current movie data for Trakt
            currentMovie = movie;

            // Set up Trakt watchlist button
            setupTraktWatchlistButton();

            // Fetch additional details
            const detailsUrl = `https://api.themoviedb.org/3/${currentMediaType}/${movie.id}?api_key=${TMDB_API_KEY}&append_to_response=credits,similar`;
            try {
                const response = await fetch(detailsUrl);
                const details = await response.json();
                modalRuntime.textContent = details.runtime ? `${details.runtime} min` : (details.episode_run_time && details.episode_run_time.length ? `${details.episode_run_time[0]} min` : '');
                modalTagline.textContent = details.tagline || '';
                displayCast(details.credits?.cast || []);
                displaySimilar(details.similar?.results || [], currentMediaType);

                if (currentMediaType === 'tv') {
                    seasonsContainer.style.display = 'block';
                    displaySeasons(details.seasons || []);
                    // Load episodes for the first usable season by default
                    const firstSeason = (details.seasons || []).find(s => s.season_number !== 0);
                    if (firstSeason) {
                        currentSeason = firstSeason.season_number;
                        loadEpisodes(firstSeason.season_number);
                    }
                } else {
                    seasonsContainer.style.display = 'none';
                }

            } catch (error) {
                console.error('Error fetching details:', error);
            }

            detailsModal.classList.add('active');
            document.body.style.overflow = 'hidden';

            // Ensure the Watch Now UI reflects current mode and media type when opening
            try { updateWatchButtonText(); } catch(_) {}
        }

        // Close details modal
        function closeModal() {
            detailsModal.classList.remove('active');
            document.body.style.overflow = 'auto';
            
            // Reset provider selection to default
            selectedProvider = 'playtorrio';
            document.querySelectorAll('.provider-btn').forEach(btn => {
                if (btn.dataset.provider === 'playtorrio') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Reset tracked search parameters
            lastSearchedSeason = null;
            lastSearchedEpisode = null;
        }

        // Display cast
        function displayCast(cast) {
            castGrid.innerHTML = '';
            (cast || []).slice(0, 10).forEach(member => {
                const card = document.createElement('div');
                card.className = 'cast-card';
                card.innerHTML = `
                    <img src="${member.profile_path ? `https://image.tmdb.org/t/p/w185${member.profile_path}` : 'https://via.placeholder.com/185x278'}" alt="${member.name}" class="cast-img">
                    <p class="cast-name">${member.name}</p>
                    <p class="cast-character">${member.character || ''}</p>
                `;
                castGrid.appendChild(card);
            });
        }

        // Display similar content (force the same media type for correct behavior)
        function displaySimilar(similar, mediaType) {
            similarGrid.innerHTML = '';
            (similar || []).slice(0, 6).forEach(item => {
                if (!item.poster_path) return;
                const card = document.createElement('div');
                card.className = 'movie-card';
                card.innerHTML = `
                    <img src="https://image.tmdb.org/t/p/w300${item.poster_path}" alt="${item.title || item.name}" class="movie-poster" style="height: 225px;">
                    <div class="movie-info">
                        <h3 class="movie-title">${item.title || item.name}</h3>
                    </div>
                `;
                card.addEventListener('click', () => openDetailsModal(item, mediaType));
                similarGrid.appendChild(card);
            });
        }

        // Display seasons for TV shows
        function displaySeasons(seasons) {
            seasonSelector.innerHTML = '';
            seasons.forEach(season => {
                if (season.season_number === 0) return; // Skip specials
                const btn = document.createElement('button');
                btn.className = 'season-btn';
                btn.textContent = season.name;
                btn.dataset.seasonNumber = season.season_number;
                if (season.season_number === currentSeason) {
                    btn.classList.add('active');
                }
                btn.addEventListener('click', () => {
                    currentSeason = season.season_number;
                    document.querySelectorAll('.season-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    loadEpisodes(currentSeason);
                    torrentsContainer.style.display = 'block'; // Make torrents visible
                    fetchTorrents(currentSeason);
                });
                seasonSelector.appendChild(btn);
            });
        }

        // Load episodes for a season
        async function loadEpisodes(seasonNumber) {
            episodesGrid.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i></div>';
            try {
                const response = await fetch(`https://api.themoviedb.org/3/tv/${currentContent.id}/season/${seasonNumber}?api_key=${TMDB_API_KEY}`);
                const data = await response.json();
                displayEpisodes(data.episodes || []);
            } catch (error) {
                console.error(`Error fetching episodes for season ${seasonNumber}:`, error);
            }
        }

        // Display episodes
        function displayEpisodes(episodes) {
            episodesGrid.innerHTML = '';
            episodes.forEach(episode => {
                const card = document.createElement('div');
                card.className = 'episode-card';
                
                // Check if this episode is already in done watching
                const isEpisodeDone = doneWatchingCache.some(item => 
                    item.id === currentMovie.id && item.media_type === 'tv' && 
                    item.season === currentSeason && item.episode === episode.episode_number
                );
                
                card.innerHTML = `
                    <img src="${episode.still_path ? `https://image.tmdb.org/t/p/w300${episode.still_path}` : 'https://via.placeholder.com/300x169'}" alt="${episode.name}" class="episode-img">
                    <div class="episode-info">
                        <h4 class="episode-title">E${episode.episode_number}: ${episode.name}</h4>
                        <p class="episode-date">${episode.air_date || ''}</p>
                        <div class="episode-actions">
                            <button class="episode-done-btn ${isEpisodeDone ? 'is-done' : ''}" 
                                    onclick="toggleEpisodeDoneWatching(event, ${currentMovie.id}, '${currentMovie.title || currentMovie.name}', ${currentSeason}, ${episode.episode_number}, '${episode.name.replace(/'/g, "\\'")}', '${currentMovie.release_date?.substring(0, 4) || currentMovie.first_air_date?.substring(0, 4) || ''}', '${currentMovie.poster_path || ''}')"
                                    title="${isEpisodeDone ? 'Remove from Done Watching' : 'Mark Episode as Done Watching'}">
                                <i class="fas ${isEpisodeDone ? 'fa-check-circle' : 'fa-check'}"></i>
                            </button>
                        </div>
                    </div>
                `;
                card.addEventListener('click', (e) => {
                    // Don't select if clicking on the done button
                    if (e.target.closest('.episode-done-btn')) return;
                    
                    console.log('[DEBUG] Episode card clicked! Season:', currentSeason, 'Episode:', episode.episode_number);
                    
                    document.querySelectorAll('.episode-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    
                    try {
                        showTorrents(e, currentSeason, episode.episode_number);
                    } catch (error) {
                        console.error('[DEBUG] Error in episode showTorrents:', error);
                    }
                });
                episodesGrid.appendChild(card);
            });
        }

        // Show episode details modal
        function showEpisodeDetails(event, showId, showTitle) {
            event.stopPropagation();
            
            // Find all episodes for this show
            const showEpisodes = doneWatchingCache.filter(item => 
                item.id === showId && item.media_type === 'tv' && item.season && item.episode
            );
            
            if (showEpisodes.length === 0) return;
            
            // Get show poster from the first episode
            const showPoster = showEpisodes[0].poster_path;
            
            // Sort episodes by season and episode
            showEpisodes.sort((a, b) => {
                if (a.season !== b.season) return a.season - b.season;
                return a.episode - b.episode;
            });
            
            // Create modal
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content episode-modal">
                    <div class="modal-header">
                        <img loading="lazy" decoding="async" src="https://image.tmdb.org/t/p/w342${showPoster}" alt="${showTitle}" class="show-poster">
                        <div class="header-content">
                            <h2>${showTitle}</h2>
                            <p class="modal-subtitle"><i class="fas fa-tv"></i> ${showEpisodes.length} episode${showEpisodes.length > 1 ? 's' : ''} watched</p>
                        </div>
                        <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="episode-list">
                            ${showEpisodes.map(ep => `
                                <div class="episode-item">
                                    <div class="episode-number">S${ep.season}E${ep.episode}</div>
                                    <div class="episode-info">
                                        <h4>${ep.episode_title || `Episode ${ep.episode}`}</h4>
                                        <p><i class="fas fa-calendar"></i> Watched on ${new Date(ep.completed_date).toLocaleDateString()}</p>
                                    </div>
                                    <button class="episode-remove-btn" onclick="removeEpisodeFromDoneWatching(event, ${ep.id}, ${ep.season}, ${ep.episode})" title="Remove episode">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
        }
        
        // Remove individual episode from done watching
    async function removeEpisodeFromDoneWatching(event, showId, season, episode) {
            // Update cache in memory
            const beforeLen = doneWatchingCache.length;
            doneWatchingCache = doneWatchingCache.filter(item => {
                if (item.media_type === 'tv' && item.id === showId) {
                    return !(item.season === season && item.episode === episode);
                }
                return true;
            });
            if (doneWatchingCache.length !== beforeLen) {
                await saveDoneWatching();
            }
            
            // Sync with Trakt if available
            if (traktToken) {
                try {
                    {
                        await fetch('/api/trakt/scrobble/pause', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                token: traktToken,
                                show: {
                                    ids: { tmdb: showId },
                                    title: undefined,
                                    year: undefined
                                },
                                episode: {
                                    season: season,
                                    number: episode
                                }
                            })
                        });
                    }
                } catch (error) {
                    console.warn('Failed to remove episode from Trakt:', error);
                }
            }
            
            showNotification('Episode removed from done watching', 'success');
            
            // If Done Watching page is visible, re-render; otherwise keep context
            if (document.getElementById('doneWatchingPage').style.display !== 'none') {
                displayDoneWatching();
            }
            updateTraktPageStatus();
            updateAllDoneButtons(showId, 'tv');

            // Remove row in the modal immediately and update header count
            if (event && event.target) {
                const row = event.target.closest('.episode-item');
                const list = row?.closest('.episode-list');
                row?.remove();
                const headerCountEl = document.querySelector('.episode-modal .modal-subtitle');
                if (headerCountEl && list) {
                    const remaining = list.querySelectorAll('.episode-item').length;
                    headerCountEl.innerHTML = `<i class="fas fa-tv"></i> ${remaining} episode${remaining === 1 ? '' : 's'} watched`;
                }
            }
            
            // Close modal if no more episodes
            const remainingEpisodes = doneWatchingCache.filter(item => 
                item.id === showId && item.media_type === 'tv' && item.season && item.episode
            );
            if (remainingEpisodes.length === 0) {
                document.querySelector('.modal-overlay')?.remove();
            }
        }

        // Show torrents for the current content
        function showTorrents(event, season = null, episode = null) {
            // Safely check streaming servers setting
            const streamingMode = localStorage.getItem('useStreamingServers') === 'true';
            console.log('[SERVERS] showTorrents called with streaming mode:', streamingMode);
            console.log('[SERVERS] Season:', season, 'Episode:', episode);
            
            // Check if streaming servers mode is enabled
            if (streamingMode) {
                console.log('[SERVERS] Streaming servers enabled, showing server selection');
                showStreamingServerSelection(season, episode);
                return;
            }
            
            console.log('[SERVERS] Streaming servers disabled, showing torrents');
            if (!hasApiKey && !useTorrentless) {
                showApiSetupModal();
                return;
            }
            torrentsContainer.style.display = 'block';
            // Reset loaded state for new searches
            torrentsLoaded = false;
            fetchTorrents(season, episode);
        }

        // Show streaming server selection instead of torrents
        function showStreamingServerSelection(season = null, episode = null) {
            console.log('[SERVERS] showStreamingServerSelection called with:', { season, episode });
            
            if (!currentContent) {
                console.error('[SERVERS] No currentContent available');
                showNotification('No content selected', 'error');
                return;
            }

            console.log('[SERVERS] Current content:', currentContent);
            console.log('[SERVERS] Current media type:', currentMediaType);

            const mediaData = {
                type: currentMediaType,
                id: currentContent.id,
                title: currentContent.title || currentContent.name,
                season: season,
                episode: episode,
                year: currentMediaType === 'movie' ? 
                    (currentContent.release_date || '').substring(0, 4) : 
                    (currentContent.first_air_date || '').substring(0, 4),
                rating: currentContent.vote_average ? parseFloat(currentContent.vote_average).toFixed(1) : null,
                poster: currentContent.poster_path ? 
                    `https://image.tmdb.org/t/p/w342${currentContent.poster_path}` : 
                    null,
                subtitle: season && episode ? 
                    `Season ${season}, Episode ${episode}` : 
                    (currentMediaType === 'tv' ? 'TV Show' : 'Movie'),
                fallbackToTorrent: () => {
                    // Fallback to torrent mode if user clicks "Use Torrent Instead"
                    useStreamingServers = false;
                    localStorage.setItem('useStreamingServers', 'false');
                    updateWatchButtonText();
                    showTorrents(null, season, episode);
                }
            };

            console.log('[SERVERS] Media data prepared:', mediaData);
            
            // Show server selection modal directly
            try {
                // Set current media data globally
                window.currentMediaData = mediaData;
                currentMediaData = mediaData;
                
                // Get modal elements
                const serverSelectionModal = document.getElementById('server-selection-modal');
                const serverMediaTitle = document.getElementById('server-media-title');
                const serverMediaSubtitle = document.getElementById('server-media-subtitle');
                const serverMediaYear = document.getElementById('server-media-year');
                const serverMediaRating = document.getElementById('server-media-rating');
                const serverMediaPoster = document.getElementById('server-media-poster');
                const serverDropdown = document.getElementById('server-dropdown');
                
                if (!serverSelectionModal) {
                    throw new Error('Server selection modal not found in DOM');
                }
                
                // Populate media info
                if (serverMediaTitle) serverMediaTitle.textContent = mediaData.title;
                if (serverMediaSubtitle) serverMediaSubtitle.textContent = mediaData.subtitle || '';
                if (serverMediaYear) serverMediaYear.textContent = mediaData.year || '';
                if (serverMediaRating) serverMediaRating.textContent = mediaData.rating ? ` ${mediaData.rating}` : '';
                if (serverMediaPoster) serverMediaPoster.src = mediaData.poster || '';
                
                // Initialize dropdown
                if (serverDropdown) {
                    const currentSelectedServer = localStorage.getItem('selectedServer') || 'Videasy';
                    serverDropdown.innerHTML = '';
                    
                    const servers = [
                        { name: 'CinemaOS' },
                        { name: 'Videasy' },
                        { name: 'LunaStream' },
                        { name: 'Vidfast 1' },
                        { name: 'Vidfast 2' },
                        { name: '111Movies' },
                        { name: 'VidSrc 1' },
                        { name: 'VidSrc 2' },
                        { name: 'VidSrc 3' },
                        { name: 'VidSrc 4' },
                        { name: 'PrimeSrc' },
                        { name: 'VidRock' },
                        { name: 'HexaWatch' },
                        { name: 'FMovies' },
                        { name: 'Xprime' },
                        { name: 'Vidnest' },
                        { name: 'veloratv' },
                        { name: 'MovieClub' },
                        { name: 'MapleTV' },
                        { name: '2Embed' },
                        { name: 'SmashyStream' },
                        { name: 'Autoembed' },
                        { name: 'GoDrivePlayer' },
                        { name: 'VidWTF Premium' },
                        { name: 'GDrivePlayer API' },
                        { name: 'Nontongo' },
                        { name: 'SpencerDevs' },
                        { name: 'VidAPI' },
                        { name: 'Vidify' },
                        { name: 'VidSrc CX' },
                        { name: 'VidSrc ME' },
                        { name: 'VidSrc TO' },
                        { name: 'VidSrc VIP' },
                        { name: 'VixSrc' }
                    ];
                    
                    console.log('[SERVERS] Using servers array with length:', servers.length);
                    
                    servers.forEach(server => {
                        const option = document.createElement('option');
                        option.value = server.name;
                        option.textContent = server.name;
                        if (server.name === currentSelectedServer) {
                            option.selected = true;
                        }
                        serverDropdown.appendChild(option);
                    });
                    
                    console.log('[SERVERS] Dropdown populated with', serverDropdown.options.length, 'options');
                }
                
                // Show modal
                serverSelectionModal.style.display = 'flex';
                document.body.classList.add('server-modal-open');
                
                console.log('[SERVERS] Server selection modal displayed successfully');
            } catch (error) {
                console.error('[SERVERS] Error showing server selection:', error);
                alert('Error loading streaming servers: ' + error.message);
            }
        }

        // Fetch streams from Nuvio API (direct streaming links)
    async function fetchNuvioStreams(season = null, episode = null) {
            if (!currentContent) return;

            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching Nuvio...</div>';

            try {
                const tmdbId = currentContent.id;
                const mediaType = currentMediaType; // 'movie' or 'tv'

                // Get IMDB ID from TMDB
                const externalIdsUrl = `https://api.themoviedb.org/3/${mediaType}/${tmdbId}/external_ids?api_key=${TMDB_API_KEY}`;
                const externalIdsRes = await fetch(externalIdsUrl);
                if (!externalIdsRes.ok) throw new Error('Failed to get IMDB ID from TMDB');
                
                const externalIds = await externalIdsRes.json();
                const imdbId = externalIds.imdb_id;
                
                if (!imdbId) {
                    throw new Error('No IMDB ID found for this content');
                }

                // Febbox JWT token for Nuvio (supports custom UI token)
                const defaultFebboxToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE3NTU5MzQ2NzcsIm5iZiI6MTc1NTkzNDY3NywiZXhwIjoxNzg3MDM4Njk3LCJkYXRhIjp7InVpZCI6OTY3OTA3LCJ0b2tlbiI6ImRjZTBiZTUyNzgzODU1Njg5ZjNlMjBhZTIzODU2YzlkIn19.yAuVwTgLyO7sTH5rOi_-UaVAHqO0YzUkykXgQC2ci2E';
                const savedToken = (localStorage.getItem('febboxToken') || '').trim();
                const febboxToken = savedToken || defaultFebboxToken;

                // Build new Nuviostreams URL with cookies, region, providers
                const base = 'https://nuviostreams.hayd.uk';
                const cookiesSeg = `cookies=${encodeURIComponent(JSON.stringify([febboxToken]))}`; // cookies=%5B"<JWT>"%5D
                const regionSeg = 'region=UK3';
                const providersSeg = 'providers=showbox,vidzee,vidsrc,vixsrc,mp4hydra,uhdmovies,moviesmod,4khdhub,topmovies';
                let nuvioExternalUrl;
                if (mediaType === 'movie') {
                    nuvioExternalUrl = `${base}/${cookiesSeg}/${regionSeg}/${providersSeg}/stream/movie/${encodeURIComponent(imdbId)}.json`;
                } else if (season && episode) {
                    nuvioExternalUrl = `${base}/${cookiesSeg}/${regionSeg}/${providersSeg}/stream/series/${encodeURIComponent(imdbId)}:${encodeURIComponent(season)}:${encodeURIComponent(episode)}.json`;
                } else {
                    throw new Error('Season and episode required for TV shows');
                }

                console.log('[Nuvio] Trying direct URL:', nuvioExternalUrl);

                let data = null;
                let responseOk = false;
                try {
                    const response = await fetch(nuvioExternalUrl);
                    responseOk = response.ok;
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    data = await response.json();
                } catch (directErr) {
                    console.warn('[Nuvio] Direct fetch failed, falling back to backend proxy:', directErr?.message || directErr);
                    // Fallback to existing backend proxy if available
                    let proxyUrl;
                    if (mediaType === 'movie') {
                        proxyUrl = `${API_BASE_URL}/nuvio/stream/movie/${imdbId}?cookie=ui%3D${encodeURIComponent(febboxToken)}&region=US`;
                    } else {
                        proxyUrl = `${API_BASE_URL}/nuvio/stream/series/${imdbId}:${season}:${episode}?cookie=ui%3D${encodeURIComponent(febboxToken)}&region=US`;
                    }
                    console.log('[Nuvio] Fetching via proxy:', proxyUrl);
                    const response = await fetch(proxyUrl);
                    if (!response.ok) throw new Error(`Proxy Nuvio error: ${response.statusText}`);
                    data = await response.json();
                    responseOk = true;
                }
                if (!responseOk || !data) throw new Error('Failed to load Nuvio streams');
                const streams = data.streams || [];
                
                console.log('[Nuvio] Found', streams.length, 'streams');

                if (streams.length === 0) {
                    torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No Nuvio streams found</div>';
                    return;
                }

                // Reorder streams: all MoviesMod first (1080p preferred), then others in original order
                const withIndex = streams.map((s, i) => ({ s, i }));
                const mmRegex = /moviesmod/i;
                const p1080 = /1080p/i;
                withIndex.sort((a, b) => {
                    const aMM = mmRegex.test(a.s?.name || '') || mmRegex.test(a.s?.title || '');
                    const bMM = mmRegex.test(b.s?.name || '') || mmRegex.test(b.s?.title || '');
                    if (aMM && !bMM) return -1;
                    if (!aMM && bMM) return 1;
                    if (aMM && bMM) {
                        const a1080 = p1080.test(a.s?.name || '') || p1080.test(a.s?.title || '');
                        const b1080 = p1080.test(b.s?.name || '') || p1080.test(b.s?.title || '');
                        if (a1080 && !b1080) return -1;
                        if (!a1080 && b1080) return 1;
                    }
                    // Preserve original order otherwise
                    return a.i - b.i;
                });
                const prioritizedStreams = withIndex.map(x => x.s);

                // Cache streams globally and add size info for sorting
                allNuvioStreams = prioritizedStreams.map(stream => {
                    const sizeMatch = (stream.title || '').match(/([\d.]+)\s*(GB|MB)/i);
                    let sizeBytes = 0;
                    if (sizeMatch) {
                        const num = parseFloat(sizeMatch[1]);
                        const unit = sizeMatch[2].toUpperCase();
                        sizeBytes = unit === 'GB' ? num * 1024 * 1024 * 1024 : num * 1024 * 1024;
                    }
                    return { ...stream, sizeBytes };
                });

                // Display Nuvio streams as direct play buttons
                displayNuvioStreams(allNuvioStreams);

            } catch (error) {
                console.error('[Nuvio] Error:', error);
                torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> Nuvio Error: ${error.message}</div>`;
            }
        }

        // Display Nuvio streams (direct play, not torrents)
        function displayNuvioStreams(streams) {
            const torrentsList = document.getElementById('torrentsList');
            
            if (!streams || streams.length === 0) {
                torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No streams available</div>';
                return;
            }

            // Apply size filter first
            let filteredStreams = streams.slice();
            if (typeof torrentSizeFilter === 'string' && torrentSizeFilter !== 'all') {
                console.log('[Nuvio] Applying size filter:', torrentSizeFilter);
                filteredStreams = filteredStreams.filter(stream => bytesMatchesSizeFilter(stream.sizeBytes));
                console.log('[Nuvio] After filter:', filteredStreams.length, 'of', streams.length, 'streams remain');
            }

            // Check if filter eliminated all results
            if (filteredStreams.length === 0) {
                torrentsList.innerHTML = '<p>No streams match your size filter.</p>';
                return;
            }

            // Apply sorting if sort mode is size-based
            let sortedStreams = filteredStreams.slice();
            const mode = (typeof torrentSortMode === 'string') ? torrentSortMode : 'seeders';
            
            if (mode === 'size-asc') {
                console.log('[Nuvio] Sorting by size ascending');
                sortedStreams.sort((a, b) => (a.sizeBytes || 0) - (b.sizeBytes || 0));
            } else if (mode === 'size-desc') {
                console.log('[Nuvio] Sorting by size descending');
                sortedStreams.sort((a, b) => (b.sizeBytes || 0) - (a.sizeBytes || 0));
            } else {
                console.log('[Nuvio] Using default priority order (MoviesMod first)');
            }

            torrentsList.innerHTML = '';
            
            sortedStreams.forEach((stream, index) => {
                const streamDiv = document.createElement('div');
                streamDiv.className = 'torrent-item';
                streamDiv.style.cursor = 'default';
                
                // Parse stream info
                const name = stream.name || `Stream ${index + 1}`;
                const title = stream.title || '';
                const url = stream.url;
                
                // Extract quality and size info from title
                const titleLines = title.split('\n');
                const mainTitle = titleLines[0] || '';
                const details = titleLines[1] || '';
                
                streamDiv.innerHTML = `
                    <div class="torrent-info">
                        <div class="torrent-name">${name}</div>
                        ${mainTitle ? `<div style="color: var(--gray); font-size: 0.85rem; margin: 0.25rem 0;">${mainTitle}</div>` : ''}
                        ${details ? `<div class="torrent-details">
                            <span>${details}</span>
                        </div>` : ''}
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="torrent-btn play-nuvio-btn" data-url="${url}" data-name="${name}">
                            <i class="fas fa-play"></i> Play Now
                        </button>
                        <button class="torrent-btn mpv-nuvio-btn" data-url="${url}" data-name="${name}">
                            <i class="fas fa-external-link-alt"></i> Open in MPV
                        </button>
                        <button class="torrent-btn vlc-nuvio-btn" data-url="${url}" data-name="${name}">
                            <i class="fas fa-external-link-alt"></i> Open in VLC
                        </button>
                        <button class="torrent-btn cast-nuvio-btn" data-url="${url}" data-name="${name}">
                            <i class="fas fa-tv"></i> Cast
                        </button>
                    </div>
                `;
                
                torrentsList.appendChild(streamDiv);
            });

            // Add event listeners for Nuvio play buttons
            document.querySelectorAll('.play-nuvio-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const url = btn.dataset.url;
                    const name = btn.dataset.name;
                    playNuvioStream(url, name);
                });
            });

            document.querySelectorAll('.mpv-nuvio-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const url = btn.dataset.url;
                    const name = btn.dataset.name;
                    openNuvioInMPV(url, name);
                });
            });

            document.querySelectorAll('.vlc-nuvio-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const url = btn.dataset.url;
                    const name = btn.dataset.name;
                    openNuvioInVLC(url, name);
                });
            });

            // Add event listeners for Nuvio cast buttons
            document.querySelectorAll('.cast-nuvio-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const url = btn.dataset.url;
                    const name = btn.dataset.name;
                    try {
                        // Set current stream and show device picker to cast
                        currentStreamUrl = url;
                        currentSelectedVideoName = name;
                        await showChromecastDevicePicker();
                    } catch (e) {
                        console.error('[Nuvio] Cast error:', e);
                        showNotification('Failed to initiate casting', 'error');
                    }
                });
            });
        }

        // Play Nuvio stream directly (not a torrent)
        async function playNuvioStream(url, name) {
            try {
                console.log('[Nuvio] Playing stream in custom player:', url);
                
                // Set current stream URL and name
                currentStreamUrl = url;
                currentSelectedVideoName = name;
                
                // Update player title
                if (customPlayerTitle) {
                    customPlayerTitle.innerHTML = `<span>${name}</span> <span class="source-badge direct-stream" title="Direct Stream">Nuvio</span>`;
                }
                
                // Open in custom player
                openCustomPlayer();
                
                showNotification('Playing in browser player', 'success');
            } catch (error) {
                console.error('[Nuvio] Play error:', error);
                showNotification('Failed to play stream', 'error');
            }
        }

        // Open Nuvio stream in MPV
        async function openNuvioInMPV(url, name) {
            try {
                console.log('[Nuvio] Opening in MPV:', url);
                
                if (!window.electronAPI || !window.electronAPI.openInMPV) {
                    showNotification('MPV integration not available', 'error');
                    return;
                }
                
                // Set current stream for MPV
                currentStreamUrl = url;
                currentSelectedVideoName = name;
                
                // Open in external MPV
                const data = {
                    streamUrl: url,
                    infoHash: null,
                    startSeconds: undefined
                };
                
                const result = await window.electronAPI.openInMPV(data);
                if (result.success) {
                    showNotification('Opened in MPV', 'success');
                } else {
                    showNotification(`MPV Error: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('[Nuvio] MPV open error:', error);
                showNotification('Failed to open in MPV', 'error');
            }
        }
            // Open Nuvio stream in VLC
            async function openNuvioInVLC(url, name) {
                try {
                    console.log('[Nuvio] Opening in VLC:', url);
                    if (!window.electronAPI || !window.electronAPI.openInVLC) {
                        showNotification('VLC integration not available', 'error');
                        return;
                    }
                    // Set current stream context (for resume/discord)
                    currentStreamUrl = url;
                    currentSelectedVideoName = name;

                    const title = currentContent?.title || currentContent?.name || 'Video';
                    const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
                    updateDiscordForStreaming(title, 'Nuvio', seasonNum);

                    const data = {
                        streamUrl: url,
                        infoHash: (currentTorrentData && currentTorrentData.infoHash) ? currentTorrentData.infoHash : null,
                        startSeconds: (resumeInfo && typeof resumeInfo.position === 'number' && resumeInfo.position > 10) ? Math.floor(resumeInfo.position) : undefined
                    };
                    const result = await window.electronAPI.openInVLC(data);
                    if (result?.success) {
                        showNotification('Opened in VLC', 'success');
                    } else {
                        showNotification(`VLC Error: ${result?.message || result?.error || 'Unknown error'}`, 'error');
                    }
                } catch (error) {
                    console.error('[Nuvio] VLC open error:', error);
                    showNotification('Failed to open in VLC', 'error');
                }
            }


        // Fetch torrents from Comet API
        async function fetchCometTorrents(season = null, episode = null) {
            if (!currentContent) return;

            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching Comet...</div>';

            try {
                const tmdbId = currentContent.id;
                const mediaType = currentMediaType; // 'movie' or 'tv'

                // Get IMDB ID from TMDB
                const externalIdsUrl = `https://api.themoviedb.org/3/${mediaType}/${tmdbId}/external_ids?api_key=${TMDB_API_KEY}`;
                const externalIdsRes = await fetch(externalIdsUrl);
                if (!externalIdsRes.ok) throw new Error('Failed to get IMDB ID from TMDB');
                
                const externalIds = await externalIdsRes.json();
                const imdbId = externalIds.imdb_id;
                
                if (!imdbId) {
                    throw new Error('No IMDB ID found for this content');
                }

                // Comet config (base64 encoded configuration)
                const cometConfig = 'eyJtYXhSZXN1bHRzUGVyUmVzb2x1dGlvbiI6MCwibWF4U2l6ZSI6MCwiY2FjaGVkT25seSI6dHJ1ZSwicmVtb3ZlVHJhc2giOnRydWUsInJlc3VsdEZvcm1hdCI6WyJhbGwiXSwiZGVicmlkU2VydmljZSI6InRvcnJlbnQiLCJkZWJyaWRBcGlLZXkiOiIiLCJkZWJyaWRTdHJlYW1Qcm94eVBhc3N3b3JkIjoiIiwibGFuZ3VhZ2VzIjp7ImV4Y2x1ZGUiOltdLCJwcmVmZXJyZWQiOlsiZW4iXX0sInJlc29sdXRpb25zIjp7fSwib3B0aW9ucyI6eyJyZW1vdmVfcmFua3NfdW5kZXIiOi0xMDAwMDAwMDAwMCwiYWxsb3dfZW5nbGlzaF9pbl9sYW5ndWFnZXMiOmZhbHNlLCJyZW1vdmVfdW5rbm93bl9sYW5ndWFnZXMiOmZhbHNlfX0=';

                let cometUrl;
                if (mediaType === 'movie') {
                    cometUrl = `${API_BASE_URL}/comet/stream/movie/${imdbId}?config=${cometConfig}`;
                } else if (season && episode) {
                    cometUrl = `${API_BASE_URL}/comet/stream/series/${imdbId}:${season}:${episode}?config=${cometConfig}`;
                } else {
                    throw new Error('Season and episode required for TV shows');
                }

                console.log('[Comet] Fetching from:', cometUrl);

                const response = await fetch(cometUrl);
                if (!response.ok) throw new Error(`Comet error: ${response.statusText}`);
                
                const data = await response.json();
                const streams = data.streams || [];
                
                console.log('[Comet] Found', streams.length, 'streams');

                if (streams.length === 0) {
                    torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No Comet torrents found</div>';
                    return;
                }

                // Convert Comet streams to magnet links and display
                const torrents = streams.map(stream => {
                    const infoHash = stream.infoHash;
                    const sources = stream.sources || [];
                    const name = stream.name || 'Unknown';
                    const description = stream.description || '';
                    
                    // Use filename from behaviorHints if available, otherwise use name
                    const displayTitle = (stream.behaviorHints && stream.behaviorHints.filename) 
                        ? stream.behaviorHints.filename 
                        : name;
                    
                    // Construct magnet link compatible with WebTorrent
                    // Include display name and file index if available
                    const fileName = (stream.behaviorHints && stream.behaviorHints.filename) || displayTitle;
                    const fileIdx = stream.fileIdx !== undefined ? stream.fileIdx : 0;
                    
                    let magnetLink = `magnet:?xt=urn:btih:${infoHash}&dn=${encodeURIComponent(fileName)}`;
                    
                    // Add trackers (WebTorrent needs good trackers for peer discovery)
                    sources.forEach(tracker => {
                        magnetLink += `&tr=${encodeURIComponent(tracker)}`;
                    });
                    
                    // Store fileIdx for later use when playing specific file from torrent
                    if (fileIdx > 0) {
                        magnetLink += `&so=${fileIdx}`;
                    }
                    
                    // Extract size if available
                    let sizeBytes = 0;
                    if (stream.behaviorHints && stream.behaviorHints.videoSize) {
                        sizeBytes = stream.behaviorHints.videoSize;
                    }
                    
                    return {
                        title: displayTitle,
                        magnet: magnetLink,
                        seeders: 0, // Comet doesn't provide seeders
                        size: sizeBytes,
                        description: description
                    };
                }).filter(Boolean);

                console.log('[Comet] Converted', torrents.length, 'torrents');
                displayTorrents(torrents, season, episode);

            } catch (error) {
                console.error('[Comet] Error:', error);
                torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> Comet Error: ${error.message}</div>`;
            }
        }

        // Fetch streams from 111477 API (direct streaming links)
    async function fetch111477Streams(season = null, episode = null) {
            if (!currentContent) return;

            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching 111477...</div>';

            try {
                const tmdbId = currentContent.id;
                const mediaType = currentMediaType; // 'movie' or 'tv'

                let apiUrl;
                if (mediaType === 'movie') {
                    apiUrl = `http://localhost:3000/111477/api/tmdb/movie/${encodeURIComponent(tmdbId)}`;
                } else if (season && episode) {
                    apiUrl = `http://localhost:3000/111477/api/tmdb/tv/${encodeURIComponent(tmdbId)}/season/${encodeURIComponent(season)}/episode/${encodeURIComponent(episode)}`;
                } else {
                    throw new Error('Season and episode required for TV shows');
                }

                console.log('[111477] Fetching from:', apiUrl);

                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`111477 API error: ${response.statusText}`);
                
                const data = await response.json();
                
                // Handle multi-result format from 111477 API
                let allFiles = [];
                if (Array.isArray(data?.results)) {
                    data.results.forEach(result => {
                        if (result.success && Array.isArray(result.files)) {
                            allFiles = allFiles.concat(result.files);
                        }
                    });
                } else if (Array.isArray(data?.files)) {
                    allFiles = data.files;
                }
                
                console.log('[111477] Found', allFiles.length, 'files');

                if (allFiles.length === 0) {
                    torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No 111477 streams found</div>';
                    return;
                }

                // Helper function to extract quality from filename
                function extractQuality(filename) {
                    const qualities = ['2160p', '4K', '1080p', '720p', '480p', '360p'];
                    for (const q of qualities) {
                        if (filename.includes(q)) {
                            return q;
                        }
                    }
                    // Check for other indicators
                    if (filename.match(/BluRay|Blu-Ray/i)) return 'BluRay';
                    if (filename.match(/WEBRip|WEB-DL/i)) return 'WEB';
                    if (filename.match(/HDTV/i)) return 'HDTV';
                    return 'Unknown';
                }

                // Helper function to format file size
                function formatFileSize(bytes) {
                    if (!bytes || bytes === 0) return 'Unknown Size';
                    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(1024));
                    return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
                }

                // Process files: extract quality, format size, parse size for sorting
                const processedFiles = allFiles.map(file => {
                    const fileName = file.name || '';
                    const quality = extractQuality(fileName);
                    const sizeBytes = parseInt(file.size) || 0;
                    const sizeFormatted = formatFileSize(sizeBytes);
                    
                    return {
                        ...file,
                        quality: quality,
                        sizeFormatted: sizeFormatted,
                        sizeBytes: sizeBytes
                    };
                });

                // Cache and render with current sort selection
                window._last111477Files = processedFiles;
                render111477Files(processedFiles);

            } catch (error) {
                console.error('[111477] Error:', error);
                torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> 111477 Error: ${error.message}</div>`;
            }
        }

        // Helper: size filter matcher shared by torrent renders
        function bytesMatchesSizeFilter(bytes) {
            const n = Number(bytes) || 0;
            try {
                switch (torrentSizeFilter) {
                    case 'gte-1g': return n >= (1024 ** 3);
                    case 'gte-2g': return n >= (2 * 1024 ** 3);
                    case '2-4g':  return n >= (2 * 1024 ** 3) && n < (4 * 1024 ** 3);
                    case '4-8g':  return n >= (4 * 1024 ** 3) && n < (8 * 1024 ** 3);
                    case 'gte-8g': return n >= (8 * 1024 ** 3);
                    case 'all':
                    default: return true;
                }
            } catch(_) {
                return true;
            }
        }

        // Render helper for 111477 files honoring global sort and size filter
        function render111477Files(files) {
            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '';
            let list = (files || []).slice();
            try {
                // Use the same torrentSortMode variable defined near the selector
                const mode = (typeof torrentSortMode === 'string') ? torrentSortMode : 'seeders';
                // Apply size filter first
                list = list.filter(f => bytesMatchesSizeFilter(f.sizeBytes));
                if (mode === 'size-desc') list.sort((a,b) => (Number(b.sizeBytes||0) - Number(a.sizeBytes||0)));
                else /* size-asc or default */ list.sort((a,b) => (Number(a.sizeBytes||0) - Number(b.sizeBytes||0)));
            } catch(_) {}

            list.forEach(file => {
                const item = document.createElement('div');
                item.className = 'torrent-item';
                item.style.display = 'flex';
                item.style.justifyContent = 'space-between';
                item.style.alignItems = 'center';
                item.style.padding = '1rem';
                item.style.marginBottom = '0.5rem';
                item.style.background = 'rgba(255,255,255,0.05)';
                item.style.borderRadius = '8px';
                item.style.cursor = 'pointer';

                const info = document.createElement('div');
                info.style.flex = '1';

                const title = document.createElement('div');
                title.style.fontWeight = '500';
                title.style.marginBottom = '0.25rem';
                title.textContent = file.name || 'Unknown';

                const meta = document.createElement('div');
                meta.style.fontSize = '0.85rem';
                meta.style.opacity = '0.7';
                meta.textContent = `${file.quality}  ${file.sizeFormatted}`;

                info.appendChild(title);
                info.appendChild(meta);

                const playBtn = document.createElement('button');
                playBtn.className = 'btn';
                playBtn.innerHTML = '<i class="fas fa-play"></i> Open in MPV';
                playBtn.style.marginLeft = '1rem';
                playBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (file.url) {
                        console.log('[111477] Opening in MPV:', file.url);
                        try {
                            // Update Discord presence for 111477 MPV streaming
                            const title = currentContent?.title || currentContent?.name || 'Video';
                            const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
                            updateDiscordForStreaming(title, '111477', seasonNum);
                            
                            const result = await window.electronAPI.openMPVDirect(file.url);
                            if (result.success) {
                                showNotification('Opening stream in MPV... Please Wait', 'success', 5000);
                            } else {
                                showNotification('Failed to open in MPV: ' + (result.error || 'Unknown error'));
                            }
                        } catch (error) {
                            console.error('[111477] MPV error:', error);
                            showNotification('Failed to open in MPV: ' + error.message);
                        }
                    } else {
                        showNotification('No stream URL available');
                    }
                };

                item.appendChild(info);
                item.appendChild(playBtn);
                torrentsList.appendChild(item);
            });
        }

        // Fetch streams from MovieBox (aggregated variants)
        async function fetchMovieBoxStreams(season = null, episode = null) {
            if (!currentContent) return;

            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching MovieBox...</div>';

            try {
                const tmdbId = currentContent.id;
                const mediaType = currentMediaType; // 'movie' or 'tv'
                // Local helper to format byte sizes (kept here to avoid scope issues)
                const fmtBytes = (bytes) => {
                    const n = Number(bytes) || 0;
                    if (n <= 0) return '';
                    const units = ['Bytes','KB','MB','GB','TB'];
                    const i = Math.floor(Math.log(n) / Math.log(1024));
                    return `${(n / Math.pow(1024, i)).toFixed(2)} ${units[i]}`;
                };

                let apiUrl;
                if (mediaType === 'movie') {
                    apiUrl = `private/moviebox/${encodeURIComponent(tmdbId)}`;
                } else if (season && episode) {
                    apiUrl = `private/moviebox/tv/${encodeURIComponent(tmdbId)}/${encodeURIComponent(season)}/${encodeURIComponent(episode)}`;
                } else {
                    throw new Error('Season and episode required for TV shows');
                }

                console.log('[MovieBox] Fetching:', apiUrl);
                const response = await fetch(apiUrl, { credentials: 'include' });

                // Read body as text first, then try JSON, so we can handle non-200s with JSON or plain text
                let rawBody = '';
                let data = null;
                try {
                    rawBody = await response.text();
                    try { data = JSON.parse(rawBody); } catch (_) { /* non-JSON */ }
                } catch (_) { /* ignore */ }

                // Helper to extract cooldown seconds
                const extractWaitSeconds = (str) => {
                    if (!str || typeof str !== 'string') return null;
                    const m = str.match(/\((\d+)\s*seconds?\)/i);
                    return m ? parseInt(m[1], 10) : null;
                };

                // If response not OK, try to surface cooldown nicely before erroring
                if (!response.ok) {
                    const errStr = (data && typeof data.error === 'string' && data.error) || rawBody || response.statusText || '';
                    const secs = extractWaitSeconds(errStr);
                    if (secs) {
                        torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-hourglass-half"></i> MovieBox cooldown: Please wait ${secs} seconds and try again.</div>`;
                        return;
                    }
                    const msg = `MovieBox error: ${response.status} ${response.statusText || ''}`.trim();
                    throw new Error(msg);
                }

                // Handle MovieBox cooldown-style errors like: {"ok":false,"error":"please wait (30 seconds)"}
                if (data && data.ok === false && typeof data.error === 'string') {
                    const secs = extractWaitSeconds(data.error);
                    const waitMsg = secs ? `Please wait ${secs} seconds and try again.` : 'Please wait a bit and try again.';
                    torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-hourglass-half"></i> MovieBox cooldown: ${waitMsg}</div>`;
                    return;
                }
                let streams = [];
                if (Array.isArray(data.streams)) {
                    // Legacy shape
                    streams = data.streams;
                } else if (Array.isArray(data.results)) {
                    // New simplified shape from MovieBox proxy
                    streams = data.results.map(r => {
                        const bytes = parseInt(r.size, 10) || 0;
                        return {
                            source: r.source || 'unknown',
                            url: r.url,
                            resolutions: (r.resolutions ?? '').toString(),
                            size: fmtBytes(bytes),
                            // minimal compat fields used by UI/MPV launcher
                            format: 'MP4',
                            codecName: '',
                            headers: {}
                        };
                    });
                } else {
                    streams = [];
                }

                console.log('[MovieBox] Found', streams.length, 'streams');
                if (streams.length === 0) {
                    torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No MovieBox streams found</div>';
                    return;
                }

                // Group by source (detailPath)
                const groups = {};
                for (const s of streams) {
                    const src = s.source || 'unknown';
                    groups[src] = groups[src] || [];
                    groups[src].push(s);
                }

                displayMovieBoxGroups(groups);
            } catch (error) {
                console.error('[MovieBox] Error:', error);
                torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> MovieBox Error: ${error.message}</div>`;
            }
        }

        // Map resolution to approximate HLS bitrate (bits/sec)
        function mapResolutionToBitrate(res) {
            const n = parseInt(String(res).replace(/[^0-9]/g, ''), 10) || 0;
            if (n >= 1080) return 5000000;
            if (n >= 720) return 2500000;
            if (n >= 480) return 1200000;
            if (n >= 360) return 600000;
            return 0; // mpv will pick automatically
        }

        // Render MovieBox groups with resolution buttons
        function displayMovieBoxGroups(groups) {
            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '';

            const groupNames = Object.keys(groups);
            if (groupNames.length === 0) {
                torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No streams available</div>';
                return;
            }

            groupNames.forEach((src) => {
                const items = groups[src] || [];

                const sample = items[0]; // for display info only

                const div = document.createElement('div');
                div.className = 'torrent-item';
                div.style.cursor = 'default';
                div.innerHTML = `
                    <div class="torrent-info">
                        <div class="torrent-name">MovieBox - ${src}</div>
                        <div class="torrent-details"><span>${sample ? (sample.format || '') : ''}${sample && sample.codecName ? '  ' + sample.codecName : ''}</span></div>
                    </div>
                    <div class="torrent-actions" data-src="${encodeURIComponent(src)}"></div>
                `;
                torrentsList.appendChild(div);

                const actions = div.querySelector('.torrent-actions');

                // Create a button for EVERY stream the API returned for this source
                items.forEach((stream) => {
                    const resStr = (stream.resolutions || '').toString().trim();
                    const label = resStr ? `${resStr}${/p$/.test(resStr) ? '' : 'p'}` : (stream.format || 'Open');
                    const btn = document.createElement('button');
                    btn.className = 'torrent-btn';
                    btn.textContent = label;
                    btn.title = `${stream.format || ''}${stream.codecName ? '  ' + stream.codecName : ''}${stream.size ? '  ' + stream.size : ''}`.trim();
                    btn.addEventListener('click', () => openMovieBoxInMPV(stream, resStr || null));
                    actions.appendChild(btn);
                });
            });
        }

        async function openMovieBoxInMPV(stream, resolution = null) {
            try {
                if (!window.electronAPI || !window.electronAPI.openMpvWithHeaders) {
                    showNotification('MPV (advanced) integration not available', 'error');
                    return;
                }

                const url = stream.url;
                const headers = stream.headers || {};
                const ua = headers.userAgent || 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36';
                const ref = headers.referer || 'https://fmoviesunblocked.net/';
                const cookie = headers.cookie || '';

                const bitrate = resolution ? mapResolutionToBitrate(resolution) : 0;

                const result = await window.electronAPI.openMpvWithHeaders({
                    url,
                    userAgent: ua,
                    referer: ref,
                    cookie,
                    hlsBitrate: bitrate || undefined
                });

                if (result?.success) {
                    showNotification('Opened in MPV', 'success');
                } else {
                    showNotification(`MPV Error: ${result?.message || 'Unknown error'}`, 'error');
                }
            } catch (e) {
                console.error('[MovieBox] MPV open error:', e);
                showNotification('Failed to open in MPV', 'error');
            }
        }

        // Fetch torrents from the backend
        async function fetchTorrents(season = null, episode = null) {
            if (!currentContent) {
                try { showNotification('Select a movie/show first'); } catch(_) {}
                return;
            }

            // Track last searched parameters for provider switching
            lastSearchedSeason = season;
            lastSearchedEpisode = episode;

            // Check selected provider first
            if (selectedProvider === 'nuvio') {
                console.log('[Provider] Routing to Nuvio');
                return fetchNuvioStreams(season, episode);
            } else if (selectedProvider === 'comet') {
                console.log('[Provider] Routing to Comet');
                return fetchCometTorrents(season, episode);
            } else if (selectedProvider === '111477') {
                console.log('[Provider] Routing to 111477');
                return fetch111477Streams(season, episode);
            } else if (selectedProvider === 'moviebox') {
                console.log('[Provider] Routing to MovieBox');
                return fetchMovieBoxStreams(season, episode);
            } else if (selectedProvider === 'torrentio' || selectedProvider === 'torrentless' || selectedProvider === 'jackett') {
                // Explicit provider override buttons
                console.log('[Provider] Explicit override:', selectedProvider);
                // Bypass settings and force the desired path
                if (selectedProvider === 'jackett') {
                    // Go straight to Jackett mode below
                } else if (selectedProvider === 'torrentio') {
                    // Force torrentio branch
                    try {
                        const tmdbId = currentContent.id;
                        const mediaType = currentMediaType;
                        const externalIdsUrl = `https://api.themoviedb.org/3/${mediaType}/${tmdbId}/external_ids?api_key=${TMDB_API_KEY}`;
                        const externalIdsRes = await fetch(externalIdsUrl);
                        if (!externalIdsRes.ok) throw new Error('Failed to get IMDB ID from TMDB');
                        const externalIds = await externalIdsRes.json();
                        const imdbId = externalIds.imdb_id;
                        if (!imdbId) throw new Error('No IMDB ID found for this content');
                        let torrentioUrl;
                        if (mediaType === 'movie') {
                            torrentioUrl = `http://localhost:3000/torrentio/api/${imdbId}`;
                        } else if (season && episode) {
                            torrentioUrl = `http://localhost:3000/torrentio/api/${imdbId}/${season}/${episode}`;
                        } else {
                            throw new Error('Season and episode required for TV shows');
                        }
                        torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching Torrentio...</div>';
                        const response = await fetch(torrentioUrl);
                        if (!response.ok) throw new Error(`Torrentio error: ${response.statusText}`);
                        const data = await response.json();
                        const streams = data.streams || [];
                        const torrents = streams.map(stream => {
                            const magnetLink = stream.magnetLink || (stream.infoHash ? `magnet:?xt=urn:btih:${stream.infoHash}` : null);
                            if (!magnetLink) return null;
                            const titleMatch = (stream.title || '').match(/\s*(\d+)/);
                            const sizeMatch = (stream.title || '').match(/\s*([\d.]+\s*[KMGT]B)/i);
                            const seeders = titleMatch ? parseInt(titleMatch[1]) : 0;
                            const sizeStr = sizeMatch ? sizeMatch[1] : '0 B';
                            const sizeParts = sizeStr.match(/([\d.]+)\s*([KMGT]?B)/i);
                            let sizeBytes = 0;
                            if (sizeParts) {
                                const num = parseFloat(sizeParts[1]);
                                const unit = sizeParts[2].toUpperCase();
                                const multipliers = { 'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4 };
                                sizeBytes = Math.round(num * (multipliers[unit] || 1));
                            }
                            return { title: (stream.title || stream.name || '').split('\n')[0], magnet: magnetLink, seeders, size: sizeBytes };
                        }).filter(Boolean);
                        displayTorrents(torrents, season, episode);
                        return;
                    } catch (error) {
                        console.error('[Torrentio] Error:', error);
                        torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> Torrentio Error: ${error.message}</div>`;
                        return;
                    }
                } else if (selectedProvider === 'torrentless') {
                    // Force in-app scraper branch
                    try {
                        let query = currentContent.title || currentContent.name;
                        if (currentMediaType === 'movie') {
                            const year = (currentContent.release_date || '').substring(0, 4);
                            if (year) query = `${query} ${year}`;
                        } else if (currentMediaType === 'tv') {
                            if (season && episode) {
                                const seasonStr = String(season).padStart(2, '0');
                                const episodeStr = String(episode).padStart(2, '0');
                                query = `${query} S${seasonStr}.E${episodeStr}`;
                            } else if (season) {
                                const seasonStr = String(season).padStart(2, '0');
                                query = `${query} S${seasonStr}`;
                            }
                        }
                        const torrentlessUrl = `http://localhost:3000/torrentless/api/search?q=${encodeURIComponent(query)}&page=1`;
                        torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching Torrentless...</div>';
                        const response = await fetch(torrentlessUrl);
                        if (!response.ok) throw new Error(`In-App Scraper error: ${response.statusText}`);
                        const data = await response.json();
                        const items = data.items || [];
                        const torrents = items.map(item => {
                            const sizeStr = item.size || '0 B';
                            const sizeParts = sizeStr.match(/([\d.]+)\s*([KMGT]?B)/i);
                            let sizeBytes = 0;
                            if (sizeParts) {
                                const num = parseFloat(sizeParts[1]);
                                const unit = sizeParts[2].toUpperCase();
                                const multipliers = { 'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4 };
                                sizeBytes = Math.round(num * (multipliers[unit] || 1));
                            }
                            return { title: item.title, magnet: item.magnet, seeders: item.seeds || 0, size: sizeBytes };
                        });
                        displayTorrents(torrents, season, episode);
                        return;
                    } catch (error) {
                        console.error('[Torrentless] Error:', error);
                        torrentsList.innerHTML = `<div class=\"error-message\"><i class=\"fas fa-exclamation-triangle\"></i> In-App Scraper Error: ${error.message}</div>`;
                        return;
                    }
                }
            }

            // Playtorrio (default) - use existing torrent search logic
            console.log('[Provider] Using Playtorrio (default torrent search)');

            // Check if Watch without Jackett is enabled and which source to use
            let torrentSource = 'torrentio'; // default
            let useTorrentless = false;
            try {
                const res = await fetch(`${API_BASE_URL}/settings`);
                if (res.ok) {
                    const settings = await res.json();
                    useTorrentless = !!settings.useTorrentless;
                    torrentSource = settings.torrentSource || 'torrentio';
                    console.log('=================================');
                    console.log('[Torrents] Settings loaded:');
                    console.log('  useTorrentless:', useTorrentless);
                    console.log('  torrentSource:', torrentSource);
                    console.log('  Mode Decision:');
                    if (!useTorrentless) {
                        console.log('   Will use JACKETT (useTorrentless is false)');
                    } else if (torrentSource === 'torrentio') {
                        console.log('   Will use TORRENTIO (useTorrentless=true, source=torrentio)');
                    } else if (torrentSource === 'in-app-scraper') {
                        console.log('   Will use IN-APP SCRAPER (useTorrentless=true, source=in-app-scraper)');
                    }
                    console.log('=================================');
                }
            } catch (e) {
                console.error('[Torrents] Failed to load settings:', e);
            }

            torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching...</div>';
            torrentsLoaded = true;

            // If Watch without Jackett is enabled
            if (useTorrentless) {
                // TORRENTIO MODE: Use IMDB ID
                if (torrentSource === 'torrentio') {
                    console.log('[Torrentio] Using Torrentio API');
                    try {
                        // Get IMDB ID from TMDB
                        const tmdbId = currentContent.id;
                        const mediaType = currentMediaType; // 'movie' or 'tv'
                        
                        console.log('[Torrentio] Fetching IMDB ID for:', { tmdbId, mediaType });
                        
                        // Fetch external IDs from TMDB
                        const externalIdsUrl = `https://api.themoviedb.org/3/${mediaType}/${tmdbId}/external_ids?api_key=${TMDB_API_KEY}`;
                        console.log('[Torrentio] External IDs URL:', externalIdsUrl);
                        
                        const externalIdsRes = await fetch(externalIdsUrl);
                        if (!externalIdsRes.ok) throw new Error('Failed to get IMDB ID from TMDB');
                        
                        const externalIds = await externalIdsRes.json();
                        const imdbId = externalIds.imdb_id;
                        
                        console.log('[Torrentio] Got IMDB ID:', imdbId);
                        
                        if (!imdbId) {
                            throw new Error('No IMDB ID found for this content');
                        }

                        let torrentioUrl;
                        if (mediaType === 'movie') {
                            // Movies: http://localhost:3000/torrentio/api/tt5950044
                            torrentioUrl = `http://localhost:3000/torrentio/api/${imdbId}`;
                            console.log('[Torrentio] Movie URL:', torrentioUrl);
                        } else if (season && episode) {
                            // TV Shows: http://localhost:3000/torrentio/api/tt13159924/2/1
                            torrentioUrl = `http://localhost:3000/torrentio/api/${imdbId}/${season}/${episode}`;
                            console.log('[Torrentio] TV Show URL:', torrentioUrl);
                        } else {
                            throw new Error('Season and episode required for TV shows');
                        }

                        console.log('[Torrentio] Fetching from:', torrentioUrl);

                        const response = await fetch(torrentioUrl);
                        if (!response.ok) throw new Error(`Torrentio error: ${response.statusText}`);
                        
                        const data = await response.json();
                        console.log('[Torrentio] Received data:', data);
                        
                        const streams = data.streams || [];
                        console.log('[Torrentio] Found', streams.length, 'streams');
                        
                        // Convert Torrentio format to our torrent format
                        const torrents = streams.map(stream => {
                            // Extract magnet link (Torrentio might return magnetLink or construct it from infoHash)
                            const magnetLink = stream.magnetLink || 
                                (stream.infoHash ? `magnet:?xt=urn:btih:${stream.infoHash}` : null);
                            
                            if (!magnetLink) return null;
                            
                            // Extract seeders and size from title
                            const titleMatch = stream.title.match(/\s*(\d+)/);
                            const sizeMatch = stream.title.match(/\s*([\d.]+\s*[KMGT]B)/i);
                            const seeders = titleMatch ? parseInt(titleMatch[1]) : 0;
                            const sizeStr = sizeMatch ? sizeMatch[1] : '0 B';
                            
                            // Convert size string to bytes
                            const sizeParts = sizeStr.match(/([\d.]+)\s*([KMGT]?B)/i);
                            let sizeBytes = 0;
                            if (sizeParts) {
                                const num = parseFloat(sizeParts[1]);
                                const unit = sizeParts[2].toUpperCase();
                                const multipliers = { 'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4 };
                                sizeBytes = Math.round(num * (multipliers[unit] || 1));
                            }
                            
                            return {
                                title: stream.title.split('\n')[0] || stream.name, // First line of title
                                magnet: magnetLink,
                                seeders: seeders,
                                size: sizeBytes
                            };
                        }).filter(Boolean);
                        
                        console.log('[Torrentio] Converted', torrents.length, 'torrents');
                        displayTorrents(torrents, season, episode);
                        return;
                    } catch (error) {
                        console.error('[Torrentio] Error:', error);
                        torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> Torrentio Error: ${error.message}</div>`;
                        return;
                    }
                } 
                // IN-APP SCRAPER MODE: Use search query (same format as Jackett)
                else if (torrentSource === 'in-app-scraper') {
                    console.log('[Torrentless] Using In-App Scraper API');
                    try {
                        // Build search query - SAME FORMAT AS JACKETT
                        let query = currentContent.title || currentContent.name;
                        
                        if (currentMediaType === 'movie') {
                            const year = (currentContent.release_date || '').substring(0, 4);
                            if (year) {
                                query = `${query} ${year}`;
                            }
                        } else if (currentMediaType === 'tv') {
                            if (season && episode) {
                                const seasonStr = String(season).padStart(2, '0');
                                const episodeStr = String(episode).padStart(2, '0');
                                query = `${query} S${seasonStr}.E${episodeStr}`; // Same as Jackett format with dot
                            } else if (season) {
                                const seasonStr = String(season).padStart(2, '0');
                                query = `${query} S${seasonStr}`;
                            }
                        }
                        
                        // Use Torrentless API: http://localhost:3000/torrentless/api/search?q=Superman&page=1
                        const torrentlessUrl = `http://localhost:3000/torrentless/api/search?q=${encodeURIComponent(query)}&page=1`;
                        console.log('[Torrentless] Query:', query);
                        console.log('[Torrentless] Fetching from:', torrentlessUrl);
                        
                        const response = await fetch(torrentlessUrl);
                        if (!response.ok) throw new Error(`In-App Scraper error: ${response.statusText}`);
                        
                        const data = await response.json();
                        console.log('[Torrentless] Raw response:', data);
                        
                        // Torrentless returns { query, page, items: [...] }
                        const items = data.items || [];
                        console.log('[Torrentless] Found', items.length, 'items');
                        
                        // Convert Torrentless format to our torrent format
                        const torrents = items.map(item => {
                            // Parse size string to bytes
                            const sizeStr = item.size || '0 B';
                            const sizeParts = sizeStr.match(/([\d.]+)\s*([KMGT]?B)/i);
                            let sizeBytes = 0;
                            if (sizeParts) {
                                const num = parseFloat(sizeParts[1]);
                                const unit = sizeParts[2].toUpperCase();
                                const multipliers = { 'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4 };
                                sizeBytes = Math.round(num * (multipliers[unit] || 1));
                            }
                            
                            return {
                                title: item.title,
                                magnet: item.magnet,
                                seeders: item.seeds || 0, // Torrentless uses 'seeds' not 'seeders'
                                size: sizeBytes
                            };
                        });
                        
                        console.log('[Torrentless] Converted', torrents.length, 'torrents');
                        displayTorrents(torrents, season, episode);
                        return;
                    } catch (error) {
                        console.error('[Torrentless] Error:', error);
                        torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> In-App Scraper Error: ${error.message}</div>`;
                        return;
                    }
                }
            }

            // JACKETT MODE (default when useTorrentless is false)
            console.log('[Torrents] Using Jackett mode');
            let query = currentContent.title || currentContent.name;
            if (currentMediaType === 'movie') {
                const year = (currentContent.release_date || '').substring(0, 4);
                if (year) {
                    query = `${query} ${year}`;
                }
            } else if (currentMediaType === 'tv') {
                if (season && episode) {
                    const seasonStr = String(season).padStart(2, '0');
                    const episodeStr = String(episode).padStart(2, '0');
                    query = `${query} S${seasonStr}.E${episodeStr}`;
                } else if (season) {
                    const seasonStr = String(season).padStart(2, '0');
                    query = `${query} S${seasonStr}`;
                }
            }

            try {
                const response = await fetch(`${API_BASE_URL}/torrents?q=${encodeURIComponent(query)}`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }
                const torrents = await response.json();
                displayTorrents(torrents, season, episode);
            } catch (error) {
                console.error('[Jackett] Error fetching torrents:', error);
                torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> ${error.message}</div>`;
            }
        }

        // Helper function to check if torrent title matches specific season/episode
        function getEpisodeMatchScore(title, season, episode) {
            if (!season || !episode || !title) return 0;
            
            const titleLower = title.toLowerCase();
            const s = parseInt(season);
            const e = parseInt(episode);
            
            // Create patterns for different episode naming formats
            const patterns = [
                // S01E01 format (most common)
                new RegExp(`s0*${s}[\\s._-]*e0*${e}(?!\\d)`, 'i'),
                // S01.E01 format
                new RegExp(`s0*${s}\\.e0*${e}(?!\\d)`, 'i'),
                // 1x01 format
                new RegExp(`(?:^|\\D)${s}x0*${e}(?!\\d)`, 'i'),
                // Season 1 Episode 1 format (written out)
                new RegExp(`season[\\s._-]*0*${s}[\\s._-]*episode[\\s._-]*0*${e}(?!\\d)`, 'i'),
                // Ep1S1 or E1S1 format
                new RegExp(`e(?:p)?0*${e}s0*${s}(?!\\d)`, 'i'),
                // S1Ep1 format
                new RegExp(`s0*${s}ep0*${e}(?!\\d)`, 'i'),
                // [1-01] or (1-01) format
                new RegExp(`[\\[\\(]0*${s}[\\s._-]0*${e}[\\]\\)]`, 'i')
            ];
            
            // Check if any pattern matches
            for (let i = 0; i < patterns.length; i++) {
                if (patterns[i].test(titleLower)) {
                    // Return higher score for exact matches (based on pattern priority)
                    // First pattern (S01E01) gets highest bonus
                    return 1000 - (i * 10);
                }
            }
            
            return 0; // No match
        }

        // Display torrents
        function displayTorrents(torrents, season = null, episode = null) {
            // Compute episode match scores if TV ep context; actual sorting applied in renderTorrentsPage based on current sort mode
            if (season && episode && currentMediaType === 'tv') {
                allTorrents = (torrents || []).map(t => ({
                    ...t,
                    episodeMatchScore: getEpisodeMatchScore(t.title, season, episode)
                }));
            } else {
                allTorrents = (torrents || []).slice();
            }
            torrentsPage = 1;
            renderTorrentsPage();
        }

        function renderTorrentsPage() {
            torrentsList.innerHTML = '';
            
            console.log('[RENDER] Starting renderTorrentsPage with sort mode:', torrentSortMode);
            
            // Apply sorting according to mode (keeping episode match priority for TV episodes)
            const isTvEp = currentMediaType === 'tv' && lastSearchedSeason && lastSearchedEpisode;
            const toSort = (allTorrents || []).slice();
            
            console.log('[RENDER] Total torrents to sort:', toSort.length, 'isTvEp:', isTvEp);
            
            toSort.sort((a, b) => {
                // TV episode exact match priority (always first)
                if (isTvEp) {
                    const ea = Number(a.episodeMatchScore || 0);
                    const eb = Number(b.episodeMatchScore || 0);
                    if (eb !== ea) return eb - ea; // primary: episode match
                }
                
                // Apply selected sort mode
                const mode = (typeof torrentSortMode === 'string') ? torrentSortMode : 'seeders';
                
                if (mode === 'size-asc') {
                    const sa = Number(a.size || 0);
                    const sb = Number(b.size || 0);
                    return sa - sb; // smallest first
                } else if (mode === 'size-desc') {
                    const sa = Number(a.size || 0);
                    const sb = Number(b.size || 0);
                    return sb - sa; // largest first
                } else {
                    // default: seeders desc
                    const seeda = Number(a.seeders || 0);
                    const seedb = Number(b.seeders || 0);
                    return seedb - seeda;
                }
            });
            
            console.log('[RENDER] After sort, first 3 torrents:');
            toSort.slice(0, 3).forEach((t, i) => {
                console.log(`  ${i+1}. Size: ${((t.size||0)/1024/1024/1024).toFixed(2)}GB, Seeds: ${t.seeders}, Title: ${t.title?.substring(0, 50)}`);
            });
            
            // Apply keyword filter
            let filteredTorrents = toSort;
            const keyword = torrentKeywordFilter ? torrentKeywordFilter.value.trim().toLowerCase() : '';
            if (keyword) {
                filteredTorrents = toSort.filter(t => 
                    (t.title || '').toLowerCase().includes(keyword)
                );
            }

            // Apply size filter
            try {
                if (typeof torrentSizeFilter === 'string' && torrentSizeFilter !== 'all') {
                    filteredTorrents = filteredTorrents.filter(t => bytesMatchesSizeFilter(t.size));
                }
            } catch(_) {}
            
            if (filteredTorrents.length === 0) {
                torrentsList.innerHTML = keyword 
                    ? '<p>No torrents match your filter.</p>' 
                    : '<p>No torrents found. Try enabling <strong>Streaming Servers</strong> in the app settings for more sources.</p>';
                return;
            }

            const start = (torrentsPage - 1) * torrentsPerPage;
            const end = start + torrentsPerPage;
            const paginatedTorrents = filteredTorrents.slice(start, end);

            let rdAvailChecked = 0;
            const rdAvailBudget = 12; // cap RD availability checks per render
            paginatedTorrents.forEach(torrent => {
                const item = document.createElement('div');
                item.className = 'torrent-item';
                item.innerHTML = `
                    <div class="torrent-info">
                        <p class="torrent-name">${torrent.title}</p>
                        <div class="torrent-details">
                            <span><i class="fas fa-arrow-up"></i> ${torrent.seeders}</span>
                            <span><i class="fas fa-database"></i> ${((torrent.size || 0) / 1024 / 1024 / 1024).toFixed(2)} GB</span>
                            <span class="cached-badge" style="display:none; background:#198754; color:#fff; padding:2px 6px; border-radius:4px; font-size: 0.8rem; margin-left:8px;">Cached</span>
                        </div>
                    </div>
                    <div class="torrent-actions">
                        <button class="btn-play torrent-btn"><i class="fas fa-play"></i> Play</button>
                        <button class="btn-copy torrent-btn"><i class="fas fa-copy"></i> Copy</button>
                    </div>
                `;

                item.querySelector('.btn-play').addEventListener('click', () => startStream(torrent.magnet));
                item.querySelector('.btn-copy').addEventListener('click', () => copyMagnet(torrent.magnet));
                torrentsList.appendChild(item);

                // Debrid availability badge (RD only)
                if (useDebrid && debridAuth && debridProvider === 'realdebrid' && torrent.magnet && rdAvailChecked < rdAvailBudget) {
                    const btih = extractInfoHashFromMagnet(torrent.magnet);
                    if (btih) {
                        (async () => {
                            try {
                                const r = await fetch(`${API_BASE_URL}/debrid/availability?btih=${btih}`);
                                if (r.ok) {
                                    const j = await r.json();
                                    if (j && j.available) {
                                        const b = item.querySelector('.cached-badge');
                                        if (b) b.style.display = 'inline-block';
                                    }
                                } else {
                                    // If RD rate limits or endpoint disabled, stop further checks on this page render
                                    try {
                                        const txt = await r.text();
                                        if (/RD_RATE_LIMIT|too_many_requests/i.test(txt)) {
                                            console.warn('[UI][Debrid] availability paused due to rate limit');
                                        }
                                        if (/RD_FEATURE_UNAVAILABLE|disabled_endpoint/i.test(txt)) {
                                            console.warn('[UI][Debrid] availability disabled for this account');
                                        }
                                    } catch {}
                                }
                            } catch(_) {}
                        })();
                        rdAvailChecked++;
                    }
                }
            });

            renderTorrentPagination();
        }

        function renderTorrentPagination() {
            // Apply same keyword filter for pagination count
            let filteredTorrents = allTorrents;
            const keyword = torrentKeywordFilter ? torrentKeywordFilter.value.trim().toLowerCase() : '';
            if (keyword) {
                filteredTorrents = allTorrents.filter(t => 
                    (t.title || '').toLowerCase().includes(keyword)
                );
            }

            // Apply size filter as well for accurate page count
            try {
                if (typeof torrentSizeFilter === 'string' && torrentSizeFilter !== 'all') {
                    filteredTorrents = filteredTorrents.filter(t => bytesMatchesSizeFilter(t.size));
                }
            } catch(_) {}
            
            const totalPages = Math.ceil(filteredTorrents.length / torrentsPerPage);
            if (totalPages <= 1) {
                return;
            }

            const paginationContainer = document.createElement('div');
            paginationContainer.className = 'torrent-pagination';

            const prevBtn = document.createElement('button');
            prevBtn.innerHTML = '<i class="fas fa-arrow-left"></i>';
            prevBtn.disabled = torrentsPage === 1;
            prevBtn.addEventListener('click', () => {
                if (torrentsPage > 1) {
                    torrentsPage--;
                    renderTorrentsPage();
                }
            });

            const nextBtn = document.createElement('button');
            nextBtn.innerHTML = '<i class="fas fa-arrow-right"></i>';
            nextBtn.disabled = torrentsPage === totalPages;
            nextBtn.addEventListener('click', () => {
                if (torrentsPage < totalPages) {
                    torrentsPage++;
                    renderTorrentsPage();
                }
            });

            const pageInfo = document.createElement('span');
            pageInfo.textContent = `Page ${torrentsPage} of ${totalPages}`;

            paginationContainer.appendChild(prevBtn);
            paginationContainer.appendChild(pageInfo);
            paginationContainer.appendChild(nextBtn);

            torrentsList.appendChild(paginationContainer);
        }

        // Start streaming a torrent
        async function startStream(magnet) {
            // Refresh debrid flags before deciding path
            await ensureDebridState();
            const providerLabel = getProviderDisplayName(debridProvider);
            // If Debrid is enabled but not authenticated, block fallback and prompt login
            if (useDebrid && !debridAuth) {
                console.warn('[UI][Debrid] blocked: enabled but not logged in');
                showNotification(`${providerLabel} is enabled but you are not logged in. Please log in to continue.`);
                promptDebridLogin();
                return;
            }
            // Debrid-exclusive flow when enabled: skip WebTorrent entirely
            if (useDebrid && debridAuth && magnet && magnet.startsWith('magnet:')) {
                try {
                    // Open our player UI first
                    showPlayer();
                    mpvLoading.style.display = 'flex';
                    mpvControls.style.display = 'none';
                    fileList.innerHTML = '';
                    subtitleList.innerHTML = '';
                    subtitleControls.style.display = 'none';
                    playerTitle.textContent = `Preparing ${providerLabel}`;

                    // Add magnet to RD and select all
                    console.log('[UI][Debrid] prepare addMagnet');
                    const prep = await fetch(`${API_BASE_URL}/debrid/prepare`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ magnet })
                    });
                    if (!prep.ok) {
                        let notif = 'Debrid prepare failed';
                        try {
                            const txt = await prep.text();
                            console.error('[UI][Debrid] prepare failed', txt);
                            try {
                                const ej = JSON.parse(txt);
                                if (ej && ej.code === 'RD_PREMIUM_REQUIRED') {
                                    notif = `${providerLabel} premium is required to add torrents. Disable Debrid in Settings to use WebTorrent instead.`;
                                } else if (ej && ej.code === 'DEBRID_UNAUTH') {
                                    notif = `${providerLabel} authentication invalid. Please login again.`;
                                    if (debridStatus) debridStatus.textContent = 'Not logged in';
                                    promptDebridLogin();
                                } else if (ej && ej.code === 'TORBOX_UNIMPLEMENTED') {
                                    notif = 'TorBox is not supported yet. Please switch provider in Settings or disable Debrid to use WebTorrent.';
                                } else if (ej && ej.error) {
                                    notif = ej.error;
                                }
                            } catch { /* not json */ }
                        } catch { /* ignore */ }
                        showNotification(notif);
                        return;
                    }
                    const prepj = await prep.json();
                    const rdId = prepj.id;
                    let info = prepj.info || null;
                    if (!info || !Array.isArray(info.files) || !info.files.length) {
                        await new Promise(r => setTimeout(r, 900));
                        const fres = await fetch(`${API_BASE_URL}/debrid/files?id=${encodeURIComponent(rdId)}`);
                        if (fres.ok) info = await fres.json();
                    }

                    let files = (info && info.files) || [];
                    // If metadata/files are not ready yet, poll a few times (helps TorBox and slow RD responses)
                    if (!files.length) {
                        for (let i = 0; i < 8; i++) {
                            await new Promise(r => setTimeout(r, 1000));
                            try {
                                const rf = await fetch(`${API_BASE_URL}/debrid/files?id=${encodeURIComponent(rdId)}`);
                                if (rf.ok) {
                                    const ij = await rf.json();
                                    files = (ij && ij.files) || [];
                                    if (files.length) break;
                                }
                            } catch {}
                        }
                    }
                    // Render RD files for explicit selection, like our torrent file list
                    mpvLoading.style.display = 'none';
                    fileList.innerHTML = '';
                    playerTitle.textContent = info?.filename || providerLabel;
                    const rdVideos = files.filter(f => /\.(mp4|mkv|avi|mov)$/i.test(f.path || f.filename || ''));
                    const rdSubs = files.filter(f => /\.(srt|vtt)$/i.test(f.path || f.filename || ''));

                    const displayName = (f) => (f.path || f.filename || 'file');
                    const displaySize = (f) => ((f.bytes || f.size || 0) / 1024 / 1024).toFixed(2) + ' MB';

                    // Helper to render a small cached status badge
                    const statusBadgeHtml = (file) => {
                        const cached = Array.isArray(file.links) && file.links.length > 0;
                        const label = cached ? 'Cached' : 'Not cached';
                        const bg = cached ? 'background:#198754;' : 'background:#6c757d;';
                        return `<span class="source-badge rd-cache-badge" style="${bg} margin-left:6px;">${label}</span>`;
                    };

                    // Poll Debrid files info until the specific file has links (cached) or timeout
                    async function waitForRdLinks(id, fileId, { timeoutMs = 30000, intervalMs = 1500 } = {}) {
                        const start = Date.now();
                        while (Date.now() - start < timeoutMs) {
                            try {
                                const fres = await fetch(`${API_BASE_URL}/debrid/files?id=${encodeURIComponent(id)}`);
                                if (!fres.ok) {
                                    // If rate limited or disabled endpoint reported, stop trying
                                    try {
                                        const t = await fres.text();
                                        if (/RD_RATE_LIMIT|RD_FEATURE_UNAVAILABLE/i.test(t)) return null;
                                    } catch {}
                                    await new Promise(r => setTimeout(r, intervalMs));
                                    continue;
                                }
                                const info = await fres.json();
                                const list = Array.isArray(info?.files) ? info.files : [];
                                const found = list.find(x => String(x.id || x.file) === String(fileId));
                                if (found && Array.isArray(found.links) && found.links.length) {
                                    return found.links[0];
                                }
                            } catch {}
                            await new Promise(r => setTimeout(r, intervalMs));
                        }
                        return null; // timed out
                    }

                    rdVideos.forEach((f) => {
                        const item = document.createElement('div');
                        item.className = 'file-item';
                        item.innerHTML = `<p class="file-name">${displayName(f)} ${statusBadgeHtml(f)}</p><p class="file-size">(${displaySize(f)})</p>`;
                        item.addEventListener('click', async () => {
                            try {
                                // Set resume key and prefetch resume info for Debrid path
                                try {
                                    const fileId = String(f.id || f.file || f.filename || f.path || '0');
                                    resumeKey = `debrid:${debridProvider}:${rdId}:${fileId}`;
                                    resumeInfo = await fetchResume(resumeKey);
                                } catch(_) {}
                                // Ensure only this file is selected for RD to process
                                try {
                                    console.log('[UI][Debrid] select-files', { id: rdId, file: String(f.id || f.file) });
                                    await fetch(`${API_BASE_URL}/debrid/select-files`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id: rdId, files: String(f.id || f.file) }) });
                                } catch(e) { console.warn('[UI][Debrid] select-files failed', e?.message); }
                                // Find current link if already cached, else wait for caching
                                let link = Array.isArray(f.links) && f.links.length ? f.links[0] : null;
                                if (!link) {
                                    showNotification(`Not cached yet on ${providerLabel}. Waiting to cache`);
                                    // Show loading indicator while waiting
                                    mpvLoading.style.display = 'flex';
                                    const waited = await waitForRdLinks(rdId, (f.id || f.file));
                                    link = waited;
                                    // Update badge to Cached if now available
                                    if (link) {
                                        try {
                                            const badge = item.querySelector('.rd-cache-badge');
                                            if (badge) { badge.textContent = 'Cached'; badge.style.background = '#198754'; }
                                        } catch {}
                                    }
                                }
                                if (!link) {
                                    showNotification('Still not cached. Try again later or disable Debrid in Settings to use WebTorrent.');
                                    mpvLoading.style.display = 'none';
                                    return;
                                }
                                // Unrestrict the resolved link
                                const unres = await fetch(`${API_BASE_URL}/debrid/link`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ link }) });
                                if (!unres.ok) {
                                    console.error('[UI][Debrid] unrestrict/stream resolve failed', await unres.text());
                                    const msg = (debridProvider === 'torbox') ? 'Failed to get stream link' : 'Failed to unrestrict';
                                    showNotification(msg);
                                    mpvLoading.style.display = 'none';
                                    return;
                                }
                                const uj = await unres.json();
                                if (!uj?.url) { console.error('[UI][Debrid] unrestrict response missing url', uj); showNotification('Invalid Debrid URL'); mpvLoading.style.display = 'none'; return; }
                                currentStreamUrl = `${API_BASE_URL}/stream/debrid?url=${encodeURIComponent(uj.url)}`;
                                const fname = baseName(f.path || f.filename || '');
                                currentSelectedVideoName = fname || displayName(f);
                                playerTitle.textContent = currentSelectedVideoName || displayName(f);
                                // Source badges -> Debrid
                                if (streamSourceBadge) { streamSourceBadge.textContent = 'Debrid'; streamSourceBadge.classList.remove('webtorrent'); streamSourceBadge.classList.add('debrid'); }
                                if (customSourceBadge) { customSourceBadge.textContent = 'Debrid'; customSourceBadge.classList.remove('webtorrent'); customSourceBadge.classList.add('debrid'); }
                                mpvControls.style.display = 'flex';
                                mpvLoading.style.display = 'none';
                                showNotification(`Ready via ${providerLabel}`);

                                // Auto-attach subtitle: prefer same folder subtitle
                                const sub = rdSubs[0];
                                if (sub && Array.isArray(sub.links) && sub.links.length) {
                                    try {
                                        const su = await fetch(`${API_BASE_URL}/debrid/link`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ link: sub.links[0] }) });
                                        if (su.ok) {
                                            const suj = await su.json();
                                            if (suj?.url) {
                                                const dl = await fetch(`${API_BASE_URL}/subtitles/download-direct`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url: suj.url, preferredName: displayName(sub) }) });
                                                const dlj = await dl.json();
                                                if (dl.ok && dlj.url) currentSubtitleUrl = dlj.url;
                                            }
                                        } else { console.warn('[UI][Debrid] sub unrestrict failed', await su.text()); }
                                    } catch(e) { console.warn('[UI][Debrid] sub attach failed', e?.message); }
                                }
                            } catch (_) {
                                console.error('[UI][Debrid] file play failed');
                                showNotification('Failed to prepare Debrid file');
                            }
                        });
                        fileList.appendChild(item);
                    });

                    // Subtitle sidebar for visibility
                    if (rdSubs.length) {
                        subtitleControls.style.display = 'flex';
                        subtitleList.innerHTML = '';
                        subtitleList.classList.add('subtitle-list');
                        currentSubtitles = rdSubs.map(s => ({ name: displayName(s), index: -1 }));
                        rdSubs.forEach((s) => {
                            const subItem = document.createElement('div');
                            subItem.className = 'subtitle-item';
                            const langDiv = document.createElement('div');
                            langDiv.className = 'subtitle-lang';
                            langDiv.textContent = displayName(s);
                            subItem.appendChild(langDiv);
                            subItem.addEventListener('click', async () => {
                                try {
                                    const l = Array.isArray(s.links) && s.links.length ? s.links[0] : null;
                                    if (!l) return;
                                    const su = await fetch(`${API_BASE_URL}/debrid/link`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ link: l }) });
                                    if (!su.ok) { console.warn('[UI][Debrid] sub unrestrict failed', await su.text()); return; }
                                    const suj = await su.json();
                                    if (!suj?.url) return;
                                    const dl = await fetch(`${API_BASE_URL}/subtitles/download-direct`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url: suj.url, preferredName: displayName(s) }) });
                                    const dlj = await dl.json();
                                    if (dl.ok && dlj.url) {
                                        currentSubtitleUrl = dlj.url;
                                        showNotification('Subtitle ready');
                                    }
                                } catch(e) { console.warn('[UI][Debrid] sub attach failed', e?.message); }
                            });
                            subtitleList.appendChild(subItem);
                        });
                    }
                    return; // Debrid path handled fully
                } catch (e) {
                    console.error('[UI][Debrid] flow failed', e?.message);
                    showNotification('Debrid path failed');
                    return;
                }
            }

            // Fallback only if Debrid is not enabled
            showPlayer();
            mpvLoading.style.display = 'flex';
            mpvControls.style.display = 'none';
            fileList.innerHTML = '';
            subtitleList.innerHTML = '';
            subtitleControls.style.display = 'none';
            playerTitle.textContent = 'Loading torrent info...';
            mpvLoading.style.display = 'flex';
            mpvControls.style.display = 'none';
            fileList.innerHTML = '';
            subtitleList.innerHTML = '';
            subtitleControls.style.display = 'none';
            playerTitle.textContent = 'Loading torrent info...';

            try {
                const response = await fetch(`${API_BASE_URL}/torrent-files?magnet=${encodeURIComponent(magnet)}`);
                const data = await response.json();
                currentTorrentData = data;
                playerTitle.textContent = data.name || 'Selected Torrent'; // Update title with torrent name
                displayFiles(data.videoFiles || [], data.subtitleFiles || []);
                // Set source badges to WebTorrent for this path
                if (streamSourceBadge) { streamSourceBadge.textContent = 'WebTorrent'; streamSourceBadge.classList.remove('debrid'); streamSourceBadge.classList.add('webtorrent'); }
                if (customSourceBadge) { customSourceBadge.textContent = 'WebTorrent'; customSourceBadge.classList.remove('debrid'); customSourceBadge.classList.add('webtorrent'); }
            } catch (error) {
                console.error('Error getting torrent files:', error);
                
            }
        }

        function promptDebridLogin() {
            try {
                showSettingsModal().then(() => {
                    setTimeout(() => {
                        try {
                            const sec = document.getElementById('debridSection');
                            if (sec && typeof sec.scrollIntoView === 'function') {
                                sec.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                            // Focus appropriate control by provider
                            if (debridProvider === 'alldebrid') {
                                if (adSection) adSection.style.display = '';
                                if (adStartPinBtn) adStartPinBtn.focus();
                            } else {
                                const input = document.getElementById('rdClientId');
                                if (input) input.focus();
                            }
                        } catch(_) {}
                    }, 50);
                });
            } catch(_) {
                // As a fallback, open settings without smooth behaviors
                showSettingsModal();
            }
        }

        // Helpers: parse BTIH from magnet and pick best file from RD
        function extractInfoHashFromMagnet(magnet) {
            try {
                const m = /btih:([A-Za-z0-9]{32,40})/i.exec(magnet);
                return m ? encodeURIComponent(m[1].toUpperCase()) : '';
            } catch { return ''; }
        }
        function pickBestVideoFile(files) {
            try {
                const vids = (files || []).filter(f => /\.(mp4|mkv|avi|mov)$/i.test(f.path || f.filename || ''));
                if (!vids.length) return null;
                vids.sort((a,b) => (b.bytes || b.size || 0) - (a.bytes || a.size || 0));
                return vids[0];
            } catch { return null; }
        }

        // Display files for selection
        function displayFiles(videos, subtitles) {
            mpvLoading.style.display = 'none';
            fileList.innerHTML = '';

            // Sort videos by season and episode
            videos.sort((a, b) => {
                const regex = /(S|s)(\d+)(E|e)(\d+)|(\d+)x(\d+)|(\d+)-(\d+)/;

                const aMatch = a.name.match(regex);
                const bMatch = b.name.match(regex);

                if (aMatch && bMatch) {
                    const aSeason = parseInt(aMatch[2] || aMatch[5] || aMatch[7], 10);
                    const aEpisode = parseInt(aMatch[4] || aMatch[6] || aMatch[8], 10);
                    const bSeason = parseInt(bMatch[2] || bMatch[5] || bMatch[7], 10);
                    const bEpisode = parseInt(bMatch[4] || bMatch[6] || bMatch[8], 10);

                    if (aSeason !== bSeason) {
                        return aSeason - bSeason;
                    }
                    return aEpisode - bEpisode;
                }
                // If no match, sort alphabetically
                return a.name.localeCompare(b.name);
            });

            videos.forEach(file => {
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `
                    <p class="file-name">${file.name}</p>
                    <p class="file-size">(${(file.size / 1024 / 1024).toFixed(2)} MB)</p>
                `;

                let hoverTimer;
                item.addEventListener('mouseenter', () => {
                    hoverTimer = setTimeout(() => {
                        const tooltip = document.createElement('div');
                        tooltip.className = 'file-name-tooltip';
                        tooltip.textContent = file.name;
                        item.appendChild(tooltip);
                    }, 3000);
                });

                item.addEventListener('mouseleave', () => {
                    clearTimeout(hoverTimer);
                    const tooltip = item.querySelector('.file-name-tooltip');
                    if (tooltip) {
                        tooltip.remove();
                    }
                });

                item.addEventListener('click', async () => {
                    currentStreamUrl = `${API_BASE_URL}/stream-file?hash=${currentTorrentData.infoHash}&file=${file.index}`;
                    currentSelectedVideoName = baseName(file.name);
                    playerTitle.textContent = currentSelectedVideoName;
                    // Compute resume key and prefetch resume info for WebTorrent
                    try {
                        resumeKey = `webtorrent:${currentTorrentData.infoHash}:${file.index}`;
                        resumeInfo = await fetchResume(resumeKey);
                    } catch(_) {}
                    mpvControls.style.display = 'flex';
                    // Ask backend to begin downloading the selected file and subtitles, but don't start playback yet
                    try {
                        await fetch(`${API_BASE_URL}/prepare-file?hash=${currentTorrentData.infoHash}&file=${file.index}`);
                    } catch (_) {}
                    showNotification(`Selected: ${currentSelectedVideoName}. Click Play Now or Open in MPV to start.`);
                });
                fileList.appendChild(item);
            });

            if (subtitles.length > 0) {
                subtitleControls.style.display = 'flex';
                subtitleList.innerHTML = '';
                subtitleList.classList.add('subtitle-list');
                currentSubtitles = subtitles;
                subtitles.forEach(sub => {
                    const subItem = document.createElement('div');
                    subItem.className = 'subtitle-item';
                    
                    const langDiv = document.createElement('div');
                    langDiv.className = 'subtitle-lang';
                    langDiv.textContent = sub.name;
                    subItem.appendChild(langDiv);

                    subItem.addEventListener('click', async () => {
                        document.querySelectorAll('.subtitle-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        subItem.classList.add('selected');

                        currentSubtitleUrl = `${API_BASE_URL}/subtitle-file?hash=${currentTorrentData.infoHash}&file=${sub.index}`;
                        showNotification(`Selected subtitle: ${sub.name}`);
                    });
                    subtitleList.appendChild(subItem);
                });
            }
        }

        // Show the MPV player
        function showPlayer() {
            mpvPlayerContainer.classList.add('active');
        }

        // Close the MPV player
        async function closePlayer(showNotif = true) {
            mpvPlayerContainer.classList.remove('active');
            if (currentTorrentData) {
                try {
                    await fetch(`${API_BASE_URL}/stop-stream?hash=${currentTorrentData.infoHash}`);
                } catch (e) {}
                if (window.electronAPI && showNotif) {
                    try {
                        const result = await window.electronAPI.clearWebtorrentTemp();
                        if (result.success) {
                            showNotification('Player closed and temp files cleared.');
                        } else {
                            showNotification(`Error clearing temp files: ${result.message}`);
                        }
                    } catch (e) {}
                } else if (window.electronAPI) {
                    // Still clear cache, just don't show notification
                    try {
                        await window.electronAPI.clearWebtorrentTemp();
                    } catch (e) {}
                }
            }
            // Cleanup RD auto-downloaded subtitle if present
            try { if (currentSubtitleFile) await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) }); } catch {}
        }

        // Open stream in MPV
        async function openInMPV() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            if (!window.electronAPI || !window.electronAPI.openInMPV) {
                showNotification('MPV integration not available in this environment');
                return;
            }
            
            // Update Discord presence for MPV streaming
            // Always use TMDB title, not torrent filename
            const title = currentContent?.title || currentContent?.name || 'Video';
            
            // Determine provider based on selectedProvider setting
            let provider;
            if (selectedProvider === 'jackett') {
                provider = 'Jackett';
            } else if (selectedProvider === 'nuvio') {
                provider = 'Nuvio';
            } else if (selectedProvider === 'comet') {
                provider = 'Comet';
            } else if (selectedProvider === '111477') {
                provider = '111477';
            } else if (selectedProvider === 'moviebox') {
                provider = 'MovieBox';
            } else if (selectedProvider === 'torrentless') {
                provider = 'PlayTorrio';
            } else {
                provider = 'App Sources';  // Default fallback
            }
            
            // For TV shows, pass the season number
            const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
            updateDiscordForStreaming(title, provider, seasonNum);
            
            const data = {
                streamUrl: currentStreamUrl,
                infoHash: (currentTorrentData && currentTorrentData.infoHash) ? currentTorrentData.infoHash : null,
                startSeconds: (resumeInfo && typeof resumeInfo.position === 'number' && resumeInfo.position > 10) ? Math.floor(resumeInfo.position) : undefined
            };
            const result = await window.electronAPI.openInMPV(data);
            if (result.success) {
                showNotification('MPV launched - Please Wait! Watch out for a new window', 'success', 5000);
            } else {
                showNotification(`Error: ${result.message}`);
            }
        }

        // Open stream in VLC (same data shape as MPV)
        async function openInVLC() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            if (!window.electronAPI || !window.electronAPI.openInVLC) {
                showNotification('VLC integration not available in this environment');
                return;
            }

            const title = currentContent?.title || currentContent?.name || 'Video';
            let provider;
            if (selectedProvider === 'jackett') provider = 'Jackett';
            else if (selectedProvider === 'nuvio') provider = 'Nuvio';
            else if (selectedProvider === 'comet') provider = 'Comet';
            else if (selectedProvider === '111477') provider = '111477';
            else if (selectedProvider === 'moviebox') provider = 'MovieBox';
            else if (selectedProvider === 'torrentless') provider = 'PlayTorrio';
            else provider = 'App Sources';

            const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
            updateDiscordForStreaming(title, provider, seasonNum);

            const data = {
                streamUrl: currentStreamUrl,
                infoHash: (currentTorrentData && currentTorrentData.infoHash) ? currentTorrentData.infoHash : null,
                startSeconds: (resumeInfo && typeof resumeInfo.position === 'number' && resumeInfo.position > 10) ? Math.floor(resumeInfo.position) : undefined
            };
            const result = await window.electronAPI.openInVLC(data);
            if (result.success) {
                showNotification('VLC launched - Please Wait! Watch out for a new window', 'success', 5000);
            } else {
                showNotification(`Error: ${result.message}`);
            }
        }

        // Copy stream URL to clipboard
        function copyStreamUrl() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            navigator.clipboard.writeText(currentStreamUrl).then(() => {
                showNotification('Stream URL copied to clipboard');
            });
        }

        // Download subtitles
        function downloadSubtitles() {
            if (!currentSubtitleUrl) {
                showNotification('No subtitle selected');
                return;
            }
            window.open(currentSubtitleUrl);
        }

        // Copy magnet link to clipboard
        function copyMagnet(magnet) {
            navigator.clipboard.writeText(magnet).then(() => {
                showNotification('Magnet link copied to clipboard');
            });
        }

        // Show notification with optional duration and type
        function showNotification(message, type = 'info', duration = 5000) {
            // Clear any existing notification classes
            notification.className = 'notification';
            
            // Add the type class for styling
            if (type) {
                notification.classList.add(type);
            }
            
            // Set the message (text content to avoid HTML injection)
            notification.textContent = message;
            notification.classList.add('show');
            
            // Clear any existing timeout
            if (window.notificationTimeout) {
                clearTimeout(window.notificationTimeout);
            }
            
            // Auto-hide notification after duration
            window.notificationTimeout = setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
            
            // Log notification for debugging
            console.log(`[NOTIFICATION] ${type.toUpperCase()}: ${message}`);
        }

        // Persistent update notification that stays until user restarts
        let persistentUpdateNotification = null;
        let persistentDownloadNotification = null;
        
        function showPersistentUpdateNotification() {
            // Remove any existing persistent notification
            hideUpdateNotification();
            
            // Create persistent notification element
            persistentUpdateNotification = document.createElement('div');
            persistentUpdateNotification.id = 'persistentUpdateNotification';
            persistentUpdateNotification.innerHTML = `
                <div style="
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
                    color: white;
                    padding: 16px 20px;
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(34, 197, 94, 0.3);
                    z-index: 10000;
                    font-weight: 600;
                    font-size: 14px;
                    max-width: 320px;
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    animation: slideInRight 0.4s ease-out;
                ">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <i class="fas fa-rocket" style="font-size: 18px; color: #dcfce7;"></i>
                        <div>
                            <div style="font-size: 15px; margin-bottom: 4px;"> Update Ready!</div>
                            <div style="font-size: 13px; opacity: 0.9;">Restart the app to complete the update</div>
                        </div>
                        <button onclick="restartForUpdate()" style="
                            background: rgba(255, 255, 255, 0.2);
                            border: 1px solid rgba(255, 255, 255, 0.3);
                            color: white;
                            padding: 8px 12px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 12px;
                            font-weight: 600;
                            transition: all 0.2s ease;
                        " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                            Restart
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(persistentUpdateNotification);
            
            // Also show a regular notification
            showNotification(' Update ready! Restart to complete installation.', 'success', 6000);
        }
        
        function hideUpdateNotification() {
            if (persistentUpdateNotification) {
                persistentUpdateNotification.remove();
                persistentUpdateNotification = null;
            }
            if (persistentDownloadNotification) {
                persistentDownloadNotification.remove();
                persistentDownloadNotification = null;
            }
        }
        
        function restartForUpdate() {
            hideUpdateNotification();
            // Trigger restart via the existing restart button in the overlay
            document.getElementById('updateRestartBtn')?.click();
        }

        // Persistent downloading notification (sticks during download)
        function showPersistentDownloadNotification(percent = 0) {
            // Remove old download notification if any
            if (persistentDownloadNotification) {
                try { persistentDownloadNotification.remove(); } catch(_) {}
                persistentDownloadNotification = null;
            }
            persistentDownloadNotification = document.createElement('div');
            persistentDownloadNotification.id = 'persistentDownloadNotification';
            persistentDownloadNotification.innerHTML = `
                <div style="
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
                    color: white;
                    padding: 16px 20px;
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(124, 58, 237, 0.35);
                    z-index: 10000;
                    font-weight: 600;
                    font-size: 14px;
                    max-width: 340px;
                    min-width: 280px;
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255, 255, 255, 0.12);
                    animation: slideInRight 0.4s ease-out;
                ">
                    <div style="display:flex; align-items:center; gap:12px;">
                        <i class="fas fa-download" style="font-size:18px; color:#ede9fe;"></i>
                        <div style="flex:1;">
                            <div style="font-size:15px; margin-bottom:6px;">Downloading update...</div>
                            <div id="dlNotifText" style="font-size:13px; opacity:0.95;">${percent}% complete</div>
                            <div style="margin-top:10px; height:6px; background:rgba(255,255,255,0.2); border-radius:6px; overflow:hidden;">
                                <div id="dlNotifBar" style="height:100%; width:${percent}%; background:#c4b5fd; transition:width .2s ease;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(persistentDownloadNotification);
        }

        function updatePersistentDownloadNotification(percent = 0) {
            if (!persistentDownloadNotification) return;
            const text = persistentDownloadNotification.querySelector('#dlNotifText');
            const bar = persistentDownloadNotification.querySelector('#dlNotifBar');
            if (text) text.textContent = `${percent}% complete`;
            if (bar) bar.style.width = `${percent}%`;
        }

        // --- Custom Player Logic ---

        function openCustomPlayer() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            
            // Update Discord presence for streaming
            const tmdbTitle = currentContent?.title || currentContent?.name || 'Unknown';
            
            // Determine provider based on selectedProvider setting
            let provider;
            if (selectedProvider === 'jackett') {
                provider = 'Jackett';
            } else if (selectedProvider === 'nuvio') {
                provider = 'Nuvio';
            } else if (selectedProvider === 'comet') {
                provider = 'Comet';
            } else if (selectedProvider === '111477') {
                provider = '111477';
            } else if (selectedProvider === 'torrentless') {
                provider = 'PlayTorrio';
            } else {
                provider = 'App Sources';
            }
            
            // For TV shows, pass the season number
            const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
            updateDiscordForStreaming(tmdbTitle, provider, seasonNum);
            
            customPlayerContainer.classList.add('active');
            customPlayerContainer.style.display = 'flex'; // Ensure it's visible
            
            // Check if this is an HLS stream (.m3u8) and use HLS.js if needed
            if (currentStreamUrl.includes('.m3u8') && typeof Hls !== 'undefined' && Hls.isSupported()) {
                // Destroy existing HLS instance if any
                if (window.hls) {
                    window.hls.destroy();
                }
                
                // Create new HLS instance
                window.hls = new Hls({
                    enableWorker: false,
                    lowLatencyMode: false,
                    backBufferLength: 90
                });
                
                window.hls.loadSource(currentStreamUrl);
                window.hls.attachMedia(customVideo);
                
                window.hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('[HLS] Manifest parsed, ready to play');
                });
                
                window.hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('[HLS] Error:', data);
                    if (data.fatal) {
                        if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                            console.log('[HLS] Network error, trying to recover...');
                            window.hls.startLoad();
                        } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                            console.log('[HLS] Media error, trying to recover...');
                            window.hls.recoverMediaError();
                        }
                    }
                });
            } else {
                // Ensure any previous HLS instance is destroyed
                if (window.hls) {
                    window.hls.destroy();
                    window.hls = null;
                }
                
                if (customVideo.canPlayType('application/vnd.apple.mpegurl') && currentStreamUrl.includes('.m3u8')) {
                    // Native HLS support (Safari)
                    const savedTracks = preserveSubtitleTracks();
                    videoSource.setAttribute('src', currentStreamUrl);
                    customVideo.load();
                    customVideo.addEventListener('loadedmetadata', () => restoreSubtitleTracks(savedTracks), { once: true });
                } else {
                    // Regular video file
                    const savedTracks = preserveSubtitleTracks();
                    videoSource.setAttribute('src', currentStreamUrl);
                    customVideo.load();
                    customVideo.addEventListener('loadedmetadata', () => restoreSubtitleTracks(savedTracks), { once: true });
                }
            }
            
            customPlayerTitle.textContent = playerTitle.textContent;
            // If resume is available, seek after metadata loaded
            if (resumeInfo && typeof resumeInfo.position === 'number' && resumeInfo.position > 10) {
                const to = Math.floor(resumeInfo.position);
                customVideo.addEventListener('loadedmetadata', () => { try { customVideo.currentTime = Math.min(to, (customVideo.duration || to + 1) - 1); } catch(_) {} }, { once: true });
                showNotification(`Resuming from ${formatTime(to)}`);
            }
            // Always start recording progress as soon as playback produces timeupdates
            try {
                const onFirst = () => { try { saveResumeThrottled(true); } catch(_) {} customVideo.removeEventListener('timeupdate', onFirst); };
                customVideo.addEventListener('timeupdate', onFirst);
            } catch(_) {}
            // If we prefetched a RD subtitle, attach it now
            if (currentSubtitleUrl) {
                try { loadSubtitle(currentSubtitleUrl, { label: 'Auto', lang: 'en' }); } catch(_) {}
            }

            // Reset subtitles
            if (subtitleTrack) {
                subtitleTrack.mode = 'hidden';
            }
            subtitleDisplay.style.display = 'none';
            htmlSubsPanel.style.display = 'none';
            try {
                customVideo.muted = false;
                const vol = Number(htmlVolume?.value || 80);
                customVideo.volume = Math.max(0, Math.min(1, vol / 100));
                htmlMuteBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
            } catch(_) {}

            // Show controls initially
            videoContainer.classList.add('show-controls');
            customPlayerContainer.classList.add('show-controls');
            resetControlsAutoHide();

            // If streaming via RD proxy, add a one-time retry to re-unrestrict on error
            try {
                const u = new URL(videoSource.getAttribute('src'), window.location.origin);
                if (u.pathname.startsWith('/stream/debrid')) {
                    const origDirect = u.searchParams.get('url');
                    let retried = false;
                    customVideo.addEventListener('error', async () => {
                        if (retried) return;
                        retried = true;
                        try {
                            const base = new URL(origDirect);
                            const baseLink = `${base.origin}${base.pathname}`;
                            const rr = await fetch(`${API_BASE_URL}/debrid/link`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ link: baseLink }) });
                            if (rr.ok) {
                                const rj = await rr.json();
                                if (rj?.url) {
                                    const proxied = `${API_BASE_URL}/stream/debrid?url=${encodeURIComponent(rj.url)}`;
                                    const savedTracks = preserveSubtitleTracks();
                                    videoSource.setAttribute('src', proxied);
                                    customVideo.load();
                                    customVideo.addEventListener('loadedmetadata', () => restoreSubtitleTracks(savedTracks), { once: true });
                                    await customVideo.play();
                                }
                            }
                        } catch(_) {}
                    }, { once: false });
                }
            } catch(_) {}
        }

        // Auto-hide controls when idle in custom player
        let controlsHideTimer = null;
        const CONTROLS_HIDE_DELAY = 1500; // ms
        const videoContainer = document.getElementById('videoContainer');

        function showControls() {
            videoContainer.classList.add('show-controls');
            customPlayerContainer.classList.add('show-controls');
        }

        function hideControls() {
            // Do not hide if subtitles panel is open
            if (htmlSubsPanel && htmlSubsPanel.style.display === 'block') return;
            videoContainer.classList.remove('show-controls');
            customPlayerContainer.classList.remove('show-controls');
        }

        function clearControlsTimer() { if (controlsHideTimer) { clearTimeout(controlsHideTimer); controlsHideTimer = null; } }

        function resetControlsAutoHide() {
            clearControlsTimer();
            showControls();
            controlsHideTimer = setTimeout(hideControls, CONTROLS_HIDE_DELAY);
        }

        // Reveal/hide on mouse activity inside video container
        videoContainer.addEventListener('mousemove', resetControlsAutoHide);
        videoContainer.addEventListener('mouseenter', resetControlsAutoHide);
        videoContainer.addEventListener('mouseleave', hideControls);
        // Keep visible while interacting with the controls bar
        videoControls.addEventListener('mouseenter', () => { clearControlsTimer(); showControls(); });
        videoControls.addEventListener('mousemove', () => { clearControlsTimer(); showControls(); });
        videoControls.addEventListener('mouseleave', resetControlsAutoHide);

        // Prevent header from flickering when mouse is over it
        const customPlayerHeader = customPlayerContainer.querySelector('.player-header');
        if (customPlayerHeader) {
            customPlayerHeader.addEventListener('mouseenter', () => { 
                clearControlsTimer(); 
                showControls(); 
            });
            customPlayerHeader.addEventListener('mousemove', () => { 
                clearControlsTimer(); 
                showControls(); 
            });
            customPlayerHeader.addEventListener('mouseleave', resetControlsAutoHide);
        }

        // When opening and closing the subtitles panel, force controls visibility appropriately
        if (htmlSubsBtn) {
            htmlSubsBtn.addEventListener('click', () => {
                // After toggling, ensure state is correct
                setTimeout(() => {
                    if (htmlSubsPanel.style.display === 'block') {
                        clearControlsTimer();
                        showControls();
                    } else {
                        resetControlsAutoHide();
                    }
                }, 0);
            });
        }
        if (htmlSubsClose) {
            htmlSubsClose.addEventListener('click', () => {
                resetControlsAutoHide();
            });
        }

        // ---- WCJS Player Logic ----
        let wcjsPlayer = null;
        let wcjsTimer = null;
        function openWCJSPlayer() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            try {
                const wc = window.electronAPI?.wcjs;
                if (!wc || !wc.available) {
                    openCustomPlayer();
                    return;
                }
                // Show container
                wcjsPlayerContainer.style.opacity = '1';
                wcjsPlayerContainer.style.pointerEvents = 'all';
                wcjsLoading.style.display = 'flex';
                wcjsPlayerTitle.textContent = playerTitle.textContent || 'WebChimera Player';

                // Init player and bind to canvas
                const ctx = wc.init('#wcjsCanvas', ["--no-video-title-show"]);
                if (!ctx || !ctx.player) {
                    showNotification('WebChimera failed to initialize, falling back to built-in player.');
                    closeWCJSPlayer();
                    openCustomPlayer();
                    return;
                }
                wcjsPlayer = ctx.player;
                // Start playback
                wcjsPlayer.play(currentStreamUrl);
                // Load pre-downloaded subtitle if available (from RD auto fetch)
                try {
                    if (currentSubtitleUrl && wcjsPlayer && wcjsPlayer.subtitles && wcjsPlayer.subtitles.load) {
                        wcjsPlayer.subtitles.load(currentSubtitleUrl);
                    }
                } catch(_) {}

                // Setup events and UI updates
                wcjsAttachEvents();
            } catch (e) {
                console.error('WCJS init error:', e);
                showNotification('WebChimera init error, using built-in player.');
                closeWCJSPlayer();
                openCustomPlayer();
            }
        }

        function wcjsAttachEvents() {
            if (!wcjsPlayer) return;
            // Length/time change handlers if available
            try { wcjsPlayer.onLengthChanged = (len) => { wcjsTotalTime.textContent = formatTime((len||0)/1000); }; } catch(_){}
            try { wcjsPlayer.onPlaying = () => { wcjsLoading.style.display = 'none'; wcjsPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>'; }; } catch(_){}
            try { wcjsPlayer.onPaused = () => { wcjsPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>'; }; } catch(_){}
            try { wcjsPlayer.onEndReached = () => { wcjsPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>'; }; } catch(_){}

            // Poll time/length as a reliable way across versions
            clearInterval(wcjsTimer);
            wcjsTimer = setInterval(() => {
                if (!wcjsPlayer) return;
                let len = 0, t = 0;
                try { len = Number(wcjsPlayer.length || wcjsPlayer.input?.length || 0); } catch(_){}
                try { t = Number(wcjsPlayer.time || wcjsPlayer.input?.time || 0); } catch(_){}
                if (len > 0) wcjsTotalTime.textContent = formatTime(len/1000);
                wcjsCurrentTime.textContent = formatTime(t/1000);
                if (len > 0) {
                    const pct = Math.max(0, Math.min(100, (t/len) * 100));
                    wcjsProgressFilled.style.width = pct + '%';
                }
            }, 200);
            // Refresh audio list on play
            setTimeout(renderAudioTracks, 400);
        }

        async function closeWCJSPlayer() {
            wcjsPlayerContainer.style.opacity = '0';
            wcjsPlayerContainer.style.pointerEvents = 'none';
            wcjsLoading.style.display = 'none';
            clearInterval(wcjsTimer);
            wcjsTimer = null;
            
            // Exit video fullscreen if active
            if (document.fullscreenElement) {
                try {
                    await document.exitFullscreen();
                } catch(_) {}
            }
            
            // Also exit app fullscreen if the window is in fullscreen to prevent black screen
            if (window.electronAPI && window.electronAPI.getFullscreen) {
                try {
                    const result = await window.electronAPI.getFullscreen();
                    if (result.success && result.isFullscreen) {
                        // Temporarily exit app fullscreen to prevent black screen
                        await window.electronAPI.setFullscreen(false);
                        // Show notification that user can re-enable fullscreen via settings
                        setTimeout(() => {
                            showNotification('Exited fullscreen mode. Re-enable in Settings if needed.', 'info', 4000);
                        }, 500);
                    }
                } catch (error) {
                    console.error('Error handling fullscreen exit:', error);
                }
            }
            
            if (wcjsPlayer) {
                try { wcjsPlayer.stop(); } catch(_){}
                try { wcjsPlayer.close && wcjsPlayer.close(); } catch(_){}
            }
            wcjsPlayer = null;
            // Stop torrent stream on server and clean temp (same as MPV close)
            if (currentTorrentData) {
                try { await fetch(`${API_BASE_URL}/stop-stream?hash=${currentTorrentData.infoHash}`); } catch(e) {}
                if (window.electronAPI) {
                    try { await window.electronAPI.clearWebtorrentTemp(); } catch(e) {}
                }
            }
            // Cleanup downloaded temporary subtitles
            try { await fetch(`${API_BASE_URL}/subtitles/cleanup`, { method: 'POST' }); } catch(e) {}
        }

        function wcjsTogglePlayPause() {
            if (!wcjsPlayer) return;
            try { wcjsPlayer.togglePause(); } catch(_){}
        }

        function wcjsSkipTime(seconds) {
            if (!wcjsPlayer) return;
            try {
                const cur = Number(wcjsPlayer.time || 0);
                wcjsPlayer.time = Math.max(0, cur + seconds * 1000);
            } catch(_){}
        }

        function wcjsToggleFullscreen() {
            if (!document.fullscreenElement) {
                wcjsPlayerContainer.requestFullscreen?.();
            } else {
                document.exitFullscreen?.();
            }
        }

        function wcjsSeek(e) {
            if (!wcjsPlayer) return;
            const rect = wcjsProgressBar.getBoundingClientRect();
            const offsetX = e.clientX - rect.left;
            const pct = offsetX / rect.width;
            try {
                const len = Number(wcjsPlayer.length || 0);
                if (len > 0) wcjsPlayer.time = Math.floor(len * pct);
            } catch(_){}
        }

        function wcjsToggleMute() {
            if (!wcjsPlayer) return;
            try {
                if (typeof wcjsPlayer.toggleMute === 'function') wcjsPlayer.toggleMute();
                else wcjsPlayer.mute = !wcjsPlayer.mute;
                // Update icon
                const muted = !!wcjsPlayer.mute;
                wcjsMuteBtn.innerHTML = muted ? '<i class="fas fa-volume-mute"></i>' : '<i class="fas fa-volume-up"></i>';
            } catch(_){}
        }

        function wcjsSetVolume() {
            if (!wcjsPlayer) return;
            // wcjs volume is 0..200
            const v = Number(wcjsVolume.value || 0);
            try { wcjsPlayer.volume = Math.round(v * 2); } catch(_){}
        }

        async function wcjsHandleSubtitleUpload(event) {
            const file = event.target.files[0];
            if (!file || !wcjsPlayer) return;
            try {
                const text = await file.text();
                const formData = new FormData();
                formData.append('subtitle', new Blob([text]), file.name);
                const response = await fetch(`${API_BASE_URL}/upload-subtitle`, { method: 'POST', body: formData });
                const data = await response.json();
                if (!response.ok || !data?.url) {
                    showNotification(data?.error || 'Subtitle upload failed');
                    return;
                }
                try { wcjsPlayer.subtitles && wcjsPlayer.subtitles.load && wcjsPlayer.subtitles.load(data.url); } catch(_){ }
                showNotification('Subtitles loaded');
            } catch (e) {
                showNotification('Failed to load subtitles');
            } finally {
                try { event.target.value = ''; } catch {}
            }
        }

        // Fetch and display subtitles from backend
        async function fetchAndRenderSubtitles() {
            wcjsSubsList.innerHTML = '<div class="subs-help"><i class="fas fa-spinner" style="animation: spin 1s linear infinite;"></i> Loading...</div>';
            try {
                // Always prefer the selected show's TMDB id and media type
                let tmdbId = currentContent?.id;
                let type = currentMediaType === 'tv' ? 'tv' : 'movie';
                // For movies, if tmdbId is missing, derive it from the selected torrent filename
                if (type === 'movie' && (!tmdbId || tmdbId === '')) {
                    if (currentSelectedVideoName) {
                        try {
                            const derived = await getTmdbFromFilename(currentSelectedVideoName);
                            if (derived?.id) tmdbId = derived.id;
                        } catch(_) {}
                    }
                }
                const params = new URLSearchParams({ type });
                if (tmdbId) params.set('tmdbId', String(tmdbId));
                if (currentSelectedVideoName) {
                    params.set('filename', currentSelectedVideoName);
                    // Provide show title/year for better matching
                    const showTitle = currentContent?.title || currentContent?.name || '';
                    const showYear = (currentContent?.release_date || currentContent?.first_air_date || '').slice(0,4);
                    if (showTitle) params.set('title', showTitle);
                    if (showYear) params.set('year', showYear);
                } else if (type === 'tv' && currentSeason) {
                    params.set('season', String(currentSeason));
                }
                // Try to detect selected episode from episodesGrid selection
                const sel = document.querySelector('.episode-card.selected');
                if (!currentSelectedVideoName && type === 'tv' && sel) {
                    const titleEl = sel.querySelector('.episode-title');
                    const m = titleEl?.textContent?.match(/E(\d+)/i);
                    if (m) params.set('episode', String(parseInt(m[1], 10)));
                }
                const res = await fetch(`${API_BASE_URL}/subtitles?${params.toString()}`);
                const data = await res.json();
                const items = Array.isArray(data.subtitles) ? data.subtitles : [];
                // Group by language and index duplicates
                const grouped = {};
                for (const it of items) {
                    const key = `${(it.langName || it.lang || 'Unknown').toLowerCase()}|${it.source}`;
                    if (!grouped[key]) grouped[key] = [];
                    grouped[key].push(it);
                }
                wcjsSubsList.innerHTML = '';
                const entries = Object.entries(grouped);
                if (!entries.length) wcjsSubsList.innerHTML = '<div class="subs-help">No subtitles found.</div>';
                for (const [key, arr] of entries) {
                    const [langNameLower, source] = key.split('|');
                    const langDisplay = langNameLower.charAt(0).toUpperCase() + langNameLower.slice(1);
                    arr.forEach((sub, idx) => {
                        const displayName = arr.length > 1 ? `${langDisplay} ${idx + 1}` : langDisplay;
                        const row = document.createElement('div');
                        row.className = 'subs-item';
                        row.innerHTML = `<div>${displayName} <span class="subs-source">(${source})</span></div><div class="subs-badge">Select</div>`;
                        row.addEventListener('click', async () => {
                            try {
                                // Download via backend to temp, then load into WCJS
                                const payload = sub.source === 'opensubtitles'
                                    ? { source: 'opensubtitles', fileId: sub.file_id, preferredName: sub.name }
                                    : { source: 'wyzie', url: sub.url, preferredName: sub.name };
                                const dl = await fetch(`${API_BASE_URL}/subtitles/download`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                                const dlJson = await dl.json();
                                if (dl.ok && dlJson.url) {
                                    try { wcjsPlayer.subtitles && wcjsPlayer.subtitles.load && wcjsPlayer.subtitles.load(dlJson.url); } catch(_){}
                                    showNotification(`Loaded: ${displayName}`);
                                    wcjsSubsPanel.style.display = 'none';
                                } else {
                                    if (dl.status === 429 || dlJson?.code === 'OS_QUOTA') {
                                        showNotification('OpenSubtitles is rate-limited. Trying Wyzie automatically...');
                                        // Try fallback to Wyzie: prefer same language, else any Wyzie
                                        const sameLangWyzie = currentSubtitles.find(s => s.source === 'wyzie' && s.lang && s.lang === (sub.lang || '').toLowerCase());
                                        const anyWyzie = currentSubtitles.find(s => s.source === 'wyzie');
                                        const wyziePick = sameLangWyzie || anyWyzie;
                                        if (wyziePick) {
                                            try {
                                                const wyPayload = { source: 'wyzie', url: wyziePick.url, preferredName: wyziePick.name || wyziePick.langName };
                                                const wyDl = await fetch(`${API_BASE_URL}/subtitles/download`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(wyPayload) });
                                                const wyJson = await wyDl.json();
                                                if (wyDl.ok && wyJson.url) {
                                                    try { wcjsPlayer.subtitles && wcjsPlayer.subtitles.load && wcjsPlayer.subtitles.load(wyJson.url); } catch(_){}
                                                    showNotification(`Loaded from Wyzie: ${wyziePick.name || wyziePick.langName}`);
                                                    wcjsSubsPanel.style.display = 'none';
                                                } else {
                                                    showNotification(wyJson.error || 'Wyzie fallback failed. Please pick a different subtitle.');
                                                }
                                            } catch (e) {
                                                showNotification('Wyzie fallback failed. Please pick a different subtitle.');
                                            }
                                        } else {
                                            showNotification('No Wyzie subtitles available. Please try another source later.');
                                        }
                                    } else {
                                        showNotification(dlJson.error || 'Subtitle download failed');
                                    }
                                }
                            } catch (e) {
                                showNotification('Subtitle download error');
                            }
                        });
                        wcjsSubsList.appendChild(row);
                    });
                }
            } catch {
                wcjsSubsList.innerHTML = '<div class="subs-help">Failed to load subtitles.</div>';
            }
        }

        // Render audio tracks and allow switching
        function renderAudioTracks() {
            wcjsAudioList.innerHTML = '';
            if (!wcjsPlayer || !wcjsPlayer.audio) {
                wcjsAudioList.innerHTML = '<div class="subs-help">Audio track info not available.</div>';
                return;
            }
            try {
                const count = Number(wcjsPlayer.audio.count || 0);
                if (!count) {
                    wcjsAudioList.innerHTML = '<div class="subs-help">No alternate audio tracks.</div>';
                    return;
                }
                for (let i = 1; i <= count; i++) {
                    const name = wcjsPlayer.audio[i] || `Track ${i}`;
                    const row = document.createElement('div');
                    row.className = 'subs-item';
                    row.innerHTML = `<div>${name}</div><div class="subs-badge">Select</div>`;
                    row.addEventListener('click', () => {
                        try { wcjsPlayer.audio.track = i; showNotification(`Audio: ${name}`); wcjsAudioPanel.style.display = 'none'; } catch(_){}
                    });
                    wcjsAudioList.appendChild(row);
                }
            } catch {
                wcjsAudioList.innerHTML = '<div class="subs-help">Audio list unavailable.</div>';
            }
        }

        async function closeCustomPlayer_() {
            // Stop Trakt scrobbling when player closes
            if (customVideo.duration && traktCurrentScrobble) {
                const progress = customVideo.currentTime / customVideo.duration * 100;
                scrobbleStop(Math.floor(progress));
            }
            
            // Clear Discord presence when custom player closes
            if (discordStreamingActive) {
                clearDiscordPresence();
            }
            
            customPlayerContainer.classList.remove('active');
            customPlayerContainer.style.display = 'none'; // Fully hide to prevent invisible overlay
            try { customVideo.pause(); } catch(_) {}
            
            // Exit video fullscreen if active
            if (document.fullscreenElement) {
                try {
                    await document.exitFullscreen();
                } catch(_) {}
            }
            
            // Also exit app fullscreen if the window is in fullscreen to prevent black screen
            if (window.electronAPI && window.electronAPI.getFullscreen) {
                try {
                    const result = await window.electronAPI.getFullscreen();
                    if (result.success && result.isFullscreen) {
                        // Temporarily exit app fullscreen to prevent black screen
                        await window.electronAPI.setFullscreen(false);
                        // Show notification that user can re-enable fullscreen via settings
                        setTimeout(() => {
                            showNotification('Exited fullscreen mode. Re-enable in Settings if needed.', 'info', 4000);
                        }, 500);
                    }
                } catch (error) {
                    console.error('Error handling fullscreen exit:', error);
                }
            }
            
            // Cleanup HLS instance if any
            if (window.hls) {
                window.hls.destroy();
                window.hls = null;
            }
            
            // Fully reset video source to clear any residual tracks/cues
            try {
                customVideo.removeAttribute('src');
                if (videoSource) videoSource.setAttribute('src', '');
                customVideo.load();
            } catch(_) {}
            
            // Cleanup temp subtitle file for HTML5 if any
            if (currentSubtitleFile) {
                try { await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) }); } catch {}
                currentSubtitleFile = null;
            }
        }

        function togglePlayPause() {
            if (customVideo.paused) {
                customVideo.play();
            } else {
                customVideo.pause();
            }
        }

        function skipTime(amount) {
            customVideo.currentTime += amount;
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                customPlayerContainer.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        async function castToChromecast() {
            // Use the same backend casting as MPV button
            if (!currentStreamUrl) {
                showNotification('No stream available to cast', 'error');
                return;
            }
            
            // Show device picker modal (same as MPV casting)
            await showChromecastDevicePicker();
        }

        // Deprecated: Old Web SDK method (kept for reference but not used in Electron)
        function loadMediaToCast() {
            const castSession = window.cast.framework.CastContext.getInstance().getCurrentSession();
            if (!castSession) {
                showNotification('No active Chromecast session', 'error');
                return;
            }

            // Prepare media info
            const mediaInfo = new window.chrome.cast.media.MediaInfo(currentStreamUrl, 'video/mp4');
            
            // Set metadata
            const metadata = new window.chrome.cast.media.GenericMediaMetadata();
            if (currentContent) {
                metadata.title = currentContent.title || currentContent.name || 'Unknown';
                if (currentContent.poster_path) {
                    metadata.images = [new window.chrome.cast.Image(`https://image.tmdb.org/t/p/w342${currentContent.poster_path}`)];
                }
            }
            mediaInfo.metadata = metadata;

            const request = new window.chrome.cast.media.LoadRequest(mediaInfo);
            
            // Set current playback position if playing from custom player
            if (customVideo && !customVideo.paused) {
                request.currentTime = customVideo.currentTime;
                // Pause local player
                customVideo.pause();
            }

            castSession.loadMedia(request).then(
                () => {
                    showNotification('Casting to ' + castSession.getCastDevice().friendlyName, 'success');
                },
                (error) => {
                    console.error('Load media error:', error);
                    showNotification('Failed to cast media: ' + error.message, 'error');
                }
            );
        }

        async function castMPVToChromecast() {
            if (!currentStreamUrl) {
                showNotification('No stream available to cast', 'error');
                return;
            }
            
            // Show device picker modal
            await showChromecastDevicePicker();
        }

        async function showChromecastDevicePicker() {
            const modal = document.getElementById('chromecast-device-modal');
            const deviceList = document.getElementById('chromecast-device-list');
            
            if (!modal || !deviceList) {
                console.error('[Chromecast] Modal elements not found');
                showNotification('Device picker not available', 'error');
                return;
            }
            
            // Show modal with loading state
            modal.style.display = 'flex';
            modal.classList.add('active');
            modal.style.opacity = '1';
            modal.style.pointerEvents = 'all';
            
            deviceList.innerHTML = `
                <div class="loading-spinner">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Discovering Chromecast devices...</p>
                </div>
            `;
            
            try {
                // Discover devices
                const result = await window.electronAPI.discoverChromecastDevices();
                
                if (!result.success || result.devices.length === 0) {
                    deviceList.innerHTML = `
                        <div class="chromecast-no-devices">
                            <i class="fas fa-broadcast-tower"></i>
                            <h4>No Chromecast Devices Found</h4>
                            <p>Make sure your Chromecast is on the same network</p>
                            <button class="chromecast-refresh-btn" onclick="showChromecastDevicePicker()">
                                <i class="fas fa-sync"></i> Refresh
                            </button>
                        </div>
                    `;
                    return;
                }
                
                // Display devices
                deviceList.innerHTML = '';
                result.devices.forEach(device => {
                    const deviceItem = document.createElement('div');
                    deviceItem.className = 'chromecast-device-item';
                    deviceItem.innerHTML = `
                        <div class="chromecast-device-icon">
                            <i class="fas fa-tv"></i>
                        </div>
                        <div class="chromecast-device-info">
                            <div class="chromecast-device-name">${escapeHtml(device.name)}</div>
                            <div class="chromecast-device-host">${escapeHtml(device.host)}</div>
                        </div>
                    `;
                    
                    deviceItem.addEventListener('click', () => {
                        castToDevice(device);
                    });
                    
                    deviceList.appendChild(deviceItem);
                });
                
            } catch (error) {
                console.error('Device discovery error:', error);
                deviceList.innerHTML = `
                    <div class="chromecast-no-devices">
                        <i class="fas fa-exclamation-triangle"></i>
                        <h4>Discovery Failed</h4>
                        <p>${escapeHtml(error.message || 'Failed to discover devices')}</p>
                        <button class="chromecast-refresh-btn" onclick="showChromecastDevicePicker()">
                            <i class="fas fa-sync"></i> Try Again
                        </button>
                    </div>
                `;
            }
        }

        async function castToDevice(device) {
            const modal = document.getElementById('chromecast-device-modal');
            if (modal) {
                modal.style.display = 'none';
                modal.classList.remove('active');
                modal.style.opacity = '0';
                modal.style.pointerEvents = 'none';
            }
            
            try {
                // Just send the URL as-is - main.js will handle proxying through network IP
                let toCast = currentStreamUrl;
                if (!toCast) {
                    showNotification('No stream available to cast', 'error');
                    return;
                }

                // Prepare metadata for Chromecast
                const metadata = {
                    title: 'PlayTorrio Stream',
                    // Guess content type from original URL
                    contentType: (toCast.includes('.m3u8') ? 'application/vnd.apple.mpegurl' : 'video/mp4'),
                    images: []
                };
                
                // Use currentContent if available
                if (currentContent) {
                    metadata.title = currentContent.title || currentContent.name || 'PlayTorrio Stream';
                    
                    if (currentContent.poster_path) {
                        metadata.images = [{
                            url: `https://image.tmdb.org/t/p/w342${currentContent.poster_path}`
                        }];
                    }
                }
                
                console.log('[Cast] Sending stream URL to main process:', toCast);
                
                showNotification(`Connecting to ${device.name}...`, 'info');
                
                const result = await window.electronAPI.castToChromecast({
                    streamUrl: toCast,
                    metadata: metadata,
                    deviceHost: device.host
                });
                
                if (result.success) {
                    showNotification(`Casting to ${device.name}`, 'success');
                } else {
                    showNotification(result.message, 'error');
                }
            } catch (error) {
                console.error('Cast error:', error);
                showNotification('Failed to cast: ' + error.message, 'error');
            }
        }

        function updateProgress() {
            const percent = (customVideo.currentTime / customVideo.duration) * 100;
            progressFilled.style.width = `${percent}%`;
            currentTime.textContent = formatTime(customVideo.currentTime);
            saveResumeThrottled();
        }

        function updateDuration() {
            totalTime.textContent = formatTime(customVideo.duration);
            saveResumeThrottled();
        }

        function seekVideo(e) {
            const rect = progressBar.getBoundingClientRect();
            const offsetX = e.clientX - rect.left;
            const seekTime = (offsetX / progressBar.offsetWidth) * customVideo.duration;
            customVideo.currentTime = seekTime;
            saveResumeThrottled(true);
        }

        function formatTime(seconds) {
            if (!isFinite(seconds)) return '0:00';
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${String(secs).padStart(2, '0')}`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function handleSubtitleUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            try {
                const text = await file.text();
                const formData = new FormData();
                formData.append('subtitle', new Blob([text]), file.name);
                const response = await fetch(`${API_BASE_URL}/upload-subtitle`, { method: 'POST', body: formData });
                const data = await response.json();
                if (!response.ok || !data?.url) {
                    showNotification(data?.error || 'Subtitle upload failed');
                    return;
                }
                // Delete previous temp file if any
                if (currentSubtitleFile) {
                    try { await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) }); } catch {}
                }
                await loadSubtitle(data.url, { label: file.name.replace(/\.[^.]+$/, ''), lang: 'en' });
                showNotification('Subtitles loaded');
            } catch (_) {
                showNotification('Failed to load subtitles');
            } finally {
                try { event.target.value = ''; } catch {}
            }
        }

        function updateSubtitleControlDisplays() {
            if (subsSizeValue) subsSizeValue.textContent = `${subtitleSettings.size}px`;
            if (subsOpacityValue) subsOpacityValue.textContent = `${subtitleSettings.backgroundOpacity}%`;
            if (subsSizeInput) subsSizeInput.value = subtitleSettings.size;
            if (subsColorInput) subsColorInput.value = subtitleSettings.color;
            if (subsBackgroundInput) subsBackgroundInput.value = subtitleSettings.background;
            if (subsBackgroundOpacityInput) subsBackgroundOpacityInput.value = subtitleSettings.backgroundOpacity;
            if (subsFontSelect) subsFontSelect.value = subtitleSettings.font;
        }

        function applySubtitleSettings() {
            // Apply styles to Video.js subtitle display
            let styleEl = document.getElementById('subtitle-cue-style');
            if (!styleEl) {
                styleEl = document.createElement('style');
                styleEl.id = 'subtitle-cue-style';
                document.head.appendChild(styleEl);
            }
            
            // Convert hex color to rgba for background
            const hexToRgba = (hex, alpha) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            };
            
            const bgColor = hexToRgba(subtitleSettings.background, subtitleSettings.backgroundOpacity / 100);
            
            // Apply to Video.js text track display and native cues with fixed position
            styleEl.textContent = `
                .video-js .vjs-text-track-display {
                    bottom: 3em !important;
                    pointer-events: none !important;
                }
                
                .video-js .vjs-text-track-cue > div {
                    font-size: ${subtitleSettings.size}px !important;
                    color: ${subtitleSettings.color} !important;
                    background-color: ${bgColor} !important;
                    font-family: ${subtitleSettings.font} !important;
                    padding: 0.2em 0.5em !important;
                    border-radius: 4px !important;
                    pointer-events: auto !important;
                }
                
                video::cue {
                    font-size: ${subtitleSettings.size}px !important;
                    color: ${subtitleSettings.color} !important;
                    background-color: ${bgColor} !important;
                    font-family: ${subtitleSettings.font} !important;
                }
            `;
        }

        // Helper to preserve subtitle tracks across video loads
        function preserveSubtitleTracks() {
            const tracks = Array.from(customVideo.querySelectorAll('track[kind="subtitles"]'));
            return tracks.map(t => ({
                src: t.src,
                label: t.label,
                srclang: t.srclang,
                isDefault: t.default,
                mode: t.track ? t.track.mode : 'hidden'
            }));
        }

        function restoreSubtitleTracks(trackData) {
            if (!trackData || trackData.length === 0) return;
            
            trackData.forEach((data, index) => {
                const track = document.createElement('track');
                track.kind = 'subtitles';
                track.label = data.label;
                track.srclang = data.srclang;
                track.src = data.src;
                if (data.isDefault) {
                    track.default = true;
                    track.setAttribute('default', '');
                }
                customVideo.appendChild(track);
                
                // Restore the mode when track loads
                track.addEventListener('load', () => {
                    try {
                        if (track.track) {
                            track.track.mode = data.mode;
                            if (data.mode === 'showing') {
                                applySubtitleSettings();
                                subtitleTrack = track;
                            }
                        }
                    } catch {}
                }, { once: true });
            });
        }

        async function loadSubtitle(url, opts = {}) {
            // Check if this subtitle URL is already loaded
            const existingTracks = Array.from(customVideo.querySelectorAll('track[kind="subtitles"]'));
            const alreadyLoaded = existingTracks.find(t => t.src === url);
            
            if (alreadyLoaded) {
                // Just switch to the existing track
                for (const t of customVideo.textTracks) { t.mode = 'hidden'; }
                if (alreadyLoaded.track) {
                    alreadyLoaded.track.mode = 'showing';
                    applySubtitleSettings();
                }
                subtitleTrack = alreadyLoaded;
                return;
            }

            // Only remove tracks if we're loading a completely new subtitle
            // Keep the current track to avoid it disappearing
            if (subtitleTrack && subtitleTrack.src !== url) {
                // Don't remove the current track yet, just hide it
                if (subtitleTrack.track) {
                    subtitleTrack.track.mode = 'hidden';
                }
            }

            const track = document.createElement('track');
            track.kind = 'subtitles';
            track.label = opts.label || 'Subtitles';
            track.srclang = (opts.lang || 'en');
            track.src = url;
            track.default = true;
            track.setAttribute('default', '');
            customVideo.appendChild(track);
            // Wait for track to load then enable showing
            track.addEventListener('load', () => {
                try {
                    // Hide all other tracks then show current
                    for (const t of customVideo.textTracks) { t.mode = 'hidden'; }
                    if (track.track) track.track.mode = 'showing';
                    applySubtitleSettings();
                } catch {}
            });
            subtitleTrack = track;
            // Track the served filename so we can delete it when switching
            try {
                const u = new URL(url, window.location.origin);
                const parts = u.pathname.split('/');
                const fname = parts[parts.length - 1];
                currentSubtitleFile = decodeURIComponent(fname);
            } catch {}
        }

        async function fetchAndRenderHtmlSubs() {
            htmlSubsList.innerHTML = '<div class="subs-help"><i class="fas fa-spinner" style="animation: spin 1s linear infinite;"></i> Loading...</div>';
            try {
                // Always use the selected show's TMDB id and type from UI
                let tmdbId = currentContent?.id;
                let type = currentMediaType === 'tv' ? 'tv' : 'movie';
                const title = currentContent?.title || currentContent?.name || '';
                const year = (currentContent?.release_date || currentContent?.first_air_date || '').slice(0,4);
                // For movies, if tmdbId is missing, derive it from the selected torrent filename
                if (type === 'movie' && (!tmdbId || tmdbId === '')) {
                    if (currentSelectedVideoName) {
                        try {
                            const derived = await getTmdbFromFilename(currentSelectedVideoName);
                            if (derived?.id) tmdbId = derived.id;
                        } catch(_) {}
                    }
                }
                const params = new URLSearchParams({ type });
                if (tmdbId) params.set('tmdbId', String(tmdbId));
                if (title) params.set('title', title);
                if (year) params.set('year', year);
                if (currentSelectedVideoName) {
                    params.set('filename', currentSelectedVideoName);
                    // title/year already represent the selected show
                }
                if (type === 'tv' && currentSeason) params.set('season', String(currentSeason));
                const sel = document.querySelector('.episode-card.selected');
                if (!currentSelectedVideoName && type === 'tv' && sel) {
                    const titleEl = sel.querySelector('.episode-title');
                    const m = titleEl?.textContent?.match(/E(\d+)/i);
                    if (m) params.set('episode', String(parseInt(m[1], 10)));
                }
                const res = await fetch(`${API_BASE_URL}/subtitles?${params.toString()}`);
                const data = await res.json();
                let items = Array.isArray(data.subtitles) ? data.subtitles : [];
                // Extra safety: filter client-side for supported formats only
                items = items.filter(it => {
                    const ext = (it.ext || it.format || '').toString().toLowerCase();
                    const u = (it.url || '').toString().toLowerCase();
                    return ['srt','vtt'].includes(ext) || u.includes('.srt') || u.includes('.vtt') || u.includes('.srt.gz') || it.file_id; // OS entries will be converted server-side
                });
                const grouped = {};
                for (const it of items) {
                    const key = `${(it.langName || it.lang || 'Unknown').toLowerCase()}|${it.source}`;
                    if (!grouped[key]) grouped[key] = [];
                    grouped[key].push(it);
                }
                htmlSubsList.innerHTML = '';
                const entries = Object.entries(grouped);
                if (!entries.length) htmlSubsList.innerHTML = '<div class="subs-help">No subtitles found.</div>';
                for (const [key, arr] of entries) {
                    const [langNameLower, source] = key.split('|');
                    const langDisplay = langNameLower.charAt(0).toUpperCase() + langNameLower.slice(1);
                    arr.forEach((sub, idx) => {
                        const displayName = arr.length > 1 ? `${langDisplay} ${idx + 1}` : langDisplay;
                        const row = document.createElement('div');
                        row.className = 'subs-item';
                        row.innerHTML = `<div>${displayName} <span class="subs-source">(${source})</span></div><div class="subs-badge">Select</div>`;
                        row.addEventListener('click', async () => {
                            try {
                                const payload = sub.source === 'opensubtitles'
                                    ? { source: 'opensubtitles', fileId: sub.file_id, preferredName: sub.name }
                                    : { source: 'wyzie', url: sub.url, preferredName: sub.name };
                                const dl = await fetch(`${API_BASE_URL}/subtitles/download`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                                const dlJson = await dl.json();
                                if (dl.ok && dlJson.url) {
                                    // Delete old subtitle temp file (if any)
                                    if (currentSubtitleFile) {
                                        try {
                                            await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) });
                                        } catch {}
                                    }
                                    const langCode = (sub.lang || '').toLowerCase();
                                    await loadSubtitle(dlJson.url, { label: displayName, lang: langCode });
                                    showNotification(`Loaded: ${displayName}`);
                                    htmlSubsPanel.style.display = 'none';
                                } else {
                                    if (dl.status === 429 || dlJson?.code === 'OS_QUOTA') {
                                        showNotification('OpenSubtitles is rate-limited. Trying Wyzie automatically...');
                                        const sameLangWyzie = currentSubtitles.find(s => s.source === 'wyzie' && s.lang && s.lang === (sub.lang || '').toLowerCase());
                                        const anyWyzie = currentSubtitles.find(s => s.source === 'wyzie');
                                        const wyziePick = sameLangWyzie || anyWyzie;
                                        if (wyziePick) {
                                            try {
                                                // Delete old subtitle temp file (if any)
                                                if (currentSubtitleFile) {
                                                    try {
                                                        await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) });
                                                    } catch {}
                                                }
                                                const wyPayload = { source: 'wyzie', url: wyziePick.url, preferredName: wyziePick.name || wyziePick.langName };
                                                const wyDl = await fetch(`${API_BASE_URL}/subtitles/download`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(wyPayload) });
                                                const wyJson = await wyDl.json();
                                                if (wyDl.ok && wyJson.url) {
                                                    const langCode = (wyziePick.lang || '').toLowerCase();
                                                    await loadSubtitle(wyJson.url, { label: wyziePick.name || wyziePick.langName, lang: langCode });
                                                    showNotification(`Loaded from Wyzie: ${wyziePick.name || wyziePick.langName}`);
                                                    htmlSubsPanel.style.display = 'none';
                                                } else {
                                                    showNotification(wyJson.error || 'Wyzie fallback failed. Please pick a different subtitle.');
                                                }
                                            } catch (e) {
                                                showNotification('Wyzie fallback failed. Please pick a different subtitle.');
                                            }
                                        } else {
                                            showNotification('No Wyzie subtitles available. Please try another source later.');
                                        }
                                    } else {
                                        showNotification(dlJson.error || 'Subtitle download failed');
                                    }
                                }
                            } catch (e) {
                                showNotification('Subtitle download error');
                            }
                        });
                        htmlSubsList.appendChild(row);
                    });
                }
            } catch {
                htmlSubsList.innerHTML = '<div class="subs-help">Failed to load subtitles.</div>';
            }
        }

        // ---- BookTorrio functionality ----
        async function initializeBookTorrio() {
            const searchInput = document.getElementById('bookSearchInput');
            const searchBtn = document.getElementById('searchBooksBtn');
            const resultsContainer = document.getElementById('bookSearchResults');
            const loadingDiv = document.getElementById('bookSearchLoading');
            const searchTabBtn = document.getElementById('searchTabBtn');
            const libraryTabBtn = document.getElementById('libraryTabBtn');
            const searchTab = document.getElementById('searchTab');
            const libraryTab = document.getElementById('libraryTab');

            if (!searchInput || !searchBtn || !resultsContainer || !loadingDiv) return;

            // Show EPUB folder location to user
            try {
                const folderResult = await window.electronAPI.getEpubFolder();
                if (folderResult.success) {
                    console.log('EPUB books will be downloaded to:', folderResult.path);
                    // You could add a small info message on the page if needed
                }
            } catch (error) {
                console.warn('Could not get EPUB folder path:', error);
            }

            // Tab switching functionality
            if (searchTabBtn && libraryTabBtn && searchTab && libraryTab) {
                searchTabBtn.addEventListener('click', () => {
                    searchTabBtn.classList.add('active');
                    libraryTabBtn.classList.remove('active');
                    searchTab.style.display = 'block';
                    libraryTab.style.display = 'none';
                });

                libraryTabBtn.addEventListener('click', () => {
                    libraryTabBtn.classList.add('active');
                    searchTabBtn.classList.remove('active');
                    libraryTab.style.display = 'block';
                    searchTab.style.display = 'none';
                    // Load library when tab is opened
                    loadEpubLibrary();
                });
            }

            // Load EPUB library function
            async function loadEpubLibrary() {
                try {
                    const result = await window.electronAPI.getEpubLibrary();
                    const libraryContent = document.getElementById('libraryTab');
                    
                    if (result.success && result.books.length > 0) {
                        libraryContent.innerHTML = `
                            <div class="books-grid">
                                ${result.books.map(book => `
                                    <div class="book-card">
                                        <img src="${book.coverUrl || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMDZiNmQ0Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNHB4IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkJvb2s8L3RleHQ+PC9zdmc+'}"
                                             alt="${book.title}"
                                             class="book-cover"
                                             onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMDZiNmQ0Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNHB4IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkJvb2s8L3RleHQ+PC9zdmc+'">
                                        <div class="book-title">${book.title}</div>
                                        <div class="book-author">${Array.isArray(book.author) ? book.author.join(', ') : (book.author || '')}</div>
                                        <div class="book-details">
                                            <span class="book-tag"><i class="fas fa-file"></i> EPUB</span>
                                            ${book.fileSize ? `<span class="book-tag"><i class=\"fas fa-hdd\"></i> ${formatFileSize(book.fileSize)}</span>` : ''}
                                        </div>
                                        <button class="read-btn" data-local-path="${book.localPath}" data-title="${book.title}">
                                            <i class="fas fa-book-open"></i>
                                            Read
                                        </button>
                                    </div>
                                `).join('')}
                            </div>
                        `;
                        libraryContent.querySelectorAll('.read-btn').forEach(btn => {
                            btn.addEventListener('click', () => {
                                const p = btn.getAttribute('data-local-path');
                                const t = btn.getAttribute('data-title');
                                openEpubReader(p, t);
                            });
                        });
                    } else {
                        libraryContent.innerHTML = `
                            <div class="search-placeholder">
                                <i class="fas fa-bookmark" style="font-size: 3rem; color: #06b6d4; margin-bottom: 1rem;"></i>
                                <h3>No Books in Library</h3>
                                <p>Downloaded EPUB books will appear here. Search and download some books to get started!</p>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('Error loading library:', error);
                    const libraryContent = document.getElementById('libraryTab');
                    libraryContent.innerHTML = `
                        <div class="search-placeholder">
                            <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: #dc3545; margin-bottom: 1rem;"></i>
                            <h3>Error Loading Library</h3>
                            <p>Could not load your EPUB library. Please try again.</p>
                        </div>
                    `;
                }
            }

            // Search function
            async function searchBooks(query) {
                if (!query.trim()) return;

                try {
                    loadingDiv.style.display = 'block';
                    resultsContainer.innerHTML = '';

                    const response = await fetch(`http://localhost:3000/otherbook/api/search/${encodeURIComponent(query)}`);
                    if (!response.ok) {
                        throw new Error('Search failed');
                    }

                    const data = await response.json();
                    loadingDiv.style.display = 'none';

                    if (data.books && data.books.length > 0) {
                        // Filter to show only EPUB files
                        const epubBooks = data.books.filter(book => 
                            book.fileExtension && book.fileExtension.toLowerCase() === 'epub'
                        );

                        if (epubBooks.length === 0) {
                            resultsContainer.innerHTML = `
                                <div class="search-placeholder">
                                    <i class="fas fa-file-alt" style="font-size: 3rem; color: #06b6d4; margin-bottom: 1rem;"></i>
                                    <h3>No EPUB Books Found</h3>
                                    <p>No EPUB books found for "${query}". Try a different search term.</p>
                                </div>
                            `;
                            return;
                        }

                        resultsContainer.innerHTML = epubBooks.map(book => `
                            <div class="book-card">
                                <img src="${book.coverUrl || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMDZiNmQ0Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNHB4IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkJvb2s8L3RleHQ+PC9zdmc+'}" 
                                     alt="${book.title}" 
                                     class="book-cover"
                                     onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMDZiNmQ0Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNHB4IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkJvb2s8L3RleHQ+PC9zdmc+'">
                                <div class="book-title">${book.title}</div>
                                <div class="book-author">${Array.isArray(book.author) ? book.author.join(', ') : book.author}</div>
                                <div class="book-details">
                                    <span class="book-tag"><i class="fas fa-calendar"></i> ${book.year}</span>
                                    <span class="book-tag"><i class="fas fa-language"></i> ${book.language}</span>
                                    <span class="book-tag ${book.fileExtension && book.fileExtension.toLowerCase() === 'epub' ? 'epub-highlight' : ''}">
                                        <i class="fas fa-file"></i> ${book.fileExtension ? book.fileExtension.toUpperCase() : 'Unknown'}
                                    </span>
                                    <span class="book-tag"><i class="fas fa-hdd"></i> ${formatFileSize(book.fileSize)}</span>
                                </div>
                                <button class="download-btn" 
                                        data-download-url="${book.downloadlink}"
                                        data-book="${encodeURIComponent(JSON.stringify(book))}">
                                    <i class="fas fa-download"></i>
                                    Download Now
                                </button>
                            </div>
                        `).join('');

                        // Wire click handlers after rendering to avoid inline JS and quoting issues
                        const downloadButtons = resultsContainer.querySelectorAll('.download-btn');
                        downloadButtons.forEach(btn => {
                            btn.addEventListener('click', () => {
                                const url = btn.getAttribute('data-download-url');
                                const encoded = btn.getAttribute('data-book');
                                let bookObj = {};
                                try {
                                    bookObj = JSON.parse(decodeURIComponent(encoded));
                                } catch (e) {
                                    console.warn('Failed to parse book data from button:', e);
                                }
                                if (!url) {
                                    alert('No download URL available for this book.');
                                    return;
                                }
                                window.downloadBook(url, bookObj);
                            });
                        });
                    } else {
                        resultsContainer.innerHTML = `
                            <div class="search-placeholder">
                                <i class="fas fa-search" style="font-size: 3rem; color: #06b6d4; margin-bottom: 1rem;"></i>
                                <h3>No Books Found</h3>
                                <p>No books found for "${query}". Try a different search term.</p>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('Search error:', error);
                    loadingDiv.style.display = 'none';
                    resultsContainer.innerHTML = `
                        <div class="search-placeholder">
                            <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: #dc3545; margin-bottom: 1rem;"></i>
                            <h3>Search Error</h3>
                            <p>Failed to search for books. Make sure the RandomBook server is running on port 5000.</p>
                        </div>
                    `;
                }
            }

            // Format file size helper
            function formatFileSize(bytes) {
                if (!bytes) return 'Unknown';
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(1024));
                return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
            }

            // Download book function
            window.downloadBook = async function(downloadUrl, bookData) {
                console.log('downloadBook called with:', downloadUrl, bookData);
                
                if (downloadUrl && bookData) {
                    try {
                        console.log('Calling electronAPI.downloadEpub...');
                        // Get EPUB folder path and prepare download
                        const result = await window.electronAPI.downloadEpub({
                            url: downloadUrl,
                            bookData: bookData
                        });
                        
                        console.log('Download result:', result);
                        
                        if (result.success) {
                            // Show download modal
                            console.log('Showing download modal...');
                            showDownloadModal(result);
                        } else {
                            alert('Error preparing download: ' + result.message);
                        }
                    } catch (error) {
                        console.error('Download error:', error);
                        alert('Error preparing download. Please try again.');
                    }
                } else {
                    console.error('Invalid parameters:', { downloadUrl, bookData });
                    alert('Invalid download link or book data.');
                }
            };

            // Modal functions
            let currentDownload = null;

            function showDownloadModal(downloadInfo) {
                const modal = document.getElementById('epubDownloadModal');
                const pathText = document.getElementById('epubDownloadPath');
                
                // Store download info for modal functions
                currentDownload = downloadInfo;
                
                // Show only the folder path per user preference
                pathText.textContent = downloadInfo.folder;
                modal.style.display = 'flex';
            }

            function closeEpubDownloadModal() {
                const modal = document.getElementById('epubDownloadModal');
                modal.style.display = 'none';
                currentDownload = null;
            }

            function copyEpubPath() {
                if (currentDownload) {
                    // Copy only the folder path per user preference
                    navigator.clipboard.writeText(currentDownload.folder).then(() => {
                        // Show feedback
                        const button = document.querySelector('.copy-path-btn');
                        const originalText = button.textContent;
                        button.textContent = 'Copied!';
                        button.style.background = '#059669';
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.background = '';
                        }, 2000);
                    });
                }
            }

            function openDownloadLink() {
                if (currentDownload && currentDownload.url) {
                    // Use electron shell to open URL in default browser
                    if (window.electronAPI && window.electronAPI.openExternal) {
                        window.electronAPI.openExternal(currentDownload.url);
                    } else {
                        // Fallback
                        window.open(currentDownload.url, '_blank');
                    }
                }
            }

            // Make functions globally available
            window.closeEpubDownloadModal = closeEpubDownloadModal;
            window.copyEpubPath = copyEpubPath;
            window.openDownloadLink = openDownloadLink;

            // Event listeners
            searchBtn.addEventListener('click', () => {
                const query = searchInput.value.trim();
                if (query) {
                    searchBooks(query);
                }
            });

            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const query = searchInput.value.trim();
                    if (query) {
                        searchBooks(query);
                    }
                }
            });
        }

        // ---- Anime functionality ----
        let animeList = [];
        let currentAnime = null;
        let animeOffset = 0;
        let animeIsLoading = false;
        let animeHasMore = true;
        let animeIsSearching = false;
        let animeSearchQuery = '';
        let animeBaseUrl = 'http://localhost:3000/anime';
        
        async function initializeAnime() {
            const animeSearchInput = document.getElementById('animeSearchInput');
            const animeGrid = document.getElementById('animeGrid');
            const animeLoadingIndicator = document.getElementById('animeLoadingIndicator');
            const animeDetailsModal = document.getElementById('animeDetailsModal');
            const animeModalClose = document.getElementById('animeModalClose');
            const animeFindTorrentsBtn = document.getElementById('animeFindTorrentsBtn');
            const animeTorrentsContainer = document.getElementById('animeTorrentsContainer');
            const animeRefreshTorrents = document.getElementById('animeRefreshTorrents');
            const animeTorrentKeywordFilter = document.getElementById('animeTorrentKeywordFilter');
            
            let searchTimeout = null;
            
            // Load trending anime on init
            loadTrendingAnime();
            
            // Setup infinite scroll
            const mainElement = document.querySelector('main');
            mainElement.addEventListener('scroll', () => {
                const animePage = document.getElementById('anime-page');
                if (animePage.style.display === 'none') return;
                
                const scrollBottom = mainElement.scrollTop + mainElement.clientHeight;
                const threshold = mainElement.scrollHeight - 300;
                
                if (scrollBottom >= threshold && !animeIsLoading && animeHasMore) {
                    if (animeIsSearching) {
                        searchAnime(animeSearchQuery, true);
                    } else {
                        loadTrendingAnime(true);
                    }
                }
            });
            
            // Search functionality
            animeSearchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                const query = animeSearchInput.value.trim();
                
                if (!query) {
                    animeIsSearching = false;
                    animeSearchQuery = '';
                    animeOffset = 0;
                    animeHasMore = true;
                    loadTrendingAnime();
                    return;
                }
                
                searchTimeout = setTimeout(() => {
                    animeIsSearching = true;
                    animeSearchQuery = query;
                    animeOffset = 0;
                    animeHasMore = true;
                    searchAnime(query);
                }, 500);
            });
            
            animeSearchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const query = animeSearchInput.value.trim();
                    if (query) {
                        animeIsSearching = true;
                        animeSearchQuery = query;
                        animeOffset = 0;
                        animeHasMore = true;
                        searchAnime(query);
                    }
                }
            });
            
            // Modal close
            animeModalClose.addEventListener('click', () => {
                animeDetailsModal.classList.remove('active');
                animeTorrentsContainer.style.display = 'none';
            });
            
            animeDetailsModal.addEventListener('click', (e) => {
                if (e.target === animeDetailsModal) {
                    animeDetailsModal.classList.remove('active');
                    animeTorrentsContainer.style.display = 'none';
                }
            });
            
            // Find torrents button
            animeFindTorrentsBtn.addEventListener('click', async () => {
                if (!currentAnime) return;
                animeTorrentsContainer.style.display = 'block';
                await loadAnimeTorrents(currentAnime.title.romaji || currentAnime.title.english);
            });
            
            // Refresh torrents
            animeRefreshTorrents.addEventListener('click', async () => {
                if (!currentAnime) return;
                await loadAnimeTorrents(currentAnime.title.romaji || currentAnime.title.english);
            });
            
            // Torrent keyword filter
            animeTorrentKeywordFilter.addEventListener('input', () => {
                filterAnimeTorrents();
            });
            
            // Custom search functionality
            const animeCustomSearchInput = document.getElementById('animeCustomSearchInput');
            const animeCustomSearchBtn = document.getElementById('animeCustomSearchBtn');
            
            animeCustomSearchBtn.addEventListener('click', async () => {
                const query = animeCustomSearchInput.value.trim();
                if (query) {
                    await searchAnimeCustomQuery(query);
                }
            });
            
            animeCustomSearchInput.addEventListener('keypress', async (e) => {
                if (e.key === 'Enter') {
                    const query = animeCustomSearchInput.value.trim();
                    if (query) {
                        await searchAnimeCustomQuery(query);
                    }
                }
            });
        }
        
        async function loadTrendingAnime(append = false) {
            if (animeIsLoading) return;
            animeIsLoading = true;
            
            const animeGrid = document.getElementById('animeGrid');
            const animeLoadingIndicator = document.getElementById('animeLoadingIndicator');
            
            if (!append) {
                animeGrid.innerHTML = '';
                animeOffset = 0;
            }
            
            animeLoadingIndicator.style.display = 'block';
            
            try {
                const query = `
                    query ($page: Int, $perPage: Int) {
                        Page(page: $page, perPage: $perPage) {
                            media(type: ANIME, sort: TRENDING_DESC) {
                                id
                                title {
                                    romaji
                                    english
                                }
                                coverImage {
                                    large
                                }
                                bannerImage
                                averageScore
                                episodes
                                format
                                genres
                                seasonYear
                                description
                            }
                        }
                    }
                `;
                
                const page = Math.floor(animeOffset / 20) + 1;
                const variables = { page, perPage: 20 };
                
                const response = await fetch('https://graphql.anilist.co', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    body: JSON.stringify({ query, variables })
                });
                
                const data = await response.json();
                const anime = data.data.Page.media;
                
                if (append) {
                    animeList = [...animeList, ...anime];
                } else {
                    animeList = anime;
                }
                
                if (anime.length < 20) {
                    animeHasMore = false;
                }
                
                anime.forEach(item => {
                    const card = createAnimeCard(item);
                    animeGrid.appendChild(card);
                });
                
                animeOffset += anime.length;
            } catch (error) {
                console.error('Error loading trending anime:', error);
            } finally {
                animeLoadingIndicator.style.display = 'none';
                animeIsLoading = false;
            }
        }
        
        async function searchAnime(query, append = false) {
            if (animeIsLoading) return;
            animeIsLoading = true;
            
            const animeGrid = document.getElementById('animeGrid');
            const animeLoadingIndicator = document.getElementById('animeLoadingIndicator');
            
            if (!append) {
                animeGrid.innerHTML = '';
                animeOffset = 0;
            }
            
            animeLoadingIndicator.style.display = 'block';
            
            try {
                const graphqlQuery = `
                    query ($search: String, $page: Int, $perPage: Int) {
                        Page(page: $page, perPage: $perPage) {
                            media(type: ANIME, search: $search, sort: POPULARITY_DESC) {
                                id
                                title {
                                    romaji
                                    english
                                }
                                coverImage {
                                    large
                                }
                                bannerImage
                                averageScore
                                episodes
                                format
                                genres
                                seasonYear
                                description
                            }
                        }
                    }
                `;
                
                const page = Math.floor(animeOffset / 20) + 1;
                const variables = { search: query, page, perPage: 20 };
                
                const response = await fetch('https://graphql.anilist.co', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    body: JSON.stringify({ query: graphqlQuery, variables })
                });
                
                const data = await response.json();
                const anime = data.data.Page.media;
                
                if (append) {
                    animeList = [...animeList, ...anime];
                } else {
                    animeList = anime;
                }
                
                if (anime.length < 20) {
                    animeHasMore = false;
                }
                
                anime.forEach(item => {
                    const card = createAnimeCard(item);
                    animeGrid.appendChild(card);
                });
                
                animeOffset += anime.length;
            } catch (error) {
                console.error('Error searching anime:', error);
            } finally {
                animeLoadingIndicator.style.display = 'none';
                animeIsLoading = false;
            }
        }
        
        function createAnimeCard(anime) {
            const card = document.createElement('div');
            card.className = 'movie-card';
            card.style.cursor = 'pointer';
            
            const title = anime.title.english || anime.title.romaji;
            const coverImage = anime.coverImage.large || '/placeholder.jpg';
            const rating = anime.averageScore ? (anime.averageScore / 10).toFixed(1) : 'N/A';
            const year = anime.seasonYear || 'N/A';
            
            card.innerHTML = `
                <div class="movie-poster-container">
                    <img src="${coverImage}" alt="${title}" class="movie-poster" loading="lazy" />
                    <div class="movie-overlay">
                        <i class="fas fa-info-circle"></i>
                    </div>
                </div>
                <div class="movie-info">
                    <div class="movie-title">${title}</div>
                    <div class="movie-meta">
                        <span class="movie-year">${year}</span>
                        <span class="movie-rating">
                            <i class="fas fa-star"></i> ${rating}
                        </span>
                    </div>
                </div>
            `;
            
            card.addEventListener('click', () => showAnimeDetails(anime));
            return card;
        }
        
        function showAnimeDetails(anime) {
            currentAnime = anime;
            const animeDetailsModal = document.getElementById('animeDetailsModal');
            const animeModalTitle = document.getElementById('animeModalTitle');
            const animeModalPoster = document.getElementById('animeModalPoster');
            const animeModalBackdrop = document.getElementById('animeModalBackdrop');
            const animeModalRating = document.getElementById('animeModalRating');
            const animeModalYear = document.getElementById('animeModalYear');
            const animeModalEpisodes = document.getElementById('animeModalEpisodes');
            const animeModalGenres = document.getElementById('animeModalGenres');
            const animeModalOverview = document.getElementById('animeModalOverview');
            const animeTorrentsContainer = document.getElementById('animeTorrentsContainer');
            const animeSeasonEpisodeContainer = document.getElementById('animeSeasonEpisodeContainer');
            
            const title = anime.title.english || anime.title.romaji;
            const rating = anime.averageScore ? (anime.averageScore / 10).toFixed(1) : 'N/A';
            const year = anime.seasonYear || 'N/A';
            const episodes = anime.episodes ? `${anime.episodes} Episodes` : 'N/A';
            const genres = anime.genres ? anime.genres.join(', ') : 'N/A';
            const description = anime.description ? anime.description.replace(/<[^>]*>/g, '') : 'No description available.';
            
            animeModalTitle.textContent = title;
            animeModalPoster.src = anime.coverImage.large || '/placeholder.jpg';
            animeModalBackdrop.src = anime.bannerImage || anime.coverImage.large || '/placeholder.jpg';
            animeModalRating.textContent = rating;
            animeModalYear.textContent = year;
            animeModalEpisodes.textContent = episodes;
            animeModalGenres.textContent = genres;
            animeModalOverview.textContent = description;
            
            // Check if it's a series (has episodes) or a movie
            const isMovie = !anime.episodes || anime.episodes === 1 || anime.format === 'MOVIE';
            
            if (isMovie) {
                // Hide season/episode selector for movies
                animeSeasonEpisodeContainer.style.display = 'none';
            } else {
                // Show season/episode selector for series
                animeSeasonEpisodeContainer.style.display = 'block';
                setupAnimeSeasonEpisodeSelectors(anime.episodes);
            }
            
            animeTorrentsContainer.style.display = 'none';
            animeDetailsModal.classList.add('active');
        }
        
        function setupAnimeSeasonEpisodeSelectors(totalEpisodes) {
            const seasonSelector = document.getElementById('animeSeasonSelector');
            const episodeSelector = document.getElementById('animeEpisodeSelector');
            
            // Clear existing options
            seasonSelector.innerHTML = '<option value="">All Seasons</option>';
            episodeSelector.innerHTML = '<option value="">All Episodes</option>';
            
            // Remove old event listeners by cloning and replacing
            const newSeasonSelector = seasonSelector.cloneNode(false);
            const newEpisodeSelector = episodeSelector.cloneNode(false);
            const defaultSeasonOption = document.createElement('option');
            defaultSeasonOption.value = '';
            defaultSeasonOption.textContent = 'All Seasons';
            defaultSeasonOption.style.background = '#1a1a2e';
            defaultSeasonOption.style.color = 'var(--light)';
            newSeasonSelector.appendChild(defaultSeasonOption);
            
            const defaultEpisodeOption = document.createElement('option');
            defaultEpisodeOption.value = '';
            defaultEpisodeOption.textContent = 'All Episodes';
            defaultEpisodeOption.style.background = '#1a1a2e';
            defaultEpisodeOption.style.color = 'var(--light)';
            newEpisodeSelector.appendChild(defaultEpisodeOption);
            
            seasonSelector.parentNode.replaceChild(newSeasonSelector, seasonSelector);
            episodeSelector.parentNode.replaceChild(newEpisodeSelector, episodeSelector);
            
            // Estimate number of seasons (typical anime season is ~12-13 or 24-26 episodes)
            // Let's assume max 4 seasons for safety
            const estimatedSeasons = totalEpisodes ? Math.min(Math.ceil(totalEpisodes / 12), 4) : 1;
            
            // Populate season selector
            for (let i = 1; i <= estimatedSeasons; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Season ${i}`;
                option.style.background = '#1a1a2e';
                option.style.color = 'var(--light)';
                option.style.fontWeight = '500';
                newSeasonSelector.appendChild(option);
            }
            
            // Populate episode selector (up to total episodes or 100, whichever is smaller)
            const maxEpisodes = totalEpisodes ? Math.min(totalEpisodes, 100) : 50;
            for (let i = 1; i <= maxEpisodes; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Episode ${i}`;
                option.style.background = '#1a1a2e';
                option.style.color = 'var(--light)';
                option.style.fontWeight = '500';
                newEpisodeSelector.appendChild(option);
            }
            
            // Add event listeners (only once per new selector)
            newSeasonSelector.addEventListener('change', () => {
                if (document.getElementById('animeTorrentsContainer').style.display !== 'none') {
                    loadAnimeTorrents(currentAnime.title.romaji || currentAnime.title.english);
                }
            });
            
            newEpisodeSelector.addEventListener('change', () => {
                if (document.getElementById('animeTorrentsContainer').style.display !== 'none') {
                    loadAnimeTorrents(currentAnime.title.romaji || currentAnime.title.english);
                }
            });
        }
        
        async function loadAnimeTorrents(animeTitle) {
            const animeTorrentsList = document.getElementById('animeTorrentsList');
            const seasonSelector = document.getElementById('animeSeasonSelector');
            const episodeSelector = document.getElementById('animeEpisodeSelector');
            
            const selectedSeason = seasonSelector.value;
            const selectedEpisode = episodeSelector.value;
            
            // Generate search queries with multiple variants
            const searchQueries = generateAnimeSearchQueries(animeTitle, selectedSeason, selectedEpisode);
            
            // Show loading state and lock the display
            animeTorrentsList.innerHTML = `<div class="loading"><div class="spinner"></div><p>Searching Nyaa with ${searchQueries.length} query variants...</p></div>`;
            
            try {
                // Collect all results first
                const allTorrents = [];
                const seenMagnets = new Set();
                
                // Execute all searches in parallel and wait for ALL to complete
                const searchResults = await Promise.all(
                    searchQueries.map(async (query) => {
                        try {
                            const response = await fetch(`${animeBaseUrl}/api/${encodeURIComponent(query)}`);
                            const data = await response.json();
                            return data.results || [];
                        } catch (err) {
                            console.error(`Error searching for "${query}":`, err);
                            return [];
                        }
                    })
                );
                
                // Now combine all results (this happens AFTER all searches complete)
                searchResults.forEach(results => {
                    results.forEach(torrent => {
                        if (!seenMagnets.has(torrent.magnetLink)) {
                            seenMagnets.add(torrent.magnetLink);
                            allTorrents.push(torrent);
                        }
                    });
                });
                
                // Check if we found anything
                if (allTorrents.length === 0) {
                    animeTorrentsList.innerHTML = '<p style="text-align: center; color: var(--light); padding: 2rem;">No torrents found. Try selecting different season/episode options.</p>';
                    return;
                }
                
                // Sort by seeders (highest first)
                allTorrents.sort((a, b) => (b.seeders || 0) - (a.seeders || 0));
                
                // Store original torrents for filtering
                animeTorrentsList.dataset.allTorrents = JSON.stringify(allTorrents);
                
                // Display all results at once
                displayAnimeTorrents(allTorrents);
                
            } catch (error) {
                console.error('Error loading anime torrents:', error);
                animeTorrentsList.innerHTML = '<p style="text-align: center; color: #ff4444; padding: 2rem;">Error loading torrents. Make sure the Nyaa server is running.</p>';
            }
        }
        
        function generateAnimeSearchQueries(animeTitle, season, episode) {
            const queries = [];
            const baseTitle = animeTitle.trim();
            
            // If no season/episode selected, just search for the anime title
            if (!season && !episode) {
                queries.push(baseTitle);
                return queries;
            }
            
            // If only season selected (no specific episode)
            if (season && !episode) {
                // Season variants
                queries.push(`${baseTitle} S${season}`);
                queries.push(`${baseTitle} S${season.padStart(2, '0')}`);
                queries.push(`${baseTitle} Season ${season}`);
                queries.push(`${baseTitle} Season${season}`);
                queries.push(`${baseTitle} Season ${season.padStart(2, '0')}`);
                queries.push(`${baseTitle} Season${season.padStart(2, '0')}`);
                return queries;
            }
            
            // If only episode selected (no season)
            if (!season && episode) {
                // Episode only variants
                queries.push(`${baseTitle} E${episode}`);
                queries.push(`${baseTitle} E${episode.padStart(2, '0')}`);
                queries.push(`${baseTitle} EP${episode}`);
                queries.push(`${baseTitle} EP${episode.padStart(2, '0')}`);
                queries.push(`${baseTitle} Episode ${episode}`);
                queries.push(`${baseTitle} Episode${episode}`);
                queries.push(`${baseTitle} - ${episode.padStart(2, '0')}`);
                return queries;
            }
            
            // Both season and episode selected
            const s = season;
            const e = episode;
            const s2 = season.padStart(2, '0');
            const e2 = episode.padStart(2, '0');
            
            // Combined season+episode variants
            queries.push(`${baseTitle} S${s2}E${e2}`);
            queries.push(`${baseTitle} S${s}E${e}`);
            queries.push(`${baseTitle} S${s2}E${e}`);
            queries.push(`${baseTitle} S${s}E${e2}`);
            queries.push(`${baseTitle} S${s2} E${e2}`);
            queries.push(`${baseTitle} Season ${s} Episode ${e}`);
            queries.push(`${baseTitle} Season${s} Episode${e}`);
            queries.push(`${baseTitle} Season ${s} Ep ${e}`);
            queries.push(`${baseTitle} ${s2}x${e2}`);
            queries.push(`${baseTitle} - ${s2}x${e2}`);
            queries.push(`${baseTitle} - S${s2}E${e2}`);
            
            return queries;
        }
        
        function displayAnimeTorrents(torrents) {
            const animeTorrentsList = document.getElementById('animeTorrentsList');
            animeTorrentsList.innerHTML = '';
            
            torrents.forEach(torrent => {
                const torrentItem = document.createElement('div');
                torrentItem.className = 'torrent-item';
                
                torrentItem.innerHTML = `
                    <div class="torrent-info">
                        <div class="torrent-title">${torrent.title}</div>
                        <div class="torrent-meta">
                            <span class="torrent-size">
                                <i class="fas fa-hdd"></i> ${torrent.size}
                            </span>
                            <span class="torrent-seeders">
                                <i class="fas fa-arrow-up"></i> ${torrent.seeders} seeders
                            </span>
                        </div>
                    </div>
                    <div class="torrent-actions">
                        <button class="btn btn-primary" onclick="playAnimeTorrent('${torrent.magnetLink.replace(/'/g, "\\'")}', '${torrent.title.replace(/'/g, "\\'")}')">
                            <i class="fas fa-play"></i> Play
                        </button>
                    </div>
                `;
                
                animeTorrentsList.appendChild(torrentItem);
            });
        }
        
        function filterAnimeTorrents() {
            const animeTorrentsList = document.getElementById('animeTorrentsList');
            const filterInput = document.getElementById('animeTorrentKeywordFilter');
            const keyword = filterInput.value.toLowerCase();
            
            const allTorrentsData = animeTorrentsList.dataset.allTorrents;
            if (!allTorrentsData) return;
            
            const allTorrents = JSON.parse(allTorrentsData);
            
            if (!keyword) {
                displayAnimeTorrents(allTorrents);
                return;
            }
            
            const filtered = allTorrents.filter(t => t.title.toLowerCase().includes(keyword));
            displayAnimeTorrents(filtered);
        }
        
        async function searchAnimeCustomQuery(customQuery) {
            const animeTorrentsList = document.getElementById('animeTorrentsList');
            const animeTorrentsContainer = document.getElementById('animeTorrentsContainer');
            
            // Show torrents container if hidden
            animeTorrentsContainer.style.display = 'block';
            
            // Show loading
            animeTorrentsList.innerHTML = '<div class="loading"><div class="spinner"></div><p>Searching Nyaa with your custom query...</p></div>';
            
            try {
                const response = await fetch(`${animeBaseUrl}/api/${encodeURIComponent(customQuery)}`);
                const data = await response.json();
                
                if (!data.results || data.results.length === 0) {
                    animeTorrentsList.innerHTML = '<p style="text-align: center; color: var(--light); padding: 2rem;">No torrents found for your custom query. Try different keywords.</p>';
                    return;
                }
                
                // Sort by seeders
                const torrents = data.results.sort((a, b) => (b.seeders || 0) - (a.seeders || 0));
                
                // Store and display
                animeTorrentsList.dataset.allTorrents = JSON.stringify(torrents);
                displayAnimeTorrents(torrents);
                
                // Show notification
                showNotification(`Found ${torrents.length} torrents for "${customQuery}"`, 'success');
                
            } catch (error) {
                console.error('Error with custom search:', error);
                animeTorrentsList.innerHTML = '<p style="text-align: center; color: #ff4444; padding: 2rem;">Error searching. Make sure the Nyaa server is running.</p>';
            }
        }
        
        function playAnimeTorrent(magnetLink, title) {
            // Close the anime modal
            const animeDetailsModal = document.getElementById('animeDetailsModal');
            animeDetailsModal.classList.remove('active');
            
            // Use the same startStream function as movies/shows
            startStream(magnetLink);
        }

        // ---- Manga functionality ----
        let mangaList = [];
        let currentManga = null;
        let mangaOffset = 0;
        let mangaIsLoading = false;
        let mangaHasMore = true;
        let mangaIsSearching = false;
        let mangaSearchQuery = '';
        
        async function initializeManga() {
            const mangaSearchInput = document.getElementById('mangaSearchInput');
            const mangaGrid = document.getElementById('mangaGrid');
            const mangaLoadingIndicator = document.getElementById('mangaLoadingIndicator');
            const mangaDetailsModal = document.getElementById('mangaDetailsModal');
            const mangaDetailsClose = document.getElementById('mangaDetailsClose');
            const mangaReaderPage = document.getElementById('manga-reader-page');
            const mangaReaderBack = document.getElementById('mangaReaderBack');
            
            let searchTimeout = null;
            
            // Load trending manga on init
            loadTrendingManga();
            
            // Setup infinite scroll
            setupMangaInfiniteScroll();
            
            // Search functionality
            mangaSearchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                const query = mangaSearchInput.value.trim();
                
                if (!query) {
                    mangaIsSearching = false;
                    mangaSearchQuery = '';
                    mangaOffset = 0;
                    mangaHasMore = true;
                    loadTrendingManga();
                    return;
                }
                
                searchTimeout = setTimeout(() => {
                    searchManga(query);
                }, 500);
            });
            
            mangaSearchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const query = mangaSearchInput.value.trim();
                    if (query) {
                        clearTimeout(searchTimeout);
                        searchManga(query);
                    }
                }
            });
            
            // Close details modal
            mangaDetailsClose.addEventListener('click', () => {
                mangaDetailsModal.style.display = 'none';
            });
            
            // Back from reader
            mangaReaderBack.addEventListener('click', () => {
                mangaReaderPage.style.display = 'none';
                document.getElementById('manga-page').style.display = '';
            });
            
            // Add hover effect for back button
            mangaReaderBack.addEventListener('mouseenter', () => {
                mangaReaderBack.style.transform = 'scale(1.05)';
            });
            mangaReaderBack.addEventListener('mouseleave', () => {
                mangaReaderBack.style.transform = 'scale(1)';
            });
            
            function setupMangaInfiniteScroll() {
                const mainElement = document.querySelector('main');
                const mangaPage = document.getElementById('manga-page');
                
                mainElement.addEventListener('scroll', () => {
                    // Only trigger if manga page is visible
                    if (mangaPage.style.display === 'none') return;
                    if (mangaIsLoading || !mangaHasMore) return;
                    
                    const scrollHeight = mainElement.scrollHeight;
                    const scrollTop = mainElement.scrollTop;
                    const clientHeight = mainElement.clientHeight;
                    
                    // Load more when user is 500px from bottom
                    if (scrollHeight - scrollTop - clientHeight < 500) {
                        if (mangaIsSearching) {
                            searchManga(mangaSearchQuery, true); // true = append
                        } else {
                            loadTrendingManga(true); // true = append
                        }
                    }
                });
            }
            
            async function loadTrendingManga(append = false) {
                if (mangaIsLoading) return;
                
                mangaIsLoading = true;
                mangaLoadingIndicator.style.display = 'block';
                
                if (!append) {
                    mangaGrid.innerHTML = '';
                    mangaOffset = 0;
                    mangaHasMore = true;
                }
                
                try {
                    const response = await fetch(`https://api.mangadex.org/manga?limit=20&offset=${mangaOffset}&order[followedCount]=desc&includes[]=cover_art&includes[]=author&includes[]=artist&contentRating[]=safe&contentRating[]=suggestive`);
                    const data = await response.json();
                    
                    if (data.result === 'ok' && data.data) {
                        if (append) {
                            mangaList = [...mangaList, ...data.data];
                        } else {
                            mangaList = data.data;
                        }
                        
                        displayManga(data.data, append);
                        
                        // Update pagination
                        mangaOffset += data.data.length;
                        mangaHasMore = data.data.length === 20; // If we got less than 20, no more results
                    }
                } catch (error) {
                    console.error('Error loading trending manga:', error);
                    if (!append) {
                        mangaGrid.innerHTML = '<p style="text-align: center; color: var(--gray); grid-column: 1 / -1;">Failed to load manga. Please try again.</p>';
                    }
                } finally {
                    mangaLoadingIndicator.style.display = 'none';
                    mangaIsLoading = false;
                }
            }
            
            async function searchManga(query, append = false) {
                if (mangaIsLoading) return;
                
                mangaIsLoading = true;
                mangaLoadingIndicator.style.display = 'block';
                mangaIsSearching = true;
                mangaSearchQuery = query;
                
                if (!append) {
                    mangaGrid.innerHTML = '';
                    mangaOffset = 0;
                    mangaHasMore = true;
                }
                
                try {
                    const response = await fetch(`https://api.mangadex.org/manga?title=${encodeURIComponent(query)}&limit=20&offset=${mangaOffset}&includes[]=cover_art&includes[]=author&includes[]=artist&contentRating[]=safe&contentRating[]=suggestive`);
                    const data = await response.json();
                    
                    if (data.result === 'ok' && data.data) {
                        if (append) {
                            mangaList = [...mangaList, ...data.data];
                        } else {
                            mangaList = data.data;
                        }
                        
                        if (!append && mangaList.length === 0) {
                            mangaGrid.innerHTML = '<p style="text-align: center; color: var(--gray); grid-column: 1 / -1;">No manga found.</p>';
                        } else {
                            displayManga(data.data, append);
                        }
                        
                        // Update pagination
                        mangaOffset += data.data.length;
                        mangaHasMore = data.data.length === 20;
                    }
                } catch (error) {
                    console.error('Error searching manga:', error);
                    if (!append) {
                        mangaGrid.innerHTML = '<p style="text-align: center; color: var(--gray); grid-column: 1 / -1;">Search failed. Please try again.</p>';
                    }
                } finally {
                    mangaLoadingIndicator.style.display = 'none';
                    mangaIsLoading = false;
                }
            }
            
            function displayManga(mangaArray, append = false) {
                if (!append) {
                    mangaGrid.innerHTML = '';
                }
                
                mangaArray.forEach(manga => {
                    const title = manga.attributes.title.en || manga.attributes.title[Object.keys(manga.attributes.title)[0]] || 'Unknown Title';
                    const coverRel = manga.relationships.find(rel => rel.type === 'cover_art');
                    const coverFilename = coverRel?.attributes?.fileName || '';
                    const coverUrl = coverFilename ? `https://uploads.mangadex.org/covers/${manga.id}/${coverFilename}.256.jpg` : '';
                    
                    const card = document.createElement('div');
                    card.className = 'movie-card';
                    card.style.cursor = 'pointer';
                    
                    card.innerHTML = `
                        <img src="${coverUrl || 'https://via.placeholder.com/256x384?text=No+Cover'}" alt="${title}" class="movie-poster" style="object-fit: cover;">
                        <div class="movie-info">
                            <h3 class="movie-title">${title}</h3>
                            <p class="movie-year">${manga.attributes.year || 'N/A'}</p>
                        </div>
                        <div class="movie-rating" style="background: #ec4899;">
                            <i class="fas fa-book"></i> Manga
                        </div>
                    `;
                    
                    card.addEventListener('click', () => showMangaDetails(manga));
                    mangaGrid.appendChild(card);
                });
            }
            
            async function showMangaDetails(manga) {
                currentManga = manga;
                const title = manga.attributes.title.en || manga.attributes.title[Object.keys(manga.attributes.title)[0]] || 'Unknown Title';
                const description = manga.attributes.description.en || manga.attributes.description[Object.keys(manga.attributes.description)[0]] || 'No description available.';
                const author = manga.relationships.find(rel => rel.type === 'author')?.attributes?.name || 'Unknown';
                const status = manga.attributes.status || 'Unknown';
                const coverRel = manga.relationships.find(rel => rel.type === 'cover_art');
                const coverFilename = coverRel?.attributes?.fileName || '';
                const coverUrl = coverFilename ? `https://uploads.mangadex.org/covers/${manga.id}/${coverFilename}` : '';
                
                document.getElementById('mangaDetailsTitle').textContent = title;
                document.getElementById('mangaDetailsAuthor').textContent = `Author: ${author}`;
                document.getElementById('mangaDetailsStatus').textContent = `Status: ${status.charAt(0).toUpperCase() + status.slice(1)}`;
                document.getElementById('mangaDetailsDescription').textContent = description;
                document.getElementById('mangaDetailsCover').src = coverUrl || 'https://via.placeholder.com/300x450?text=No+Cover';
                
                // Tags
                const tagsContainer = document.getElementById('mangaDetailsTags');
                tagsContainer.innerHTML = '';
                (manga.attributes.tags || []).slice(0, 10).forEach(tag => {
                    const tagEl = document.createElement('span');
                    tagEl.style.cssText = 'padding: 0.25rem 0.75rem; background: rgba(236, 72, 153, 0.2); border: 1px solid #ec4899; border-radius: 999px; font-size: 0.85rem; color: #ec4899;';
                    tagEl.textContent = tag.attributes.name.en;
                    tagsContainer.appendChild(tagEl);
                });
                
                // Load chapters
                await loadMangaChapters(manga.id);
                
                mangaDetailsModal.style.display = 'block';
            }
            
            async function loadMangaChapters(mangaId) {
                const chaptersList = document.getElementById('mangaChaptersList');
                chaptersList.innerHTML = '<p style="text-align: center; color: white; grid-column: 1 / -1;">Loading chapters...</p>';
                
                try {
                    // First, try to fetch English chapters
                    const englishResponse = await fetch(`https://api.mangadex.org/manga/${mangaId}/feed?limit=500&includes[]=scanlation_group&includes[]=user&order[volume]=desc&order[chapter]=desc&offset=0&contentRating[]=safe&contentRating[]=suggestive&contentRating[]=erotica&contentRating[]=pornographic&translatedLanguage[]=en`);
                    const englishData = await englishResponse.json();
                    
                    let allChapters = [];
                    
                    // If we have English chapters, use them
                    if (englishData.result === 'ok' && englishData.data && englishData.data.length > 0) {
                        allChapters = englishData.data;
                    } else {
                        // No English chapters, fetch all languages
                        const allResponse = await fetch(`https://api.mangadex.org/manga/${mangaId}/feed?limit=500&includes[]=scanlation_group&includes[]=user&order[volume]=desc&order[chapter]=desc&offset=0&contentRating[]=safe&contentRating[]=suggestive&contentRating[]=erotica&contentRating[]=pornographic`);
                        const allData = await allResponse.json();
                        
                        if (allData.result === 'ok' && allData.data) {
                            allChapters = allData.data;
                        }
                    }
                    
                    chaptersList.innerHTML = '';
                    
                    if (allChapters.length === 0) {
                        chaptersList.innerHTML = '<p style="text-align: center; color: white; grid-column: 1 / -1;">No chapters available.</p>';
                        return;
                    }
                    
                    allChapters.forEach(chapter => {
                            const chapterNum = chapter.attributes.chapter || '?';
                            const chapterTitle = chapter.attributes.title || '';
                            const externalUrl = chapter.attributes.externalUrl;
                            const pages = chapter.attributes.pages;
                            const language = chapter.attributes.translatedLanguage || 'N/A';
                            const displayTitle = chapterTitle ? `Ch. ${chapterNum}: ${chapterTitle}` : `Chapter ${chapterNum}`;
                            
                            const chapterCard = document.createElement('div');
                            chapterCard.style.cssText = 'background: rgba(255,255,255,0.1); padding: 1rem; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; border: 1px solid rgba(236, 72, 153, 0.3);';
                            
                            // Language badge
                            const langBadge = `<span style="color: #a78bfa; font-size: 0.75rem; margin-left: 0.5rem; text-transform: uppercase;"> ${language}</span>`;
                            
                            // Add external link indicator if chapter has external URL, otherwise show if it's hosted
                            const statusBadge = externalUrl 
                                ? '<span style="color: #60a5fa; font-size: 0.75rem; margin-left: 0.5rem;"> External</span>' 
                                : (pages > 0 ? '<span style="color: #10b981; font-size: 0.75rem; margin-left: 0.5rem;"> ' + pages + ' pages</span>' : '');
                            
                            chapterCard.innerHTML = `
                                <div style="font-weight: 600; color: #ec4899; margin-bottom: 0.25rem;">${displayTitle}${langBadge}${statusBadge}</div>
                                <div style="font-size: 0.85rem; color: #9ca3af;">${new Date(chapter.attributes.publishAt).toLocaleDateString()}</div>
                            `;
                            
                            chapterCard.addEventListener('mouseenter', () => {
                                chapterCard.style.background = 'rgba(236, 72, 153, 0.2)';
                                chapterCard.style.transform = 'translateX(4px)';
                            });
                            
                            chapterCard.addEventListener('mouseleave', () => {
                                chapterCard.style.background = 'rgba(255,255,255,0.1)';
                                chapterCard.style.transform = 'translateX(0)';
                            });
                            
                            chapterCard.addEventListener('click', async () => {
                                if (externalUrl) {
                                    // Open external URL in default browser
                                    await window.electronAPI.openExternal(externalUrl);
                                } else {
                                    // Check if chapter has pages (hosted on MangaDex)
                                    if (pages > 0) {
                                        // Open in internal reader
                                        readChapter(chapter.id, displayTitle);
                                    } else {
                                        // Open on MangaDex website
                                        await window.electronAPI.openExternal(`https://mangadex.org/chapter/${chapter.id}`);
                                    }
                                }
                            });
                            
                            chaptersList.appendChild(chapterCard);
                        });
                } catch (error) {
                    console.error('Error loading chapters:', error);
                    chaptersList.innerHTML = '<p style="text-align: center; color: white; grid-column: 1 / -1;">Failed to load chapters.</p>';
                }
            }
            
            async function readChapter(chapterId, chapterTitle) {
                // Hide details modal and manga page
                mangaDetailsModal.style.display = 'none';
                document.getElementById('manga-page').style.display = 'none';
                
                // Show reader page
                mangaReaderPage.style.display = 'block';
                document.getElementById('mangaReaderTitle').textContent = chapterTitle;
                document.getElementById('mangaReaderPages').innerHTML = '';
                document.getElementById('mangaReaderLoading').style.display = 'block';
                
                try {
                    // Get chapter pages
                    const response = await fetch(`https://api.mangadex.org/at-home/server/${chapterId}`);
                    const data = await response.json();
                    
                    if (data.result === 'ok') {
                        const baseUrl = data.baseUrl;
                        const chapterHash = data.chapter.hash;
                        const pages = data.chapter.data; // Use high quality images
                        
                        document.getElementById('mangaReaderLoading').style.display = 'none';
                        
                        const pagesContainer = document.getElementById('mangaReaderPages');
                        pages.forEach((page, index) => {
                            const pageUrl = `${baseUrl}/data/${chapterHash}/${page}`;
                            
                            const img = document.createElement('img');
                            img.src = pageUrl;
                            img.alt = `Page ${index + 1}`;
                            img.style.cssText = 'width: 100%; height: auto; margin-bottom: 0.5rem; border-radius: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.5);';
                            img.loading = 'lazy';
                            
                            pagesContainer.appendChild(img);
                        });
                    } else {
                        throw new Error('Failed to load chapter data');
                    }
                } catch (error) {
                    console.error('Error reading chapter:', error);
                    document.getElementById('mangaReaderLoading').innerHTML = '<p style="color: #ef4444;">Failed to load chapter. Please try again.</p>';
                }
            }
        }

        // Initialize the app on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', init);

        // ---- Resume helpers ----

        // ---- EPUB Reader Logic ----
        let rendition = null;
        let bookInstance = null;
    let chapterToc = null;
    let chapterSpineItems = null;
    let chapterTotal = 0;

        async function openEpubReader(localPath, title) {
            try {
                console.log('[EPUB] Opening:', localPath);
                const overlay = document.getElementById('epubReaderOverlay');
                const titleEl = document.getElementById('readerTitle');
                const container = document.getElementById('readerContainer');
                const prevBtn = document.getElementById('readerPrevBtn');
                const nextBtn = document.getElementById('readerNextBtn');

                titleEl.textContent = title || 'EPUB Reader';
                overlay.classList.add('theme-dark');
                overlay.classList.remove('theme-light', 'theme-night');
                overlay.style.display = 'flex';

                // Clear previous
                container.innerHTML = '';
                rendition = null;
                bookInstance = null;
                prevBtn.disabled = true;
                nextBtn.disabled = false;

                // Load epub.js and JSZip first
                if (!window.ePub || !window.JSZip) {
                    console.log('[EPUB] Loading libraries...');
                    
                    if (!window.JSZip) {
                        const jszipScript = document.createElement('script');
                        jszipScript.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
                        await new Promise((resolve, reject) => {
                            jszipScript.onload = resolve;
                            jszipScript.onerror = reject;
                            document.head.appendChild(jszipScript);
                        });
                        console.log('[EPUB] JSZip loaded');
                    }

                    if (!window.ePub) {
                        const epubScript = document.createElement('script');
                        epubScript.src = 'https://cdn.jsdelivr.net/npm/epubjs@0.3.93/dist/epub.min.js';
                        await new Promise((resolve, reject) => {
                            epubScript.onload = resolve;
                            epubScript.onerror = reject;
                            document.head.appendChild(epubScript);
                        });
                        console.log('[EPUB] epub.js loaded');
                    }
                }

                // Read the file from main
                console.log('[EPUB] Reading file...');
                const res = await window.electronAPI.readEpubFile(localPath);
                console.log('[EPUB] Read result:', res.success, res.base64 ? `${res.base64.length} bytes` : 'no data');
                if (!res.success) {
                    alert('Failed to open book: ' + res.message);
                    overlay.style.display = 'none';
                    return;
                }

                // Convert base64 to ArrayBuffer for better compatibility
                console.log('[EPUB] Converting to ArrayBuffer...');
                const binaryString = atob(res.base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                console.log('[EPUB] ArrayBuffer size:', bytes.length);

                console.log('[EPUB] Creating book instance...');
                bookInstance = window.ePub(bytes.buffer);
                
                console.log('[EPUB] Rendering to container...');
                rendition = bookInstance.renderTo(container, { 
                    width: '100%', 
                    height: '100%',
                    spread: 'none',
                    flow: 'paginated'
                });
                
                // Create a unique key for this book based on its path
                const bookKey = 'epub_position_' + encodeURIComponent(localPath);
                
                // Wire navigation and save position on page change
                rendition.on('relocated', (location) => {
                    console.log('[EPUB] Relocated:', location.atStart, location.atEnd);
                    prevBtn.disabled = location.atStart;
                    nextBtn.disabled = location.atEnd;
                    
                    // Save current position to localStorage
                    if (location && location.start && location.start.cfi) {
                        try {
                            localStorage.setItem(bookKey, location.start.cfi);
                            console.log('[EPUB] Saved position:', location.start.cfi);
                        } catch (e) {
                            console.warn('[EPUB] Could not save position:', e);
                        }
                    }
                });

                // Try to restore last position
                let restored = false;
                try {
                    const savedPosition = localStorage.getItem(bookKey);
                    if (savedPosition) {
                        console.log('[EPUB] Restoring position:', savedPosition);
                        await rendition.display(savedPosition);
                        restored = true;
                        console.log('[EPUB] Position restored successfully');
                    }
                } catch (e) {
                    console.warn('[EPUB] Could not restore position:', e);
                }
                
                // If no saved position or restore failed, display from beginning
                if (!restored) {
                    console.log('[EPUB] Displaying from beginning...');
                    await rendition.display();
                }
                
                console.log('[EPUB] Book opened successfully');

                // Apply initial theme/font/size
                applyReaderPrefs();

                // Initialize chapter controls (count and input range)
                await initChapterControls();
            } catch (err) {
                console.error('[EPUB] Error:', err);
                alert('Could not open the EPUB: ' + err.message);
                const overlay = document.getElementById('epubReaderOverlay');
                overlay.style.display = 'none';
            }
        }

        function closeEpubReader() {
            const overlay = document.getElementById('epubReaderOverlay');
            const settingsPanel = document.getElementById('readerSettingsPanel');
            overlay.style.display = 'none';
            settingsPanel.classList.add('hidden');
            // Cleanup
            if (rendition) { try { rendition.destroy(); } catch(_){} }
            rendition = null;
            bookInstance = null;
            chapterToc = null;
            chapterSpineItems = null;
            chapterTotal = 0;
            const chapterControls = document.getElementById('readerChapterControls');
            if (chapterControls) chapterControls.style.display = 'none';
        }

        // Escape key to close reader
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const overlay = document.getElementById('epubReaderOverlay');
                if (overlay && overlay.style.display === 'flex') {
                    closeEpubReader();
                }
            }
        });

        // Settings handling
        function applyReaderPrefs() {
            const overlay = document.getElementById('epubReaderOverlay');
            const theme = localStorage.getItem('reader.theme') || 'dark';
            const font = localStorage.getItem('reader.font') || "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif";
            const size = parseInt(localStorage.getItem('reader.size') || '16', 10);

            overlay.classList.remove('theme-light', 'theme-dark', 'theme-night');
            overlay.classList.add(`theme-${theme}`);

            if (rendition) {
                // Map explicit colors for the iframe
                let fg = '#f2f2f2', bg = '#202225';
                if (theme === 'light') { fg = '#111111'; bg = '#ffffff'; }
                else if (theme === 'night') { fg = '#e5e7eb'; bg = '#000000'; }
                
                // Register and select theme with font
                try { 
                    rendition.themes.register('custom', { 
                        'body': { 
                            'font-family': `${font} !important`, 
                            'color': fg, 
                            'background': bg 
                        },
                        '*': {
                            'font-family': `${font} !important`
                        }
                    }); 
                } catch(e){ console.log('[EPUB] Theme register error:', e); }
                try { rendition.themes.select('custom'); } catch(e){ console.log('[EPUB] Theme select error:', e); }
                try { rendition.themes.fontSize(`${size}px`); } catch(e){ console.log('[EPUB] Font size error:', e); }
                
                // Force font update
                try {
                    rendition.themes.default({
                        'body': { 'font-family': `${font} !important` },
                        'p': { 'font-family': `${font} !important` },
                        'div': { 'font-family': `${font} !important` },
                        'span': { 'font-family': `${font} !important` }
                    });
                } catch(e){ }
            }
        }

        // Header buttons
        document.addEventListener('click', (e) => {
            if (e.target.closest('#readerPrevBtn')) {
                if (rendition) {
                    console.log('[EPUB] Going to previous page');
                    rendition.prev();
                }
            }
            if (e.target.closest('#readerNextBtn')) {
                if (rendition) {
                    console.log('[EPUB] Going to next page');
                    rendition.next();
                }
            }
            if (e.target.closest('#readerChapterGo')) {
                const inputEl = document.getElementById('readerChapterInput');
                if (!inputEl) return;
                const val = parseInt(inputEl.value, 10);
                goToChapterIndex(val);
            }
            if (e.target.closest('#readerSettingsBtn')) {
                const panel = document.getElementById('readerSettingsPanel');
                const wasHidden = panel.classList.contains('hidden');
                panel.classList.toggle('hidden');
                
                // Restore current values when opening settings
                if (wasHidden) {
                    const fontSelect = document.getElementById('readerFont');
                    const fontSizeInput = document.getElementById('readerFontSize');
                    const currentFont = localStorage.getItem('reader.font') || "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif";
                    const currentSize = localStorage.getItem('reader.size') || '16';
                    
                    if (fontSelect) fontSelect.value = currentFont;
                    if (fontSizeInput) fontSizeInput.value = currentSize;
                }
                
                console.log('[EPUB] Settings panel toggled:', wasHidden ? 'now visible' : 'now hidden');
            }
            if (e.target.closest('#readerBackBtn')) {
                console.log('[EPUB] Back button clicked');
                closeEpubReader();
            }
        });

        // Handle Enter key on the chapter input
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target && e.target.id === 'readerChapterInput') {
                const val = parseInt(e.target.value, 10);
                goToChapterIndex(val);
            }
        });

        // Settings controls
        document.addEventListener('click', (e) => {
            const themeBtn = e.target.closest('.theme-btn');
            if (themeBtn) {
                const theme = themeBtn.getAttribute('data-theme');
                localStorage.setItem('reader.theme', theme);
                applyReaderPrefs();
            }
        });
        document.addEventListener('input', (e) => {
            if (e.target.id === 'readerFont') {
                localStorage.setItem('reader.font', e.target.value);
                applyReaderPrefs();
            } else if (e.target.id === 'readerFontSize') {
                localStorage.setItem('reader.size', e.target.value);
                applyReaderPrefs();
            }
        });

        // Expose open function if needed elsewhere
        window.openEpubReader = openEpubReader;
        
        // Initialize chapter controls: compute total and prepare UI
        async function initChapterControls() {
            try {
                const controls = document.getElementById('readerChapterControls');
                const countEl = document.getElementById('readerChapterCount');
                const inputEl = document.getElementById('readerChapterInput');
                if (!controls || !countEl || !inputEl) return;

                if (!bookInstance) {
                    controls.style.display = 'none';
                    return;
                }

                chapterToc = null;
                chapterSpineItems = null;
                chapterTotal = 0;

                // Try to load navigation (TOC)
                try {
                    const nav = await bookInstance.loaded?.navigation;
                    if (nav && Array.isArray(nav.toc) && nav.toc.length > 0) {
                        chapterToc = nav.toc;
                        chapterTotal = chapterToc.length;
                    }
                } catch(_) {}

                // Fallback to spine items
                if (!chapterTotal) {
                    try {
                        const spine = await bookInstance.loaded?.spine;
                        if (spine && Array.isArray(spine.spineItems) && spine.spineItems.length > 0) {
                            chapterSpineItems = spine.spineItems;
                            chapterTotal = chapterSpineItems.length;
                        } else if (bookInstance.spine && Array.isArray(bookInstance.spine.spineItems) && bookInstance.spine.spineItems.length > 0) {
                            chapterSpineItems = bookInstance.spine.spineItems;
                            chapterTotal = chapterSpineItems.length;
                        }
                    } catch(_) {}
                }

                if (chapterTotal > 0) {
                    controls.style.display = 'flex';
                    countEl.textContent = String(chapterTotal);
                    inputEl.max = String(chapterTotal);
                    inputEl.placeholder = `1-${chapterTotal}`;
                } else {
                    controls.style.display = 'none';
                }
            } catch (e) {
                console.warn('[EPUB] Could not initialize chapter controls:', e);
            }
        }

        // Jump to a given 1-based chapter index
        async function goToChapterIndex(n) {
            const inputEl = document.getElementById('readerChapterInput');
            if (!bookInstance || !rendition || !Number.isFinite(n)) {
                if (inputEl) flashInvalid(inputEl);
                return;
            }
            const total = chapterTotal || 0;
            if (!total) {
                if (inputEl) flashInvalid(inputEl);
                return;
            }
            let idx = Math.floor(n) - 1;
            if (idx < 0 || idx >= total) {
                if (inputEl) flashInvalid(inputEl);
                return;
            }
            try {
                let targetHref = null;
                if (chapterToc && chapterToc[idx] && chapterToc[idx].href) {
                    targetHref = chapterToc[idx].href;
                } else if (chapterSpineItems && chapterSpineItems[idx] && chapterSpineItems[idx].href) {
                    targetHref = chapterSpineItems[idx].href;
                }
                if (targetHref) {
                    await rendition.display(targetHref);
                } else {
                    // As a last resort, try using the spine index directly if available
                    if (typeof bookInstance.spine?.get === 'function') {
                        const item = bookInstance.spine.get(idx);
                        if (item && item.href) {
                            await rendition.display(item.href);
                            return;
                        }
                    }
                    throw new Error('No valid chapter target');
                }
            } catch (err) {
                console.warn('[EPUB] Failed to jump to chapter', n, err);
                if (inputEl) flashInvalid(inputEl);
            }
        }

        function flashInvalid(inputEl) {
            const orig = inputEl.style.borderColor;
            inputEl.style.borderColor = 'rgba(244,63,94,0.85)';
            setTimeout(() => { inputEl.style.borderColor = orig || 'rgba(255,255,255,0.15)'; }, 450);
        }
        async function fetchResume(key) {
            if (!key) return null;
            try {
                const r = await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(key)}`);
                if (!r.ok) return null;
                const j = await r.json();
                if (j && typeof j.position === 'number' && j.position > 0) return j;
            } catch(_){ }
            return null;
        }
        async function saveResume() {
            if (!resumeKey || !customVideo || !isFinite(customVideo.duration) || !isFinite(customVideo.currentTime)) return;
            const pos = Math.max(0, Math.floor(customVideo.currentTime || 0));
            const dur = Math.max(0, Math.floor(customVideo.duration || 0));
            const title = currentSelectedVideoName || (currentContent?.title || currentContent?.name || '');
            if (dur === 0 || pos === 0) return;
            try {
                await fetch(`${API_BASE_URL}/resume`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: resumeKey, position: pos, duration: dur, title }) });
            } catch(_){ }
        }
        function saveResumeThrottled(immediate = false) {
            const now = Date.now();
            if (immediate || now - lastResumeSend > 2500) {
                lastResumeSend = now;
                clearTimeout(resumeTimer);
                resumeTimer = null;
                saveResume();
                return;
            }
            if (!resumeTimer) {
                resumeTimer = setTimeout(() => { lastResumeSend = Date.now(); saveResume(); resumeTimer = null; }, 1500);
            }
        }
        try {
            customVideo.addEventListener('ended', async () => {
                if (resumeKey) {
                    try { await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(resumeKey)}`, { method: 'DELETE' }); } catch(_){ }
                }
            });
        } catch(_){ }

        // Hook version notice (v1.6.3) from main
        try {
            if (window.electronAPI?.onVersionNotice163) {
                window.electronAPI.onVersionNotice163(() => {
                    showVersion163Modal();
                });
            }
        } catch(_) {}

        // ---- Updater overlay wiring (non-intrusive) ----
        try {
            const overlay = document.getElementById('updateOverlay');
            const icon = document.getElementById('updateStatusIcon');
            const text = document.getElementById('updateStatusText');
            const bar = document.getElementById('updateProgressBar');
            const pct = document.getElementById('updatePercent');
            const restartBtn = document.getElementById('updateRestartBtn');

            function showOverlay() {
                if (overlay) overlay.style.display = 'flex';
                document.body && (document.body.style.overflow = 'hidden');
            }
            function hideOverlay() {
                if (overlay) overlay.style.display = 'none';
                document.body && (document.body.style.overflow = 'auto');
            }

            if (window.electronAPI) {
                // When update check starts, show longer notification
                window.electronAPI.onUpdateChecking?.((_info) => {
                    showNotification(' Checking for updates...', 'info', 5000); // Show for 5 seconds
                });

                // When no update is available, show longer notification
                window.electronAPI.onUpdateNotAvailable?.((_info) => {
                    showNotification(' App is up to date', 'success', 4000); // Show for 4 seconds
                });
                
                // When update becomes available, show persistent overlay and notification
                window.electronAPI.onUpdateAvailable?.((_info) => {
                    showOverlay();
                    if (icon) { icon.className = 'fas fa-download'; icon.style.animation = 'pulse 1.5s ease-in-out infinite'; icon.style.color = '#a855f7'; }
                    if (text) text.textContent = 'Update found! Download starting, please wait...';
                    if (bar) bar.style.width = '0%';
                    if (pct) pct.textContent = '0%';
                    if (restartBtn) restartBtn.style.display = 'none';
                    
                    const warningText = document.getElementById('updateWarningText');
                    if (warningText) warningText.textContent = ' Downloading update - please keep the app open';
                    
                    // Show persistent download notification that stays until completion
                    showPersistentDownloadNotification(0);
                });
                
                // Progress updates - keep overlay visible throughout download
                window.electronAPI.onUpdateProgress?.((p) => {
                    const percent = Math.max(0, Math.min(100, Math.round(p?.percent || 0)));
                    if (bar) bar.style.width = percent + '%';
                    if (pct) pct.textContent = percent + '%';
                    if (text) text.textContent = `Downloading update... ${percent}% complete`;
                    if (icon) { icon.className = 'fas fa-download'; icon.style.animation = 'pulse 1.5s ease-in-out infinite'; }
                    updatePersistentDownloadNotification(percent);
                    
                    // Optional: throttle additional toasts if desired; persistent notif covers it
                });
                
                // Download finished - keep overlay visible and show persistent restart notification
                window.electronAPI.onUpdateDownloaded?.((_info) => {
                    // Switch from download notification to restart-ready notification
                    hideUpdateNotification();
                    if (icon) { icon.className = 'fas fa-check-circle'; icon.style.animation = 'none'; icon.style.color = '#22c55e'; }
                    if (text) text.textContent = 'Update downloaded successfully! Click "Restart Now" to complete the update.';
                    if (bar) bar.style.width = '100%';
                    if (pct) pct.textContent = '100%';
                    if (restartBtn) restartBtn.style.display = 'inline-flex';
                    
                    const warningText = document.getElementById('updateWarningText');
                    if (warningText) warningText.textContent = ' Update ready! You can restart the app anytime to apply the update';
                    
                    const closeBtn = document.getElementById('updateCloseBtn');
                    if (closeBtn) closeBtn.style.display = 'flex';
                    
                    // Show persistent restart notification that stays until user restarts
                    showPersistentUpdateNotification();
                });
                
                // Restart button
                restartBtn?.addEventListener('click', async (ev) => {
                    try {
                        ev.stopPropagation?.();
                        // Visual feedback: disable button and show restarting state
                        restartBtn.disabled = true;
                        const originalHtml = restartBtn.innerHTML;
                        restartBtn.innerHTML = '<i class="fas fa-sync fa-spin"></i> Restarting...';
                        restartBtn.style.opacity = '0.85';

                        // Trigger updater installation (main will relaunch automatically)
                        const res = await window.electronAPI.installUpdateNow?.();
                        // Optionally hide the notification right after invoking install
                        // (App should quit almost immediately.)
                        setTimeout(() => { try { hideUpdateNotification(); } catch(_) {} }, 200);

                        // If for some reason it didn't return success, keep overlay visible
                        if (!res || res.success !== true) {
                            restartBtn.disabled = false;
                            restartBtn.innerHTML = originalHtml;
                            restartBtn.style.opacity = '1';
                            showNotification('Update install failed to start. Please try again.', 'error', 4000);
                        }
                    } catch (e) {
                        // Restore button and keep the overlay so user can retry
                        try {
                            restartBtn.disabled = false;
                            restartBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Restart Now to Complete Update';
                            restartBtn.style.opacity = '1';
                        } catch(_) {}
                        showNotification('Could not trigger restart. Please try again.', 'error', 4000);
                    }
                });
            }
            
            // Offline/Online UX: show a small banner so users know they can access offline music
            try {
                const notifyOffline = () => showNotification('You are offline. Offline Music Library is available.', 'warning', 5000);
                const notifyOnline = () => showNotification('Back online.', 'success', 3000);
                if (typeof navigator !== 'undefined' && navigator && navigator.onLine === false) {
                    notifyOffline();
                }
                window.addEventListener('offline', notifyOffline);
                window.addEventListener('online', notifyOnline);
            } catch(_) {}
        } catch(_){ }

        // ---- My List functionality ----
        let myListCache = [];

        async function loadMyList() {
            try {
                const response = await window.electronAPI.myListRead();
                if (response.success) {
                    myListCache = response.data || [];
                    return myListCache;
                } else {
                    console.error('Failed to load my list:', response.message);
                    return [];
                }
            } catch (error) {
                console.error('Error loading my list:', error);
                return [];
            }
        }

        async function saveMyList() {
            try {
                const response = await window.electronAPI.myListWrite(myListCache);
                if (!response.success) {
                    console.error('Failed to save my list:', response.message);
                }
                return response.success;
            } catch (error) {
                console.error('Error saving my list:', error);
                return false;
            }
        }

        async function toggleMyList(event, id, mediaType, title, posterPath, year, rating) {
            event.preventDefault();
            event.stopPropagation();
            
            const button = event.target.closest('.add-to-list-btn');
            if (!button) return;

            const existingIndex = myListCache.findIndex(item => item.id === id && item.media_type === mediaType);
            
            if (existingIndex >= 0) {
                // Remove from list
                myListCache.splice(existingIndex, 1);
                button.classList.remove('in-list');
                button.innerHTML = '<i class="fas fa-plus"></i>';
                button.title = 'Add to My List';
                
                // Sync removal with Trakt
                await syncWithTraktWatchlist('remove', title, mediaType, year);
            } else {
                // Add to list
                const listItem = {
                    id: id,
                    media_type: mediaType,
                    title: title,
                    poster_path: posterPath,
                    year: year,
                    vote_average: rating,
                    added_date: new Date().toISOString()
                };
                myListCache.unshift(listItem); // Add to beginning
                button.classList.add('in-list');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Remove from My List';
                
                // Sync addition with Trakt
                await syncWithTraktWatchlist('add', title, mediaType, year);
            }

            await saveMyList();
            
            // Refresh My List page if it's currently open
            if (document.getElementById('myListPage').style.display !== 'none') {
                displayMyList();
            }
        }

        function updateCardListStatus(cardElement, id, mediaType) {
            const button = cardElement.querySelector('.add-to-list-btn');
            if (!button) return;

            const isInList = myListCache.some(item => item.id === id && item.media_type === mediaType);
            
            if (isInList) {
                button.classList.add('in-list');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Remove from My List';
            } else {
                button.classList.remove('in-list');
                button.innerHTML = '<i class="fas fa-plus"></i>';
                button.title = 'Add to My List';
            }
        }

        function updateCardDoneStatus(cardElement, id, mediaType) {
            const button = cardElement.querySelector('.done-watching-btn');
            if (!button) return;

            // Only mark as done if the exact title (movie or full show) is in doneWatchingCache,
            // never due to episode entries.
            const isDone = doneWatchingCache.some(item =>
                item.id === id && item.media_type === mediaType && (!item.season && !item.episode)
            );

            if (isDone) {
                button.classList.add('is-done');
                button.innerHTML = '<i class="fas fa-check-circle"></i>';
                button.title = 'Remove from Done Watching';
            } else {
                button.classList.remove('is-done');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Mark as Done Watching';
            }
        }

        async function displayMyList() {
            const grid = document.getElementById('myListGrid');
            const loading = document.getElementById('myListLoading');
            const empty = document.getElementById('myListEmpty');
            
            if (!grid) return;

            loading.style.display = 'block';
            empty.style.display = 'none';
            grid.innerHTML = '';

            await loadMyList();

            loading.style.display = 'none';

            if (myListCache.length === 0) {
                empty.style.display = 'block';
                return;
            }

            myListCache.forEach(item => {
                const card = document.createElement('div');
                card.className = 'movie-card';
                card.dataset.rating = item.vote_average || 0;
                card.dataset.date = `${item.year}-01-01`; // Approximate date for consistency
                card.innerHTML = `
                    <button class="add-to-list-btn in-list" onclick="toggleMyList(event, ${item.id}, '${item.media_type}', '${item.title.replace(/'/g, "\\'")}', '${item.poster_path}', '${item.year}', ${item.vote_average})">
                        <i class="fas fa-check"></i>
                    </button>
                    <img loading="lazy" decoding="async" src="https://image.tmdb.org/t/p/w342${item.poster_path}" alt="${item.title}" class="movie-poster">
                    <div class="movie-info">
                        <h3 class="movie-title">${item.title}</h3>
                        <p class="movie-year">${item.year}</p>
                    </div>
                    <div class="movie-rating">
                        <i class="fas fa-star"></i> ${Number(item.vote_average).toFixed(1)}
                    </div>
                `;
                card.addEventListener('click', (e) => {
                    if (!e.target.closest('.add-to-list-btn')) {
                        openDetailsModal(item, item.media_type);
                    }
                });
                grid.appendChild(card);
            });
        }

        async function clearMyList() {
            if (confirm('Are you sure you want to clear your entire list? This action cannot be undone.')) {
                myListCache = [];
                await saveMyList();
                
                // Update all visible cards
                document.querySelectorAll('.add-to-list-btn.in-list').forEach(button => {
                    button.classList.remove('in-list');
                    button.innerHTML = '<i class="fas fa-plus"></i>';
                    button.title = 'Add to My List';
                });
                
                // Refresh My List page if open
                if (document.getElementById('myListPage').style.display !== 'none') {
                    displayMyList();
                }
            }
        }

        // ---- Done Watching functionality ----
        let doneWatchingCache = [];

        async function loadDoneWatching() {
            try {
                const response = await window.electronAPI.doneWatchingRead();
                if (response.success) {
                    doneWatchingCache = response.data || [];
                    return doneWatchingCache;
                } else {
                    console.error('Failed to load done watching:', response.message);
                    return [];
                }
            } catch (error) {
                console.error('Error loading done watching:', error);
                return [];
            }
        }

        async function saveDoneWatching() {
            try {
                const response = await window.electronAPI.doneWatchingWrite(doneWatchingCache);
                if (!response.success) {
                    console.error('Failed to save done watching:', response.message);
                }
                return response.success;
            } catch (error) {
                console.error('Error saving done watching:', error);
                return false;
            }
        }

        async function toggleDoneWatching(event, id, mediaType, title, posterPath, year, rating, season, episode) {
            event.preventDefault();
            event.stopPropagation();
            
            const button = event.target.closest('.done-watching-btn');
            if (!button) return;

            const existingIndex = doneWatchingCache.findIndex(item => {
                if (mediaType === 'tv' && season && episode) {
                    // For episodes, match by show ID, season, and episode
                    return item.id === id && item.media_type === mediaType && 
                           item.season === season && item.episode === episode;
                } else {
                    // For movies and whole shows, match by ID and media type
                    return item.id === id && item.media_type === mediaType;
                }
            });
            
            if (existingIndex >= 0) {
                // Remove from done watching
                doneWatchingCache.splice(existingIndex, 1);
                button.classList.remove('is-done');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Mark as Done Watching';
                
                // Note: We don't remove from Trakt history as that's not typical behavior
                showNotification('Removed from local done watching list', 'info');
            } else {
                // Add to done watching
                const doneItem = {
                    id: id,
                    media_type: mediaType,
                    title: title,
                    poster_path: posterPath,
                    year: year,
                    vote_average: rating,
                    completed_date: new Date().toISOString()
                };
                
                // Add episode info if this is a TV episode
                if (mediaType === 'tv' && season && episode) {
                    doneItem.season = season;
                    doneItem.episode = episode;
                    doneItem.episode_title = title; // Store episode title separately
                }
                
                doneWatchingCache.unshift(doneItem); // Add to beginning
                button.classList.add('is-done');
                button.innerHTML = '<i class="fas fa-check-circle"></i>';
                button.title = 'Remove from Done Watching';
                
                // Sync with Trakt
                if (mediaType === 'movie') {
                    // For movies, mark as watched and add to collection
                    await syncWithTraktWatched('movie', title, year);
                    await syncWithTraktCollection('add', title, 'movie', year);
                } else if (mediaType === 'tv') {
                    if (season && episode) {
                        // For specific episodes
                        await syncWithTraktWatchedEpisode(title, year, season, episode);
                    } else {
                        // For whole shows (only add to collection, not mark entire show as watched)
                        await syncWithTraktCollection('add', title, 'show', year);
                        showNotification(`Added "${title}" to your Trakt collection`, 'success');
                    }
                }
            }

            await saveDoneWatching();
            
            // Refresh Done Watching page if it's currently open
            if (document.getElementById('doneWatchingPage').style.display !== 'none') {
                displayDoneWatching();
            }
        }

        function updateCardDoneStatus(cardElement, id, mediaType) {
            const button = cardElement.querySelector('.done-watching-btn');
            if (!button) return;

            // Only mark as done if the exact title (movie or full show) is in doneWatchingCache,
            // never due to episode entries.
            const isDone = doneWatchingCache.some(item =>
                item.id === id && item.media_type === mediaType && (!item.season && !item.episode)
            );
            
            if (isDone) {
                button.classList.add('is-done');
                button.innerHTML = '<i class="fas fa-check-circle"></i>';
                button.title = 'Remove from Done Watching';
            } else {
                button.classList.remove('is-done');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Mark as Done Watching';
            }
        }

        async function displayDoneWatching() {
            const grid = document.getElementById('doneWatchingGrid');
            const loading = document.getElementById('doneWatchingLoading');
            const empty = document.getElementById('doneWatchingEmpty');
            
            if (!grid) return;

            loading.style.display = 'block';
            empty.style.display = 'none';
            grid.innerHTML = '';

            await loadDoneWatching();

            loading.style.display = 'none';

            if (doneWatchingCache.length === 0) {
                empty.style.display = 'block';
                return;
            }

            // Group episodes by show and keep movies separate
            const groupedItems = new Map();
            
            doneWatchingCache.forEach(item => {
                if (item.media_type === 'tv' && item.season && item.episode) {
                    // This is an individual episode
                    const showKey = `${item.id}-${item.media_type}`;
                    if (!groupedItems.has(showKey)) {
                        groupedItems.set(showKey, {
                            ...item,
                            episodes: [],
                            isGrouped: true
                        });
                    }
                    groupedItems.get(showKey).episodes.push({
                        season: item.season,
                        episode: item.episode,
                        episode_title: item.episode_title,
                        completed_date: item.completed_date
                    });
                } else {
                    // This is a movie or full show
                    const key = `${item.id}-${item.media_type}-single`;
                    groupedItems.set(key, {
                        ...item,
                        isGrouped: false
                    });
                }
            });

            // Sort and display grouped items
            Array.from(groupedItems.values())
                .sort((a, b) => new Date(b.completed_date) - new Date(a.completed_date))
                .forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'movie-card';
                    card.dataset.rating = item.vote_average || 0;
                    card.dataset.date = `${item.year}-01-01`;
                    
                    let displayTitle = item.title;
                    let episodeInfo = '';
                    let episodeBadge = '';
                    
                    if (item.isGrouped && item.episodes && item.episodes.length > 0) {
                        // Sort episodes by season/episode to get the latest
                        const sortedEpisodes = item.episodes.sort((a, b) => {
                            if (a.season !== b.season) return b.season - a.season;
                            return b.episode - a.episode;
                        });
                        
                        const latestEpisode = sortedEpisodes[0];
                        const episodeCount = item.episodes.length;
                        
                        displayTitle = item.title;
                        episodeInfo = `<p class="episode-subtitle">${episodeCount} episode${episodeCount > 1 ? 's' : ''} watched  Latest: S${latestEpisode.season}E${latestEpisode.episode}</p>`;
                        episodeBadge = `<div class="episode-badge"><i class="fas fa-tv"></i> ${episodeCount} Episodes</div>`;
                    }
                    
                    card.innerHTML = `
                        <button class="add-to-list-btn" onclick="toggleMyList(event, ${item.id}, '${item.media_type}', '${item.title.replace(/'/g, "\\'")}', '${item.poster_path}', '${item.year}', ${item.vote_average})">
                            <i class="fas fa-plus"></i>
                        </button>
                        ${item.media_type === 'movie' ? `
                        <button class="done-watching-btn is-done" onclick="toggleDoneWatching(event, ${item.id}, '${item.media_type}', '${item.title.replace(/'/g, "\\'")}', '${item.poster_path}', '${item.year}', ${item.vote_average})">
                            <i class="fas fa-check-circle"></i>
                        </button>` : ''}
                        ${episodeBadge}
                        <img loading="lazy" decoding="async" src="https://image.tmdb.org/t/p/w342${item.poster_path}" alt="${displayTitle}" class="movie-poster">
                        <div class="movie-info">
                            <h3 class="movie-title">${displayTitle}</h3>
                            ${episodeInfo}
                            <p class="movie-year">${item.year}</p>
                        </div>
                        <div class="movie-rating">
                            <i class="fas fa-star"></i> ${Number(item.vote_average).toFixed(1)}
                        </div>
                        ${item.isGrouped ? `
                        <button class="episode-details-btn" onclick="showEpisodeDetails(event, ${item.id}, '${item.title.replace(/'/g, "\\'")}')">
                            <i class="fas fa-list"></i> View ${item.episodes.length} Episode${item.episodes.length > 1 ? 's' : ''}
                        </button>
                        ` : ''}
                    `;
                    card.addEventListener('click', (e) => {
                    if (!e.target.closest('.add-to-list-btn') && !e.target.closest('.done-watching-btn')) {
                        openDetailsModal(item, item.media_type);
                    }
                });
                grid.appendChild(card);
            });
        }

        async function clearDoneWatching() {
            if (confirm('Are you sure you want to clear your entire done watching list? This action cannot be undone.')) {
                doneWatchingCache = [];
                await saveDoneWatching();
                
                // Update all visible cards
                document.querySelectorAll('.done-watching-btn.is-done').forEach(button => {
                    button.classList.remove('is-done');
                    button.innerHTML = '<i class="fas fa-check"></i>';
                    button.title = 'Mark as Done Watching';
                });
                
                // Refresh Done Watching page if open
                if (document.getElementById('doneWatchingPage').style.display !== 'none') {
                    displayDoneWatching();
                }
            }
        }

        // Load both lists on app start
        document.addEventListener('DOMContentLoaded', async () => {
            // Reconcile downloaded music with disk at launch so manually deleted files are not listed
            try { await reconcileDownloadedMusicWithDisk(); } catch(_) {}
            try { renderDownloadedMusic(); } catch(_) {}
            await loadMyList();
            await loadDoneWatching();
            
            // Update existing cards with both list statuses when movies are loaded
            const originalDisplayMovies = displayMovies;
            displayMovies = function(movies, append = true) {
                const result = originalDisplayMovies.call(this, movies, append);
                
                // Update both list and done watching status for newly added cards
                setTimeout(() => {
                    movies.forEach(movie => {
                        const cards = document.querySelectorAll(`[data-rating="${movie.vote_average || 0}"]`);
                        cards.forEach(card => {
                            updateCardListStatus(card, movie.id, movie.media_type || 'movie');
                            updateCardDoneStatus(card, movie.id, movie.media_type || 'movie');
                        });
                    });
                }, 100);
                
                return result;
            };

            // Also update cards for genre items
            const originalDisplayGenreItems = displayGenreItems;
            displayGenreItems = function(items, mediaType) {
                const result = originalDisplayGenreItems.call(this, items, mediaType);
                
                // Update both list and done watching status for genre cards
                setTimeout(() => {
                    items.forEach(item => {
                        const cards = document.querySelectorAll(`.movie-card`);
                        cards.forEach(card => {
                            const cardImg = card.querySelector('img');
                            if (cardImg && cardImg.src.includes(item.poster_path)) {
                                updateCardListStatus(card, item.id, mediaType);
                                updateCardDoneStatus(card, item.id, mediaType);
                            }
                        });
                    });
                }, 100);
                
                return result;
            };

            // Add button handlers
            document.getElementById('clearMyListBtn')?.addEventListener('click', clearMyList);
            document.getElementById('clearDoneWatchingBtn')?.addEventListener('click', clearDoneWatching);
        });
    </script>
    
    <!-- Updater Overlay (enhanced, user-friendly) -->
    <div id="updateOverlay" style="position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:9999; display:none; align-items:center; justify-content:center; backdrop-filter:blur(10px);">
        <div style="background:linear-gradient(135deg, #2a1847 0%, #1f1235 100%); border:2px solid #a855f7; padding:2.5rem; border-radius:16px; width:min(90%, 480px); text-align:center; color:#f8f9fa; box-shadow:0 20px 40px rgba(0,0,0,0.5); position:relative;">
            <!-- Close button (only shown when download is complete) -->
            <button id="updateCloseBtn" onclick="hideOverlay()" style="position:absolute; top:15px; right:15px; background:rgba(255,255,255,0.1); border:none; color:#c084fc; width:32px; height:32px; border-radius:50%; cursor:pointer; display:none; align-items:center; justify-content:center; transition:all 0.2s ease;" onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                <i class="fas fa-times" style="font-size:14px;"></i>
            </button>
            
            <div id="updateStatusIcon" class="fas fa-download" style="font-size:3rem; margin-bottom:1.5rem; color:#a855f7; animation: spin 1s linear infinite;"></div>
            <h2 style="margin:0 0 0.5rem 0; font-size:1.5rem; font-weight:600;">App Update in Progress</h2>
            <p id="updateStatusText" style="margin:0.25rem 0 1.5rem 0; color:#c084fc; font-size:1rem; line-height:1.4;">Update found! Downloading now, please wait...</p>
            <div style="height:12px; background:rgba(255,255,255,0.08); border-radius:12px; overflow:hidden; margin-bottom:12px; box-shadow:inset 0 2px 4px rgba(0,0,0,0.3);">
                <div id="updateProgressBar" style="height:100%; width:0%; background:linear-gradient(90deg, #a855f7, #22c55e); transition:width 0.4s ease; border-radius:12px;"></div>
            </div>
            <div id="updatePercent" style="font-weight:700; color:#a855f7; font-size:1.1rem; margin-bottom:1rem;">0%</div>
            <p id="updateWarningText" style="margin:0.5rem 0 1rem 0; color:#8b5cf6; font-size:0.9rem; opacity:0.8;"> Please do not close the application during the update</p>
            <button id="updateRestartBtn" class="btn btn-primary" style="margin-top:1rem; display:none; padding:0.75rem 2rem; font-size:1rem; border-radius:8px;">
                <i class="fas fa-sync-alt"></i> Restart Now to Complete Update
            </button>
        </div>
    </div>

    <!-- Resume Prompt Modal (top-level) -->
    <div class="modal" id="resumeModal">
        <div class="modal-content" style="max-width:480px">
            <button class="modal-close" id="resumeClose"><i class="fas fa-times"></i></button>
            <div class="modal-header">
                <div class="modal-header-content" style="gap:0.75rem; align-items:center;">
                    <div style="display:flex; align-items:center; gap:0.5rem;">
                        <i class="fas fa-history" style="color: var(--vlc-orange);"></i>
                        <h2 class="modal-title" id="resumeTitle" style="margin:0; font-size:1.3rem;">Resume playback?</h2>
                    </div>
                    <div class="modal-info" style="display:flex; gap:0.5rem; align-items:center;">
                        <span id="resumeTime" class="genre-chip">00:00</span>
                    </div>
                </div>
            </div>
            <div class="modal-body" style="padding-top:0.5rem;">
                <p class="modal-overview" id="resumeText" style="margin-bottom:1rem;">You have previous progress for this title. Would you like to continue from where you left off?</p>
                <div style="display:flex; gap:0.75rem; justify-content:flex-end;">
                    <button class="btn btn-outline" id="resumeStartOver"><i class="fas fa-undo"></i> Start Over</button>
                    <button class="btn" id="resumeContinue"><i class="fas fa-play"></i> Continue</button>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
